
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model card
 * 
 */
export type card = {
  idCard: number
  idInfoPeople: number
  cardNumber: string
  expirationDate: Date
  cvv: number
}

/**
 * Model cash
 * 
 */
export type cash = {
  idCash: number
  cashType: string
}

/**
 * Model clientlocation
 * 
 */
export type clientlocation = {
  idClientLocation: number
  idClientPeople: number
  idLocation: number
}

/**
 * Model clientmembership
 * 
 */
export type clientmembership = {
  idClientMembership: number
  idMembership: number
  idClientPeople: number
}

/**
 * Model clientpeople
 * 
 */
export type clientpeople = {
  idClientPeople: number
  idClientUser: number
  idInfoPeople: number
  salesCounter: number
  isActive: boolean
}

/**
 * Model clientuser
 * 
 */
export type clientuser = {
  idClientUser: number
  userPassword: Buffer
  isActive: boolean
}

/**
 * Model club
 * 
 */
export type club = {
  idClub: number
  clubName: string
  idLocation: number
  deliveryCostProp: number
  idCash: number
  isActive: boolean
}

/**
 * Model complaint
 * 
 */
export type complaint = {
  idComplaint: number
  idWorkerReview: number
  compDescription: string
  solved: boolean
}

/**
 * Model infopeople
 * 
 */
export type infopeople = {
  idInfoPeople: number
  peopleName: string
  surname: string
  email: string
  phoneNumber: number
  birthDate: Date
  isActive: boolean
}

/**
 * Model inventory
 * 
 */
export type inventory = {
  idInventory: number
  idClub: number
  idProduct: number
  stock: number
  isActive: boolean
}

/**
 * Model location
 * 
 */
export type location = {
  idLocation: number
  typeLocation: boolean | null
  isActive: boolean
}

/**
 * Model membership
 * 
 */
export type membership = {
  idMembership: number
  nameMembership: string
  cost: Prisma.Decimal
  productDiscount: number
  deliveryDiscount: number
  isActive: boolean
}

/**
 * Model orderline
 * 
 */
export type orderline = {
  idOrderLine: number
  idOrderP: number
  idProduct: number
  cost: Prisma.Decimal
  amount: number
}

/**
 * Model orderp
 * 
 */
export type orderp = {
  idOrderP: number
  idClientPeople: number
  orderDate: Date
  idClub: number
  idEmployer: number
  idMailer: number
  deliveryCost: Prisma.Decimal
}

/**
 * Model popularproducts
 * 
 */
export type popularproducts = {
  idPopularProducts: number
  idProduct: number
  amount: number
  idClub: number
}

/**
 * Model presentation
 * 
 */
export type presentation = {
  idPresentation: number
  idProduct: number
  amountBottles: number
  sizeBottle: number
}

/**
 * Model product
 * 
 */
export type product = {
  idProduct: number
  productName: string | null
  cost: Prisma.Decimal
  idProductType: number
  image: Buffer | null
  idSupplier: number
  idCash: number
  isActive: boolean
  entryDate: Date
  tier: number
  productDescr: string | null
}

/**
 * Model producttype
 * 
 */
export type producttype = {
  idProductType: number
  typeName: string
  isActive: boolean
}

/**
 * Model qualification
 * 
 */
export type qualification = {
  idQualification: number
  idWorkerReview: number
  qualDescription: string
}

/**
 * Model review
 * 
 */
export type review = {
  idReview: number
  idProduct: number
  score: number
  revDescription: string
  idClientUser: number
  revDate: Date
}

/**
 * Model supplier
 * 
 */
export type supplier = {
  idSupplier: number
  supplierName: string
  isActive: boolean
}

/**
 * Model workerreview
 * 
 */
export type workerreview = {
  idWorkerReview: number
  idClientUser: number
  idWorker: number
  dateWR: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cards
 * const cards = await prisma.card.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cards
   * const cards = await prisma.card.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.card`: Exposes CRUD operations for the **card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.cardDelegate<GlobalReject>;

  /**
   * `prisma.cash`: Exposes CRUD operations for the **cash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cash
    * const cash = await prisma.cash.findMany()
    * ```
    */
  get cash(): Prisma.cashDelegate<GlobalReject>;

  /**
   * `prisma.clientlocation`: Exposes CRUD operations for the **clientlocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientlocations
    * const clientlocations = await prisma.clientlocation.findMany()
    * ```
    */
  get clientlocation(): Prisma.clientlocationDelegate<GlobalReject>;

  /**
   * `prisma.clientmembership`: Exposes CRUD operations for the **clientmembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientmemberships
    * const clientmemberships = await prisma.clientmembership.findMany()
    * ```
    */
  get clientmembership(): Prisma.clientmembershipDelegate<GlobalReject>;

  /**
   * `prisma.clientpeople`: Exposes CRUD operations for the **clientpeople** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientpeople
    * const clientpeople = await prisma.clientpeople.findMany()
    * ```
    */
  get clientpeople(): Prisma.clientpeopleDelegate<GlobalReject>;

  /**
   * `prisma.clientuser`: Exposes CRUD operations for the **clientuser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientusers
    * const clientusers = await prisma.clientuser.findMany()
    * ```
    */
  get clientuser(): Prisma.clientuserDelegate<GlobalReject>;

  /**
   * `prisma.club`: Exposes CRUD operations for the **club** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clubs
    * const clubs = await prisma.club.findMany()
    * ```
    */
  get club(): Prisma.clubDelegate<GlobalReject>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.complaintDelegate<GlobalReject>;

  /**
   * `prisma.infopeople`: Exposes CRUD operations for the **infopeople** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infopeople
    * const infopeople = await prisma.infopeople.findMany()
    * ```
    */
  get infopeople(): Prisma.infopeopleDelegate<GlobalReject>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.inventoryDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<GlobalReject>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.membershipDelegate<GlobalReject>;

  /**
   * `prisma.orderline`: Exposes CRUD operations for the **orderline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderlines
    * const orderlines = await prisma.orderline.findMany()
    * ```
    */
  get orderline(): Prisma.orderlineDelegate<GlobalReject>;

  /**
   * `prisma.orderp`: Exposes CRUD operations for the **orderp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderps
    * const orderps = await prisma.orderp.findMany()
    * ```
    */
  get orderp(): Prisma.orderpDelegate<GlobalReject>;

  /**
   * `prisma.popularproducts`: Exposes CRUD operations for the **popularproducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Popularproducts
    * const popularproducts = await prisma.popularproducts.findMany()
    * ```
    */
  get popularproducts(): Prisma.popularproductsDelegate<GlobalReject>;

  /**
   * `prisma.presentation`: Exposes CRUD operations for the **presentation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presentations
    * const presentations = await prisma.presentation.findMany()
    * ```
    */
  get presentation(): Prisma.presentationDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<GlobalReject>;

  /**
   * `prisma.producttype`: Exposes CRUD operations for the **producttype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Producttypes
    * const producttypes = await prisma.producttype.findMany()
    * ```
    */
  get producttype(): Prisma.producttypeDelegate<GlobalReject>;

  /**
   * `prisma.qualification`: Exposes CRUD operations for the **qualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualifications
    * const qualifications = await prisma.qualification.findMany()
    * ```
    */
  get qualification(): Prisma.qualificationDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<GlobalReject>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<GlobalReject>;

  /**
   * `prisma.workerreview`: Exposes CRUD operations for the **workerreview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workerreviews
    * const workerreviews = await prisma.workerreview.findMany()
    * ```
    */
  get workerreview(): Prisma.workerreviewDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Prisma Client JS version: 3.15.2
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    card: 'card',
    cash: 'cash',
    clientlocation: 'clientlocation',
    clientmembership: 'clientmembership',
    clientpeople: 'clientpeople',
    clientuser: 'clientuser',
    club: 'club',
    complaint: 'complaint',
    infopeople: 'infopeople',
    inventory: 'inventory',
    location: 'location',
    membership: 'membership',
    orderline: 'orderline',
    orderp: 'orderp',
    popularproducts: 'popularproducts',
    presentation: 'presentation',
    product: 'product',
    producttype: 'producttype',
    qualification: 'qualification',
    review: 'review',
    supplier: 'supplier',
    workerreview: 'workerreview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    mysql_Scotland_db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CashCountOutputType
   */


  export type CashCountOutputType = {
    club: number
    product: number
  }

  export type CashCountOutputTypeSelect = {
    club?: boolean
    product?: boolean
  }

  export type CashCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CashCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CashCountOutputType
    : S extends undefined
    ? never
    : S extends CashCountOutputTypeArgs
    ?'include' extends U
    ? CashCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CashCountOutputType ? CashCountOutputType[P] : never
  } 
    : CashCountOutputType
  : CashCountOutputType




  // Custom InputTypes

  /**
   * CashCountOutputType without action
   */
  export type CashCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CashCountOutputType
     * 
    **/
    select?: CashCountOutputTypeSelect | null
  }



  /**
   * Count Type ClientpeopleCountOutputType
   */


  export type ClientpeopleCountOutputType = {
    clientlocation: number
    clientmembership: number
    orderp: number
  }

  export type ClientpeopleCountOutputTypeSelect = {
    clientlocation?: boolean
    clientmembership?: boolean
    orderp?: boolean
  }

  export type ClientpeopleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClientpeopleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClientpeopleCountOutputType
    : S extends undefined
    ? never
    : S extends ClientpeopleCountOutputTypeArgs
    ?'include' extends U
    ? ClientpeopleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClientpeopleCountOutputType ? ClientpeopleCountOutputType[P] : never
  } 
    : ClientpeopleCountOutputType
  : ClientpeopleCountOutputType




  // Custom InputTypes

  /**
   * ClientpeopleCountOutputType without action
   */
  export type ClientpeopleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientpeopleCountOutputType
     * 
    **/
    select?: ClientpeopleCountOutputTypeSelect | null
  }



  /**
   * Count Type ClientuserCountOutputType
   */


  export type ClientuserCountOutputType = {
    clientpeople: number
    review: number
    workerreview: number
  }

  export type ClientuserCountOutputTypeSelect = {
    clientpeople?: boolean
    review?: boolean
    workerreview?: boolean
  }

  export type ClientuserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClientuserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClientuserCountOutputType
    : S extends undefined
    ? never
    : S extends ClientuserCountOutputTypeArgs
    ?'include' extends U
    ? ClientuserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClientuserCountOutputType ? ClientuserCountOutputType[P] : never
  } 
    : ClientuserCountOutputType
  : ClientuserCountOutputType




  // Custom InputTypes

  /**
   * ClientuserCountOutputType without action
   */
  export type ClientuserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClientuserCountOutputType
     * 
    **/
    select?: ClientuserCountOutputTypeSelect | null
  }



  /**
   * Count Type ClubCountOutputType
   */


  export type ClubCountOutputType = {
    inventory: number
    orderp: number
    popularproducts: number
  }

  export type ClubCountOutputTypeSelect = {
    inventory?: boolean
    orderp?: boolean
    popularproducts?: boolean
  }

  export type ClubCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ClubCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ClubCountOutputType
    : S extends undefined
    ? never
    : S extends ClubCountOutputTypeArgs
    ?'include' extends U
    ? ClubCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ClubCountOutputType ? ClubCountOutputType[P] : never
  } 
    : ClubCountOutputType
  : ClubCountOutputType




  // Custom InputTypes

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClubCountOutputType
     * 
    **/
    select?: ClubCountOutputTypeSelect | null
  }



  /**
   * Count Type InfopeopleCountOutputType
   */


  export type InfopeopleCountOutputType = {
    card: number
    clientpeople: number
  }

  export type InfopeopleCountOutputTypeSelect = {
    card?: boolean
    clientpeople?: boolean
  }

  export type InfopeopleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InfopeopleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InfopeopleCountOutputType
    : S extends undefined
    ? never
    : S extends InfopeopleCountOutputTypeArgs
    ?'include' extends U
    ? InfopeopleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InfopeopleCountOutputType ? InfopeopleCountOutputType[P] : never
  } 
    : InfopeopleCountOutputType
  : InfopeopleCountOutputType




  // Custom InputTypes

  /**
   * InfopeopleCountOutputType without action
   */
  export type InfopeopleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InfopeopleCountOutputType
     * 
    **/
    select?: InfopeopleCountOutputTypeSelect | null
  }



  /**
   * Count Type LocationCountOutputType
   */


  export type LocationCountOutputType = {
    clientlocation: number
    club: number
  }

  export type LocationCountOutputTypeSelect = {
    clientlocation?: boolean
    club?: boolean
  }

  export type LocationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LocationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LocationCountOutputType
    : S extends undefined
    ? never
    : S extends LocationCountOutputTypeArgs
    ?'include' extends U
    ? LocationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LocationCountOutputType ? LocationCountOutputType[P] : never
  } 
    : LocationCountOutputType
  : LocationCountOutputType




  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     * 
    **/
    select?: LocationCountOutputTypeSelect | null
  }



  /**
   * Count Type MembershipCountOutputType
   */


  export type MembershipCountOutputType = {
    clientmembership: number
  }

  export type MembershipCountOutputTypeSelect = {
    clientmembership?: boolean
  }

  export type MembershipCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MembershipCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MembershipCountOutputType
    : S extends undefined
    ? never
    : S extends MembershipCountOutputTypeArgs
    ?'include' extends U
    ? MembershipCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MembershipCountOutputType ? MembershipCountOutputType[P] : never
  } 
    : MembershipCountOutputType
  : MembershipCountOutputType




  // Custom InputTypes

  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MembershipCountOutputType
     * 
    **/
    select?: MembershipCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderpCountOutputType
   */


  export type OrderpCountOutputType = {
    orderline: number
  }

  export type OrderpCountOutputTypeSelect = {
    orderline?: boolean
  }

  export type OrderpCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderpCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderpCountOutputType
    : S extends undefined
    ? never
    : S extends OrderpCountOutputTypeArgs
    ?'include' extends U
    ? OrderpCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderpCountOutputType ? OrderpCountOutputType[P] : never
  } 
    : OrderpCountOutputType
  : OrderpCountOutputType




  // Custom InputTypes

  /**
   * OrderpCountOutputType without action
   */
  export type OrderpCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderpCountOutputType
     * 
    **/
    select?: OrderpCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    inventory: number
    orderline: number
    popularproducts: number
    presentation: number
    review: number
  }

  export type ProductCountOutputTypeSelect = {
    inventory?: boolean
    orderline?: boolean
    popularproducts?: boolean
    presentation?: boolean
    review?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type ProducttypeCountOutputType
   */


  export type ProducttypeCountOutputType = {
    product: number
  }

  export type ProducttypeCountOutputTypeSelect = {
    product?: boolean
  }

  export type ProducttypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProducttypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProducttypeCountOutputType
    : S extends undefined
    ? never
    : S extends ProducttypeCountOutputTypeArgs
    ?'include' extends U
    ? ProducttypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProducttypeCountOutputType ? ProducttypeCountOutputType[P] : never
  } 
    : ProducttypeCountOutputType
  : ProducttypeCountOutputType




  // Custom InputTypes

  /**
   * ProducttypeCountOutputType without action
   */
  export type ProducttypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProducttypeCountOutputType
     * 
    **/
    select?: ProducttypeCountOutputTypeSelect | null
  }



  /**
   * Count Type SupplierCountOutputType
   */


  export type SupplierCountOutputType = {
    product: number
  }

  export type SupplierCountOutputTypeSelect = {
    product?: boolean
  }

  export type SupplierCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SupplierCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SupplierCountOutputType
    : S extends undefined
    ? never
    : S extends SupplierCountOutputTypeArgs
    ?'include' extends U
    ? SupplierCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SupplierCountOutputType ? SupplierCountOutputType[P] : never
  } 
    : SupplierCountOutputType
  : SupplierCountOutputType




  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     * 
    **/
    select?: SupplierCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkerreviewCountOutputType
   */


  export type WorkerreviewCountOutputType = {
    complaint: number
    qualification: number
  }

  export type WorkerreviewCountOutputTypeSelect = {
    complaint?: boolean
    qualification?: boolean
  }

  export type WorkerreviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkerreviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkerreviewCountOutputType
    : S extends undefined
    ? never
    : S extends WorkerreviewCountOutputTypeArgs
    ?'include' extends U
    ? WorkerreviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WorkerreviewCountOutputType ? WorkerreviewCountOutputType[P] : never
  } 
    : WorkerreviewCountOutputType
  : WorkerreviewCountOutputType




  // Custom InputTypes

  /**
   * WorkerreviewCountOutputType without action
   */
  export type WorkerreviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkerreviewCountOutputType
     * 
    **/
    select?: WorkerreviewCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model card
   */


  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    idCard: number | null
    idInfoPeople: number | null
    cvv: number | null
  }

  export type CardSumAggregateOutputType = {
    idCard: number | null
    idInfoPeople: number | null
    cvv: number | null
  }

  export type CardMinAggregateOutputType = {
    idCard: number | null
    idInfoPeople: number | null
    cardNumber: string | null
    expirationDate: Date | null
    cvv: number | null
  }

  export type CardMaxAggregateOutputType = {
    idCard: number | null
    idInfoPeople: number | null
    cardNumber: string | null
    expirationDate: Date | null
    cvv: number | null
  }

  export type CardCountAggregateOutputType = {
    idCard: number
    idInfoPeople: number
    cardNumber: number
    expirationDate: number
    cvv: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    idCard?: true
    idInfoPeople?: true
    cvv?: true
  }

  export type CardSumAggregateInputType = {
    idCard?: true
    idInfoPeople?: true
    cvv?: true
  }

  export type CardMinAggregateInputType = {
    idCard?: true
    idInfoPeople?: true
    cardNumber?: true
    expirationDate?: true
    cvv?: true
  }

  export type CardMaxAggregateInputType = {
    idCard?: true
    idInfoPeople?: true
    cardNumber?: true
    expirationDate?: true
    cvv?: true
  }

  export type CardCountAggregateInputType = {
    idCard?: true
    idInfoPeople?: true
    cardNumber?: true
    expirationDate?: true
    cvv?: true
    _all?: true
  }

  export type CardAggregateArgs = {
    /**
     * Filter which card to aggregate.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs = {
    where?: cardWhereInput
    orderBy?: Enumerable<cardOrderByWithAggregationInput>
    by: Array<CardScalarFieldEnum>
    having?: cardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }


  export type CardGroupByOutputType = {
    idCard: number
    idInfoPeople: number
    cardNumber: string
    expirationDate: Date
    cvv: number
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type cardSelect = {
    idCard?: boolean
    idInfoPeople?: boolean
    cardNumber?: boolean
    expirationDate?: boolean
    cvv?: boolean
    infopeople?: boolean | infopeopleArgs
  }

  export type cardInclude = {
    infopeople?: boolean | infopeopleArgs
  }

  export type cardGetPayload<
    S extends boolean | null | undefined | cardArgs,
    U = keyof S
      > = S extends true
        ? card
    : S extends undefined
    ? never
    : S extends cardArgs | cardFindManyArgs
    ?'include' extends U
    ? card  & {
    [P in TrueKeys<S['include']>]:
        P extends 'infopeople' ? infopeopleGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'infopeople' ? infopeopleGetPayload<S['select'][P]> :  P extends keyof card ? card[P] : never
  } 
    : card
  : card


  type cardCountArgs = Merge<
    Omit<cardFindManyArgs, 'select' | 'include'> & {
      select?: CardCountAggregateInputType | true
    }
  >

  export interface cardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Card that matches the filter.
     * @param {cardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'card'> extends True ? CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>> : CheckSelect<T, Prisma__cardClient<card | null >, Prisma__cardClient<cardGetPayload<T> | null >>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'card'> extends True ? CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>> : CheckSelect<T, Prisma__cardClient<card | null >, Prisma__cardClient<cardGetPayload<T> | null >>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `idCard`
     * const cardWithIdCardOnly = await prisma.card.findMany({ select: { idCard: true } })
     * 
    **/
    findMany<T extends cardFindManyArgs>(
      args?: SelectSubset<T, cardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<card>>, PrismaPromise<Array<cardGetPayload<T>>>>

    /**
     * Create a Card.
     * @param {cardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
    **/
    create<T extends cardCreateArgs>(
      args: SelectSubset<T, cardCreateArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Create many Cards.
     *     @param {cardCreateManyArgs} args - Arguments to create many Cards.
     *     @example
     *     // Create many Cards
     *     const card = await prisma.card.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cardCreateManyArgs>(
      args?: SelectSubset<T, cardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {cardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
    **/
    delete<T extends cardDeleteArgs>(
      args: SelectSubset<T, cardDeleteArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Update one Card.
     * @param {cardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cardUpdateArgs>(
      args: SelectSubset<T, cardUpdateArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Delete zero or more Cards.
     * @param {cardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cardDeleteManyArgs>(
      args?: SelectSubset<T, cardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cardUpdateManyArgs>(
      args: SelectSubset<T, cardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {cardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
    **/
    upsert<T extends cardUpsertArgs>(
      args: SelectSubset<T, cardUpsertArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends cardCountArgs>(
      args?: Subset<T, cardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cardClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    infopeople<T extends infopeopleArgs = {}>(args?: Subset<T, infopeopleArgs>): CheckSelect<T, Prisma__infopeopleClient<infopeople | null >, Prisma__infopeopleClient<infopeopleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * card findUnique
   */
  export type cardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Throw an Error if a card can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which card to fetch.
     * 
    **/
    where: cardWhereUniqueInput
  }


  /**
   * card findFirst
   */
  export type cardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Throw an Error if a card can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which card to fetch.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cards.
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cards.
     * 
    **/
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * card findMany
   */
  export type cardFindManyArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter, which cards to fetch.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cards.
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * card create
   */
  export type cardCreateArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The data needed to create a card.
     * 
    **/
    data: XOR<cardCreateInput, cardUncheckedCreateInput>
  }


  /**
   * card createMany
   */
  export type cardCreateManyArgs = {
    /**
     * The data used to create many cards.
     * 
    **/
    data: Enumerable<cardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * card update
   */
  export type cardUpdateArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The data needed to update a card.
     * 
    **/
    data: XOR<cardUpdateInput, cardUncheckedUpdateInput>
    /**
     * Choose, which card to update.
     * 
    **/
    where: cardWhereUniqueInput
  }


  /**
   * card updateMany
   */
  export type cardUpdateManyArgs = {
    /**
     * The data used to update cards.
     * 
    **/
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyInput>
    /**
     * Filter which cards to update
     * 
    **/
    where?: cardWhereInput
  }


  /**
   * card upsert
   */
  export type cardUpsertArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The filter to search for the card to update in case it exists.
     * 
    **/
    where: cardWhereUniqueInput
    /**
     * In case the card found by the `where` argument doesn't exist, create a new card with this data.
     * 
    **/
    create: XOR<cardCreateInput, cardUncheckedCreateInput>
    /**
     * In case the card was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cardUpdateInput, cardUncheckedUpdateInput>
  }


  /**
   * card delete
   */
  export type cardDeleteArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter which card to delete.
     * 
    **/
    where: cardWhereUniqueInput
  }


  /**
   * card deleteMany
   */
  export type cardDeleteManyArgs = {
    /**
     * Filter which cards to delete
     * 
    **/
    where?: cardWhereInput
  }


  /**
   * card without action
   */
  export type cardArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
  }



  /**
   * Model cash
   */


  export type AggregateCash = {
    _count: CashCountAggregateOutputType | null
    _avg: CashAvgAggregateOutputType | null
    _sum: CashSumAggregateOutputType | null
    _min: CashMinAggregateOutputType | null
    _max: CashMaxAggregateOutputType | null
  }

  export type CashAvgAggregateOutputType = {
    idCash: number | null
  }

  export type CashSumAggregateOutputType = {
    idCash: number | null
  }

  export type CashMinAggregateOutputType = {
    idCash: number | null
    cashType: string | null
  }

  export type CashMaxAggregateOutputType = {
    idCash: number | null
    cashType: string | null
  }

  export type CashCountAggregateOutputType = {
    idCash: number
    cashType: number
    _all: number
  }


  export type CashAvgAggregateInputType = {
    idCash?: true
  }

  export type CashSumAggregateInputType = {
    idCash?: true
  }

  export type CashMinAggregateInputType = {
    idCash?: true
    cashType?: true
  }

  export type CashMaxAggregateInputType = {
    idCash?: true
    cashType?: true
  }

  export type CashCountAggregateInputType = {
    idCash?: true
    cashType?: true
    _all?: true
  }

  export type CashAggregateArgs = {
    /**
     * Filter which cash to aggregate.
     * 
    **/
    where?: cashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash to fetch.
     * 
    **/
    orderBy?: Enumerable<cashOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cash
    **/
    _count?: true | CashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashMaxAggregateInputType
  }

  export type GetCashAggregateType<T extends CashAggregateArgs> = {
        [P in keyof T & keyof AggregateCash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCash[P]>
      : GetScalarType<T[P], AggregateCash[P]>
  }




  export type CashGroupByArgs = {
    where?: cashWhereInput
    orderBy?: Enumerable<cashOrderByWithAggregationInput>
    by: Array<CashScalarFieldEnum>
    having?: cashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashCountAggregateInputType | true
    _avg?: CashAvgAggregateInputType
    _sum?: CashSumAggregateInputType
    _min?: CashMinAggregateInputType
    _max?: CashMaxAggregateInputType
  }


  export type CashGroupByOutputType = {
    idCash: number
    cashType: string
    _count: CashCountAggregateOutputType | null
    _avg: CashAvgAggregateOutputType | null
    _sum: CashSumAggregateOutputType | null
    _min: CashMinAggregateOutputType | null
    _max: CashMaxAggregateOutputType | null
  }

  type GetCashGroupByPayload<T extends CashGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashGroupByOutputType[P]>
            : GetScalarType<T[P], CashGroupByOutputType[P]>
        }
      >
    >


  export type cashSelect = {
    idCash?: boolean
    cashType?: boolean
    club?: boolean | clubFindManyArgs
    product?: boolean | productFindManyArgs
    _count?: boolean | CashCountOutputTypeArgs
  }

  export type cashInclude = {
    club?: boolean | clubFindManyArgs
    product?: boolean | productFindManyArgs
    _count?: boolean | CashCountOutputTypeArgs
  }

  export type cashGetPayload<
    S extends boolean | null | undefined | cashArgs,
    U = keyof S
      > = S extends true
        ? cash
    : S extends undefined
    ? never
    : S extends cashArgs | cashFindManyArgs
    ?'include' extends U
    ? cash  & {
    [P in TrueKeys<S['include']>]:
        P extends 'club' ? Array < clubGetPayload<S['include'][P]>>  :
        P extends 'product' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? CashCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'club' ? Array < clubGetPayload<S['select'][P]>>  :
        P extends 'product' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? CashCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof cash ? cash[P] : never
  } 
    : cash
  : cash


  type cashCountArgs = Merge<
    Omit<cashFindManyArgs, 'select' | 'include'> & {
      select?: CashCountAggregateInputType | true
    }
  >

  export interface cashDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Cash that matches the filter.
     * @param {cashFindUniqueArgs} args - Arguments to find a Cash
     * @example
     * // Get one Cash
     * const cash = await prisma.cash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cashFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cashFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cash'> extends True ? CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>> : CheckSelect<T, Prisma__cashClient<cash | null >, Prisma__cashClient<cashGetPayload<T> | null >>

    /**
     * Find the first Cash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashFindFirstArgs} args - Arguments to find a Cash
     * @example
     * // Get one Cash
     * const cash = await prisma.cash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cashFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cashFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cash'> extends True ? CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>> : CheckSelect<T, Prisma__cashClient<cash | null >, Prisma__cashClient<cashGetPayload<T> | null >>

    /**
     * Find zero or more Cash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cash
     * const cash = await prisma.cash.findMany()
     * 
     * // Get first 10 Cash
     * const cash = await prisma.cash.findMany({ take: 10 })
     * 
     * // Only select the `idCash`
     * const cashWithIdCashOnly = await prisma.cash.findMany({ select: { idCash: true } })
     * 
    **/
    findMany<T extends cashFindManyArgs>(
      args?: SelectSubset<T, cashFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cash>>, PrismaPromise<Array<cashGetPayload<T>>>>

    /**
     * Create a Cash.
     * @param {cashCreateArgs} args - Arguments to create a Cash.
     * @example
     * // Create one Cash
     * const Cash = await prisma.cash.create({
     *   data: {
     *     // ... data to create a Cash
     *   }
     * })
     * 
    **/
    create<T extends cashCreateArgs>(
      args: SelectSubset<T, cashCreateArgs>
    ): CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>>

    /**
     * Create many Cash.
     *     @param {cashCreateManyArgs} args - Arguments to create many Cash.
     *     @example
     *     // Create many Cash
     *     const cash = await prisma.cash.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cashCreateManyArgs>(
      args?: SelectSubset<T, cashCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cash.
     * @param {cashDeleteArgs} args - Arguments to delete one Cash.
     * @example
     * // Delete one Cash
     * const Cash = await prisma.cash.delete({
     *   where: {
     *     // ... filter to delete one Cash
     *   }
     * })
     * 
    **/
    delete<T extends cashDeleteArgs>(
      args: SelectSubset<T, cashDeleteArgs>
    ): CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>>

    /**
     * Update one Cash.
     * @param {cashUpdateArgs} args - Arguments to update one Cash.
     * @example
     * // Update one Cash
     * const cash = await prisma.cash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cashUpdateArgs>(
      args: SelectSubset<T, cashUpdateArgs>
    ): CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>>

    /**
     * Delete zero or more Cash.
     * @param {cashDeleteManyArgs} args - Arguments to filter Cash to delete.
     * @example
     * // Delete a few Cash
     * const { count } = await prisma.cash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cashDeleteManyArgs>(
      args?: SelectSubset<T, cashDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cash
     * const cash = await prisma.cash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cashUpdateManyArgs>(
      args: SelectSubset<T, cashUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cash.
     * @param {cashUpsertArgs} args - Arguments to update or create a Cash.
     * @example
     * // Update or create a Cash
     * const cash = await prisma.cash.upsert({
     *   create: {
     *     // ... data to create a Cash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cash we want to update
     *   }
     * })
    **/
    upsert<T extends cashUpsertArgs>(
      args: SelectSubset<T, cashUpsertArgs>
    ): CheckSelect<T, Prisma__cashClient<cash>, Prisma__cashClient<cashGetPayload<T>>>

    /**
     * Count the number of Cash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cashCountArgs} args - Arguments to filter Cash to count.
     * @example
     * // Count the number of Cash
     * const count = await prisma.cash.count({
     *   where: {
     *     // ... the filter for the Cash we want to count
     *   }
     * })
    **/
    count<T extends cashCountArgs>(
      args?: Subset<T, cashCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashAggregateArgs>(args: Subset<T, CashAggregateArgs>): PrismaPromise<GetCashAggregateType<T>>

    /**
     * Group by Cash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashGroupByArgs['orderBy'] }
        : { orderBy?: CashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for cash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cashClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    club<T extends clubFindManyArgs = {}>(args?: Subset<T, clubFindManyArgs>): CheckSelect<T, PrismaPromise<Array<club>>, PrismaPromise<Array<clubGetPayload<T>>>>;

    product<T extends productFindManyArgs = {}>(args?: Subset<T, productFindManyArgs>): CheckSelect<T, PrismaPromise<Array<product>>, PrismaPromise<Array<productGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * cash findUnique
   */
  export type cashFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * Throw an Error if a cash can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cash to fetch.
     * 
    **/
    where: cashWhereUniqueInput
  }


  /**
   * cash findFirst
   */
  export type cashFindFirstArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * Throw an Error if a cash can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cash to fetch.
     * 
    **/
    where?: cashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash to fetch.
     * 
    **/
    orderBy?: Enumerable<cashOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash.
     * 
    **/
    cursor?: cashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash.
     * 
    **/
    distinct?: Enumerable<CashScalarFieldEnum>
  }


  /**
   * cash findMany
   */
  export type cashFindManyArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * Filter, which cash to fetch.
     * 
    **/
    where?: cashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash to fetch.
     * 
    **/
    orderBy?: Enumerable<cashOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cash.
     * 
    **/
    cursor?: cashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CashScalarFieldEnum>
  }


  /**
   * cash create
   */
  export type cashCreateArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * The data needed to create a cash.
     * 
    **/
    data: XOR<cashCreateInput, cashUncheckedCreateInput>
  }


  /**
   * cash createMany
   */
  export type cashCreateManyArgs = {
    /**
     * The data used to create many cash.
     * 
    **/
    data: Enumerable<cashCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cash update
   */
  export type cashUpdateArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * The data needed to update a cash.
     * 
    **/
    data: XOR<cashUpdateInput, cashUncheckedUpdateInput>
    /**
     * Choose, which cash to update.
     * 
    **/
    where: cashWhereUniqueInput
  }


  /**
   * cash updateMany
   */
  export type cashUpdateManyArgs = {
    /**
     * The data used to update cash.
     * 
    **/
    data: XOR<cashUpdateManyMutationInput, cashUncheckedUpdateManyInput>
    /**
     * Filter which cash to update
     * 
    **/
    where?: cashWhereInput
  }


  /**
   * cash upsert
   */
  export type cashUpsertArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * The filter to search for the cash to update in case it exists.
     * 
    **/
    where: cashWhereUniqueInput
    /**
     * In case the cash found by the `where` argument doesn't exist, create a new cash with this data.
     * 
    **/
    create: XOR<cashCreateInput, cashUncheckedCreateInput>
    /**
     * In case the cash was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cashUpdateInput, cashUncheckedUpdateInput>
  }


  /**
   * cash delete
   */
  export type cashDeleteArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
    /**
     * Filter which cash to delete.
     * 
    **/
    where: cashWhereUniqueInput
  }


  /**
   * cash deleteMany
   */
  export type cashDeleteManyArgs = {
    /**
     * Filter which cash to delete
     * 
    **/
    where?: cashWhereInput
  }


  /**
   * cash without action
   */
  export type cashArgs = {
    /**
     * Select specific fields to fetch from the cash
     * 
    **/
    select?: cashSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cashInclude | null
  }



  /**
   * Model clientlocation
   */


  export type AggregateClientlocation = {
    _count: ClientlocationCountAggregateOutputType | null
    _avg: ClientlocationAvgAggregateOutputType | null
    _sum: ClientlocationSumAggregateOutputType | null
    _min: ClientlocationMinAggregateOutputType | null
    _max: ClientlocationMaxAggregateOutputType | null
  }

  export type ClientlocationAvgAggregateOutputType = {
    idClientLocation: number | null
    idClientPeople: number | null
    idLocation: number | null
  }

  export type ClientlocationSumAggregateOutputType = {
    idClientLocation: number | null
    idClientPeople: number | null
    idLocation: number | null
  }

  export type ClientlocationMinAggregateOutputType = {
    idClientLocation: number | null
    idClientPeople: number | null
    idLocation: number | null
  }

  export type ClientlocationMaxAggregateOutputType = {
    idClientLocation: number | null
    idClientPeople: number | null
    idLocation: number | null
  }

  export type ClientlocationCountAggregateOutputType = {
    idClientLocation: number
    idClientPeople: number
    idLocation: number
    _all: number
  }


  export type ClientlocationAvgAggregateInputType = {
    idClientLocation?: true
    idClientPeople?: true
    idLocation?: true
  }

  export type ClientlocationSumAggregateInputType = {
    idClientLocation?: true
    idClientPeople?: true
    idLocation?: true
  }

  export type ClientlocationMinAggregateInputType = {
    idClientLocation?: true
    idClientPeople?: true
    idLocation?: true
  }

  export type ClientlocationMaxAggregateInputType = {
    idClientLocation?: true
    idClientPeople?: true
    idLocation?: true
  }

  export type ClientlocationCountAggregateInputType = {
    idClientLocation?: true
    idClientPeople?: true
    idLocation?: true
    _all?: true
  }

  export type ClientlocationAggregateArgs = {
    /**
     * Filter which clientlocation to aggregate.
     * 
    **/
    where?: clientlocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientlocations to fetch.
     * 
    **/
    orderBy?: Enumerable<clientlocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientlocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientlocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientlocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientlocations
    **/
    _count?: true | ClientlocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientlocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientlocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientlocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientlocationMaxAggregateInputType
  }

  export type GetClientlocationAggregateType<T extends ClientlocationAggregateArgs> = {
        [P in keyof T & keyof AggregateClientlocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientlocation[P]>
      : GetScalarType<T[P], AggregateClientlocation[P]>
  }




  export type ClientlocationGroupByArgs = {
    where?: clientlocationWhereInput
    orderBy?: Enumerable<clientlocationOrderByWithAggregationInput>
    by: Array<ClientlocationScalarFieldEnum>
    having?: clientlocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientlocationCountAggregateInputType | true
    _avg?: ClientlocationAvgAggregateInputType
    _sum?: ClientlocationSumAggregateInputType
    _min?: ClientlocationMinAggregateInputType
    _max?: ClientlocationMaxAggregateInputType
  }


  export type ClientlocationGroupByOutputType = {
    idClientLocation: number
    idClientPeople: number
    idLocation: number
    _count: ClientlocationCountAggregateOutputType | null
    _avg: ClientlocationAvgAggregateOutputType | null
    _sum: ClientlocationSumAggregateOutputType | null
    _min: ClientlocationMinAggregateOutputType | null
    _max: ClientlocationMaxAggregateOutputType | null
  }

  type GetClientlocationGroupByPayload<T extends ClientlocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientlocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientlocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientlocationGroupByOutputType[P]>
            : GetScalarType<T[P], ClientlocationGroupByOutputType[P]>
        }
      >
    >


  export type clientlocationSelect = {
    idClientLocation?: boolean
    idClientPeople?: boolean
    idLocation?: boolean
    clientpeople?: boolean | clientpeopleArgs
    location?: boolean | locationArgs
  }

  export type clientlocationInclude = {
    clientpeople?: boolean | clientpeopleArgs
    location?: boolean | locationArgs
  }

  export type clientlocationGetPayload<
    S extends boolean | null | undefined | clientlocationArgs,
    U = keyof S
      > = S extends true
        ? clientlocation
    : S extends undefined
    ? never
    : S extends clientlocationArgs | clientlocationFindManyArgs
    ?'include' extends U
    ? clientlocation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :  P extends keyof clientlocation ? clientlocation[P] : never
  } 
    : clientlocation
  : clientlocation


  type clientlocationCountArgs = Merge<
    Omit<clientlocationFindManyArgs, 'select' | 'include'> & {
      select?: ClientlocationCountAggregateInputType | true
    }
  >

  export interface clientlocationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Clientlocation that matches the filter.
     * @param {clientlocationFindUniqueArgs} args - Arguments to find a Clientlocation
     * @example
     * // Get one Clientlocation
     * const clientlocation = await prisma.clientlocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientlocationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientlocationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'clientlocation'> extends True ? CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>> : CheckSelect<T, Prisma__clientlocationClient<clientlocation | null >, Prisma__clientlocationClient<clientlocationGetPayload<T> | null >>

    /**
     * Find the first Clientlocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientlocationFindFirstArgs} args - Arguments to find a Clientlocation
     * @example
     * // Get one Clientlocation
     * const clientlocation = await prisma.clientlocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientlocationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientlocationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'clientlocation'> extends True ? CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>> : CheckSelect<T, Prisma__clientlocationClient<clientlocation | null >, Prisma__clientlocationClient<clientlocationGetPayload<T> | null >>

    /**
     * Find zero or more Clientlocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientlocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientlocations
     * const clientlocations = await prisma.clientlocation.findMany()
     * 
     * // Get first 10 Clientlocations
     * const clientlocations = await prisma.clientlocation.findMany({ take: 10 })
     * 
     * // Only select the `idClientLocation`
     * const clientlocationWithIdClientLocationOnly = await prisma.clientlocation.findMany({ select: { idClientLocation: true } })
     * 
    **/
    findMany<T extends clientlocationFindManyArgs>(
      args?: SelectSubset<T, clientlocationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<clientlocation>>, PrismaPromise<Array<clientlocationGetPayload<T>>>>

    /**
     * Create a Clientlocation.
     * @param {clientlocationCreateArgs} args - Arguments to create a Clientlocation.
     * @example
     * // Create one Clientlocation
     * const Clientlocation = await prisma.clientlocation.create({
     *   data: {
     *     // ... data to create a Clientlocation
     *   }
     * })
     * 
    **/
    create<T extends clientlocationCreateArgs>(
      args: SelectSubset<T, clientlocationCreateArgs>
    ): CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>>

    /**
     * Create many Clientlocations.
     *     @param {clientlocationCreateManyArgs} args - Arguments to create many Clientlocations.
     *     @example
     *     // Create many Clientlocations
     *     const clientlocation = await prisma.clientlocation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientlocationCreateManyArgs>(
      args?: SelectSubset<T, clientlocationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Clientlocation.
     * @param {clientlocationDeleteArgs} args - Arguments to delete one Clientlocation.
     * @example
     * // Delete one Clientlocation
     * const Clientlocation = await prisma.clientlocation.delete({
     *   where: {
     *     // ... filter to delete one Clientlocation
     *   }
     * })
     * 
    **/
    delete<T extends clientlocationDeleteArgs>(
      args: SelectSubset<T, clientlocationDeleteArgs>
    ): CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>>

    /**
     * Update one Clientlocation.
     * @param {clientlocationUpdateArgs} args - Arguments to update one Clientlocation.
     * @example
     * // Update one Clientlocation
     * const clientlocation = await prisma.clientlocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientlocationUpdateArgs>(
      args: SelectSubset<T, clientlocationUpdateArgs>
    ): CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>>

    /**
     * Delete zero or more Clientlocations.
     * @param {clientlocationDeleteManyArgs} args - Arguments to filter Clientlocations to delete.
     * @example
     * // Delete a few Clientlocations
     * const { count } = await prisma.clientlocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientlocationDeleteManyArgs>(
      args?: SelectSubset<T, clientlocationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientlocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientlocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientlocations
     * const clientlocation = await prisma.clientlocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientlocationUpdateManyArgs>(
      args: SelectSubset<T, clientlocationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientlocation.
     * @param {clientlocationUpsertArgs} args - Arguments to update or create a Clientlocation.
     * @example
     * // Update or create a Clientlocation
     * const clientlocation = await prisma.clientlocation.upsert({
     *   create: {
     *     // ... data to create a Clientlocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientlocation we want to update
     *   }
     * })
    **/
    upsert<T extends clientlocationUpsertArgs>(
      args: SelectSubset<T, clientlocationUpsertArgs>
    ): CheckSelect<T, Prisma__clientlocationClient<clientlocation>, Prisma__clientlocationClient<clientlocationGetPayload<T>>>

    /**
     * Count the number of Clientlocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientlocationCountArgs} args - Arguments to filter Clientlocations to count.
     * @example
     * // Count the number of Clientlocations
     * const count = await prisma.clientlocation.count({
     *   where: {
     *     // ... the filter for the Clientlocations we want to count
     *   }
     * })
    **/
    count<T extends clientlocationCountArgs>(
      args?: Subset<T, clientlocationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientlocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientlocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientlocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientlocationAggregateArgs>(args: Subset<T, ClientlocationAggregateArgs>): PrismaPromise<GetClientlocationAggregateType<T>>

    /**
     * Group by Clientlocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientlocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientlocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientlocationGroupByArgs['orderBy'] }
        : { orderBy?: ClientlocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientlocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientlocationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientlocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientlocationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientpeople<T extends clientpeopleArgs = {}>(args?: Subset<T, clientpeopleArgs>): CheckSelect<T, Prisma__clientpeopleClient<clientpeople | null >, Prisma__clientpeopleClient<clientpeopleGetPayload<T> | null >>;

    location<T extends locationArgs = {}>(args?: Subset<T, locationArgs>): CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * clientlocation findUnique
   */
  export type clientlocationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * Throw an Error if a clientlocation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientlocation to fetch.
     * 
    **/
    where: clientlocationWhereUniqueInput
  }


  /**
   * clientlocation findFirst
   */
  export type clientlocationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * Throw an Error if a clientlocation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientlocation to fetch.
     * 
    **/
    where?: clientlocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientlocations to fetch.
     * 
    **/
    orderBy?: Enumerable<clientlocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientlocations.
     * 
    **/
    cursor?: clientlocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientlocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientlocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientlocations.
     * 
    **/
    distinct?: Enumerable<ClientlocationScalarFieldEnum>
  }


  /**
   * clientlocation findMany
   */
  export type clientlocationFindManyArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * Filter, which clientlocations to fetch.
     * 
    **/
    where?: clientlocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientlocations to fetch.
     * 
    **/
    orderBy?: Enumerable<clientlocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientlocations.
     * 
    **/
    cursor?: clientlocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientlocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientlocations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientlocationScalarFieldEnum>
  }


  /**
   * clientlocation create
   */
  export type clientlocationCreateArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * The data needed to create a clientlocation.
     * 
    **/
    data: XOR<clientlocationCreateInput, clientlocationUncheckedCreateInput>
  }


  /**
   * clientlocation createMany
   */
  export type clientlocationCreateManyArgs = {
    /**
     * The data used to create many clientlocations.
     * 
    **/
    data: Enumerable<clientlocationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * clientlocation update
   */
  export type clientlocationUpdateArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * The data needed to update a clientlocation.
     * 
    **/
    data: XOR<clientlocationUpdateInput, clientlocationUncheckedUpdateInput>
    /**
     * Choose, which clientlocation to update.
     * 
    **/
    where: clientlocationWhereUniqueInput
  }


  /**
   * clientlocation updateMany
   */
  export type clientlocationUpdateManyArgs = {
    /**
     * The data used to update clientlocations.
     * 
    **/
    data: XOR<clientlocationUpdateManyMutationInput, clientlocationUncheckedUpdateManyInput>
    /**
     * Filter which clientlocations to update
     * 
    **/
    where?: clientlocationWhereInput
  }


  /**
   * clientlocation upsert
   */
  export type clientlocationUpsertArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * The filter to search for the clientlocation to update in case it exists.
     * 
    **/
    where: clientlocationWhereUniqueInput
    /**
     * In case the clientlocation found by the `where` argument doesn't exist, create a new clientlocation with this data.
     * 
    **/
    create: XOR<clientlocationCreateInput, clientlocationUncheckedCreateInput>
    /**
     * In case the clientlocation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientlocationUpdateInput, clientlocationUncheckedUpdateInput>
  }


  /**
   * clientlocation delete
   */
  export type clientlocationDeleteArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
    /**
     * Filter which clientlocation to delete.
     * 
    **/
    where: clientlocationWhereUniqueInput
  }


  /**
   * clientlocation deleteMany
   */
  export type clientlocationDeleteManyArgs = {
    /**
     * Filter which clientlocations to delete
     * 
    **/
    where?: clientlocationWhereInput
  }


  /**
   * clientlocation without action
   */
  export type clientlocationArgs = {
    /**
     * Select specific fields to fetch from the clientlocation
     * 
    **/
    select?: clientlocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientlocationInclude | null
  }



  /**
   * Model clientmembership
   */


  export type AggregateClientmembership = {
    _count: ClientmembershipCountAggregateOutputType | null
    _avg: ClientmembershipAvgAggregateOutputType | null
    _sum: ClientmembershipSumAggregateOutputType | null
    _min: ClientmembershipMinAggregateOutputType | null
    _max: ClientmembershipMaxAggregateOutputType | null
  }

  export type ClientmembershipAvgAggregateOutputType = {
    idClientMembership: number | null
    idMembership: number | null
    idClientPeople: number | null
  }

  export type ClientmembershipSumAggregateOutputType = {
    idClientMembership: number | null
    idMembership: number | null
    idClientPeople: number | null
  }

  export type ClientmembershipMinAggregateOutputType = {
    idClientMembership: number | null
    idMembership: number | null
    idClientPeople: number | null
  }

  export type ClientmembershipMaxAggregateOutputType = {
    idClientMembership: number | null
    idMembership: number | null
    idClientPeople: number | null
  }

  export type ClientmembershipCountAggregateOutputType = {
    idClientMembership: number
    idMembership: number
    idClientPeople: number
    _all: number
  }


  export type ClientmembershipAvgAggregateInputType = {
    idClientMembership?: true
    idMembership?: true
    idClientPeople?: true
  }

  export type ClientmembershipSumAggregateInputType = {
    idClientMembership?: true
    idMembership?: true
    idClientPeople?: true
  }

  export type ClientmembershipMinAggregateInputType = {
    idClientMembership?: true
    idMembership?: true
    idClientPeople?: true
  }

  export type ClientmembershipMaxAggregateInputType = {
    idClientMembership?: true
    idMembership?: true
    idClientPeople?: true
  }

  export type ClientmembershipCountAggregateInputType = {
    idClientMembership?: true
    idMembership?: true
    idClientPeople?: true
    _all?: true
  }

  export type ClientmembershipAggregateArgs = {
    /**
     * Filter which clientmembership to aggregate.
     * 
    **/
    where?: clientmembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientmemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<clientmembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientmembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientmemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientmemberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientmemberships
    **/
    _count?: true | ClientmembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientmembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientmembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientmembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientmembershipMaxAggregateInputType
  }

  export type GetClientmembershipAggregateType<T extends ClientmembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateClientmembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientmembership[P]>
      : GetScalarType<T[P], AggregateClientmembership[P]>
  }




  export type ClientmembershipGroupByArgs = {
    where?: clientmembershipWhereInput
    orderBy?: Enumerable<clientmembershipOrderByWithAggregationInput>
    by: Array<ClientmembershipScalarFieldEnum>
    having?: clientmembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientmembershipCountAggregateInputType | true
    _avg?: ClientmembershipAvgAggregateInputType
    _sum?: ClientmembershipSumAggregateInputType
    _min?: ClientmembershipMinAggregateInputType
    _max?: ClientmembershipMaxAggregateInputType
  }


  export type ClientmembershipGroupByOutputType = {
    idClientMembership: number
    idMembership: number
    idClientPeople: number
    _count: ClientmembershipCountAggregateOutputType | null
    _avg: ClientmembershipAvgAggregateOutputType | null
    _sum: ClientmembershipSumAggregateOutputType | null
    _min: ClientmembershipMinAggregateOutputType | null
    _max: ClientmembershipMaxAggregateOutputType | null
  }

  type GetClientmembershipGroupByPayload<T extends ClientmembershipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientmembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientmembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientmembershipGroupByOutputType[P]>
            : GetScalarType<T[P], ClientmembershipGroupByOutputType[P]>
        }
      >
    >


  export type clientmembershipSelect = {
    idClientMembership?: boolean
    idMembership?: boolean
    idClientPeople?: boolean
    clientpeople?: boolean | clientpeopleArgs
    membership?: boolean | membershipArgs
  }

  export type clientmembershipInclude = {
    clientpeople?: boolean | clientpeopleArgs
    membership?: boolean | membershipArgs
  }

  export type clientmembershipGetPayload<
    S extends boolean | null | undefined | clientmembershipArgs,
    U = keyof S
      > = S extends true
        ? clientmembership
    : S extends undefined
    ? never
    : S extends clientmembershipArgs | clientmembershipFindManyArgs
    ?'include' extends U
    ? clientmembership  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['include'][P]> :
        P extends 'membership' ? membershipGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['select'][P]> :
        P extends 'membership' ? membershipGetPayload<S['select'][P]> :  P extends keyof clientmembership ? clientmembership[P] : never
  } 
    : clientmembership
  : clientmembership


  type clientmembershipCountArgs = Merge<
    Omit<clientmembershipFindManyArgs, 'select' | 'include'> & {
      select?: ClientmembershipCountAggregateInputType | true
    }
  >

  export interface clientmembershipDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Clientmembership that matches the filter.
     * @param {clientmembershipFindUniqueArgs} args - Arguments to find a Clientmembership
     * @example
     * // Get one Clientmembership
     * const clientmembership = await prisma.clientmembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientmembershipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientmembershipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'clientmembership'> extends True ? CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>> : CheckSelect<T, Prisma__clientmembershipClient<clientmembership | null >, Prisma__clientmembershipClient<clientmembershipGetPayload<T> | null >>

    /**
     * Find the first Clientmembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientmembershipFindFirstArgs} args - Arguments to find a Clientmembership
     * @example
     * // Get one Clientmembership
     * const clientmembership = await prisma.clientmembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientmembershipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientmembershipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'clientmembership'> extends True ? CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>> : CheckSelect<T, Prisma__clientmembershipClient<clientmembership | null >, Prisma__clientmembershipClient<clientmembershipGetPayload<T> | null >>

    /**
     * Find zero or more Clientmemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientmembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientmemberships
     * const clientmemberships = await prisma.clientmembership.findMany()
     * 
     * // Get first 10 Clientmemberships
     * const clientmemberships = await prisma.clientmembership.findMany({ take: 10 })
     * 
     * // Only select the `idClientMembership`
     * const clientmembershipWithIdClientMembershipOnly = await prisma.clientmembership.findMany({ select: { idClientMembership: true } })
     * 
    **/
    findMany<T extends clientmembershipFindManyArgs>(
      args?: SelectSubset<T, clientmembershipFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<clientmembership>>, PrismaPromise<Array<clientmembershipGetPayload<T>>>>

    /**
     * Create a Clientmembership.
     * @param {clientmembershipCreateArgs} args - Arguments to create a Clientmembership.
     * @example
     * // Create one Clientmembership
     * const Clientmembership = await prisma.clientmembership.create({
     *   data: {
     *     // ... data to create a Clientmembership
     *   }
     * })
     * 
    **/
    create<T extends clientmembershipCreateArgs>(
      args: SelectSubset<T, clientmembershipCreateArgs>
    ): CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>>

    /**
     * Create many Clientmemberships.
     *     @param {clientmembershipCreateManyArgs} args - Arguments to create many Clientmemberships.
     *     @example
     *     // Create many Clientmemberships
     *     const clientmembership = await prisma.clientmembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientmembershipCreateManyArgs>(
      args?: SelectSubset<T, clientmembershipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Clientmembership.
     * @param {clientmembershipDeleteArgs} args - Arguments to delete one Clientmembership.
     * @example
     * // Delete one Clientmembership
     * const Clientmembership = await prisma.clientmembership.delete({
     *   where: {
     *     // ... filter to delete one Clientmembership
     *   }
     * })
     * 
    **/
    delete<T extends clientmembershipDeleteArgs>(
      args: SelectSubset<T, clientmembershipDeleteArgs>
    ): CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>>

    /**
     * Update one Clientmembership.
     * @param {clientmembershipUpdateArgs} args - Arguments to update one Clientmembership.
     * @example
     * // Update one Clientmembership
     * const clientmembership = await prisma.clientmembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientmembershipUpdateArgs>(
      args: SelectSubset<T, clientmembershipUpdateArgs>
    ): CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>>

    /**
     * Delete zero or more Clientmemberships.
     * @param {clientmembershipDeleteManyArgs} args - Arguments to filter Clientmemberships to delete.
     * @example
     * // Delete a few Clientmemberships
     * const { count } = await prisma.clientmembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientmembershipDeleteManyArgs>(
      args?: SelectSubset<T, clientmembershipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientmemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientmembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientmemberships
     * const clientmembership = await prisma.clientmembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientmembershipUpdateManyArgs>(
      args: SelectSubset<T, clientmembershipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientmembership.
     * @param {clientmembershipUpsertArgs} args - Arguments to update or create a Clientmembership.
     * @example
     * // Update or create a Clientmembership
     * const clientmembership = await prisma.clientmembership.upsert({
     *   create: {
     *     // ... data to create a Clientmembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientmembership we want to update
     *   }
     * })
    **/
    upsert<T extends clientmembershipUpsertArgs>(
      args: SelectSubset<T, clientmembershipUpsertArgs>
    ): CheckSelect<T, Prisma__clientmembershipClient<clientmembership>, Prisma__clientmembershipClient<clientmembershipGetPayload<T>>>

    /**
     * Count the number of Clientmemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientmembershipCountArgs} args - Arguments to filter Clientmemberships to count.
     * @example
     * // Count the number of Clientmemberships
     * const count = await prisma.clientmembership.count({
     *   where: {
     *     // ... the filter for the Clientmemberships we want to count
     *   }
     * })
    **/
    count<T extends clientmembershipCountArgs>(
      args?: Subset<T, clientmembershipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientmembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientmembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientmembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientmembershipAggregateArgs>(args: Subset<T, ClientmembershipAggregateArgs>): PrismaPromise<GetClientmembershipAggregateType<T>>

    /**
     * Group by Clientmembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientmembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientmembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientmembershipGroupByArgs['orderBy'] }
        : { orderBy?: ClientmembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientmembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientmembershipGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientmembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientmembershipClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientpeople<T extends clientpeopleArgs = {}>(args?: Subset<T, clientpeopleArgs>): CheckSelect<T, Prisma__clientpeopleClient<clientpeople | null >, Prisma__clientpeopleClient<clientpeopleGetPayload<T> | null >>;

    membership<T extends membershipArgs = {}>(args?: Subset<T, membershipArgs>): CheckSelect<T, Prisma__membershipClient<membership | null >, Prisma__membershipClient<membershipGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * clientmembership findUnique
   */
  export type clientmembershipFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * Throw an Error if a clientmembership can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientmembership to fetch.
     * 
    **/
    where: clientmembershipWhereUniqueInput
  }


  /**
   * clientmembership findFirst
   */
  export type clientmembershipFindFirstArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * Throw an Error if a clientmembership can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientmembership to fetch.
     * 
    **/
    where?: clientmembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientmemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<clientmembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientmemberships.
     * 
    **/
    cursor?: clientmembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientmemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientmemberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientmemberships.
     * 
    **/
    distinct?: Enumerable<ClientmembershipScalarFieldEnum>
  }


  /**
   * clientmembership findMany
   */
  export type clientmembershipFindManyArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * Filter, which clientmemberships to fetch.
     * 
    **/
    where?: clientmembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientmemberships to fetch.
     * 
    **/
    orderBy?: Enumerable<clientmembershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientmemberships.
     * 
    **/
    cursor?: clientmembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientmemberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientmemberships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientmembershipScalarFieldEnum>
  }


  /**
   * clientmembership create
   */
  export type clientmembershipCreateArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * The data needed to create a clientmembership.
     * 
    **/
    data: XOR<clientmembershipCreateInput, clientmembershipUncheckedCreateInput>
  }


  /**
   * clientmembership createMany
   */
  export type clientmembershipCreateManyArgs = {
    /**
     * The data used to create many clientmemberships.
     * 
    **/
    data: Enumerable<clientmembershipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * clientmembership update
   */
  export type clientmembershipUpdateArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * The data needed to update a clientmembership.
     * 
    **/
    data: XOR<clientmembershipUpdateInput, clientmembershipUncheckedUpdateInput>
    /**
     * Choose, which clientmembership to update.
     * 
    **/
    where: clientmembershipWhereUniqueInput
  }


  /**
   * clientmembership updateMany
   */
  export type clientmembershipUpdateManyArgs = {
    /**
     * The data used to update clientmemberships.
     * 
    **/
    data: XOR<clientmembershipUpdateManyMutationInput, clientmembershipUncheckedUpdateManyInput>
    /**
     * Filter which clientmemberships to update
     * 
    **/
    where?: clientmembershipWhereInput
  }


  /**
   * clientmembership upsert
   */
  export type clientmembershipUpsertArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * The filter to search for the clientmembership to update in case it exists.
     * 
    **/
    where: clientmembershipWhereUniqueInput
    /**
     * In case the clientmembership found by the `where` argument doesn't exist, create a new clientmembership with this data.
     * 
    **/
    create: XOR<clientmembershipCreateInput, clientmembershipUncheckedCreateInput>
    /**
     * In case the clientmembership was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientmembershipUpdateInput, clientmembershipUncheckedUpdateInput>
  }


  /**
   * clientmembership delete
   */
  export type clientmembershipDeleteArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
    /**
     * Filter which clientmembership to delete.
     * 
    **/
    where: clientmembershipWhereUniqueInput
  }


  /**
   * clientmembership deleteMany
   */
  export type clientmembershipDeleteManyArgs = {
    /**
     * Filter which clientmemberships to delete
     * 
    **/
    where?: clientmembershipWhereInput
  }


  /**
   * clientmembership without action
   */
  export type clientmembershipArgs = {
    /**
     * Select specific fields to fetch from the clientmembership
     * 
    **/
    select?: clientmembershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientmembershipInclude | null
  }



  /**
   * Model clientpeople
   */


  export type AggregateClientpeople = {
    _count: ClientpeopleCountAggregateOutputType | null
    _avg: ClientpeopleAvgAggregateOutputType | null
    _sum: ClientpeopleSumAggregateOutputType | null
    _min: ClientpeopleMinAggregateOutputType | null
    _max: ClientpeopleMaxAggregateOutputType | null
  }

  export type ClientpeopleAvgAggregateOutputType = {
    idClientPeople: number | null
    idClientUser: number | null
    idInfoPeople: number | null
    salesCounter: number | null
  }

  export type ClientpeopleSumAggregateOutputType = {
    idClientPeople: number | null
    idClientUser: number | null
    idInfoPeople: number | null
    salesCounter: number | null
  }

  export type ClientpeopleMinAggregateOutputType = {
    idClientPeople: number | null
    idClientUser: number | null
    idInfoPeople: number | null
    salesCounter: number | null
    isActive: boolean | null
  }

  export type ClientpeopleMaxAggregateOutputType = {
    idClientPeople: number | null
    idClientUser: number | null
    idInfoPeople: number | null
    salesCounter: number | null
    isActive: boolean | null
  }

  export type ClientpeopleCountAggregateOutputType = {
    idClientPeople: number
    idClientUser: number
    idInfoPeople: number
    salesCounter: number
    isActive: number
    _all: number
  }


  export type ClientpeopleAvgAggregateInputType = {
    idClientPeople?: true
    idClientUser?: true
    idInfoPeople?: true
    salesCounter?: true
  }

  export type ClientpeopleSumAggregateInputType = {
    idClientPeople?: true
    idClientUser?: true
    idInfoPeople?: true
    salesCounter?: true
  }

  export type ClientpeopleMinAggregateInputType = {
    idClientPeople?: true
    idClientUser?: true
    idInfoPeople?: true
    salesCounter?: true
    isActive?: true
  }

  export type ClientpeopleMaxAggregateInputType = {
    idClientPeople?: true
    idClientUser?: true
    idInfoPeople?: true
    salesCounter?: true
    isActive?: true
  }

  export type ClientpeopleCountAggregateInputType = {
    idClientPeople?: true
    idClientUser?: true
    idInfoPeople?: true
    salesCounter?: true
    isActive?: true
    _all?: true
  }

  export type ClientpeopleAggregateArgs = {
    /**
     * Filter which clientpeople to aggregate.
     * 
    **/
    where?: clientpeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientpeople to fetch.
     * 
    **/
    orderBy?: Enumerable<clientpeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientpeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientpeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientpeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientpeople
    **/
    _count?: true | ClientpeopleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientpeopleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientpeopleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientpeopleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientpeopleMaxAggregateInputType
  }

  export type GetClientpeopleAggregateType<T extends ClientpeopleAggregateArgs> = {
        [P in keyof T & keyof AggregateClientpeople]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientpeople[P]>
      : GetScalarType<T[P], AggregateClientpeople[P]>
  }




  export type ClientpeopleGroupByArgs = {
    where?: clientpeopleWhereInput
    orderBy?: Enumerable<clientpeopleOrderByWithAggregationInput>
    by: Array<ClientpeopleScalarFieldEnum>
    having?: clientpeopleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientpeopleCountAggregateInputType | true
    _avg?: ClientpeopleAvgAggregateInputType
    _sum?: ClientpeopleSumAggregateInputType
    _min?: ClientpeopleMinAggregateInputType
    _max?: ClientpeopleMaxAggregateInputType
  }


  export type ClientpeopleGroupByOutputType = {
    idClientPeople: number
    idClientUser: number
    idInfoPeople: number
    salesCounter: number
    isActive: boolean
    _count: ClientpeopleCountAggregateOutputType | null
    _avg: ClientpeopleAvgAggregateOutputType | null
    _sum: ClientpeopleSumAggregateOutputType | null
    _min: ClientpeopleMinAggregateOutputType | null
    _max: ClientpeopleMaxAggregateOutputType | null
  }

  type GetClientpeopleGroupByPayload<T extends ClientpeopleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientpeopleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientpeopleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientpeopleGroupByOutputType[P]>
            : GetScalarType<T[P], ClientpeopleGroupByOutputType[P]>
        }
      >
    >


  export type clientpeopleSelect = {
    idClientPeople?: boolean
    idClientUser?: boolean
    idInfoPeople?: boolean
    salesCounter?: boolean
    isActive?: boolean
    clientuser?: boolean | clientuserArgs
    infopeople?: boolean | infopeopleArgs
    clientlocation?: boolean | clientlocationFindManyArgs
    clientmembership?: boolean | clientmembershipFindManyArgs
    orderp?: boolean | orderpFindManyArgs
    _count?: boolean | ClientpeopleCountOutputTypeArgs
  }

  export type clientpeopleInclude = {
    clientuser?: boolean | clientuserArgs
    infopeople?: boolean | infopeopleArgs
    clientlocation?: boolean | clientlocationFindManyArgs
    clientmembership?: boolean | clientmembershipFindManyArgs
    orderp?: boolean | orderpFindManyArgs
    _count?: boolean | ClientpeopleCountOutputTypeArgs
  }

  export type clientpeopleGetPayload<
    S extends boolean | null | undefined | clientpeopleArgs,
    U = keyof S
      > = S extends true
        ? clientpeople
    : S extends undefined
    ? never
    : S extends clientpeopleArgs | clientpeopleFindManyArgs
    ?'include' extends U
    ? clientpeople  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['include'][P]> :
        P extends 'infopeople' ? infopeopleGetPayload<S['include'][P]> :
        P extends 'clientlocation' ? Array < clientlocationGetPayload<S['include'][P]>>  :
        P extends 'clientmembership' ? Array < clientmembershipGetPayload<S['include'][P]>>  :
        P extends 'orderp' ? Array < orderpGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientpeopleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['select'][P]> :
        P extends 'infopeople' ? infopeopleGetPayload<S['select'][P]> :
        P extends 'clientlocation' ? Array < clientlocationGetPayload<S['select'][P]>>  :
        P extends 'clientmembership' ? Array < clientmembershipGetPayload<S['select'][P]>>  :
        P extends 'orderp' ? Array < orderpGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientpeopleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof clientpeople ? clientpeople[P] : never
  } 
    : clientpeople
  : clientpeople


  type clientpeopleCountArgs = Merge<
    Omit<clientpeopleFindManyArgs, 'select' | 'include'> & {
      select?: ClientpeopleCountAggregateInputType | true
    }
  >

  export interface clientpeopleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Clientpeople that matches the filter.
     * @param {clientpeopleFindUniqueArgs} args - Arguments to find a Clientpeople
     * @example
     * // Get one Clientpeople
     * const clientpeople = await prisma.clientpeople.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientpeopleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientpeopleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'clientpeople'> extends True ? CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>> : CheckSelect<T, Prisma__clientpeopleClient<clientpeople | null >, Prisma__clientpeopleClient<clientpeopleGetPayload<T> | null >>

    /**
     * Find the first Clientpeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientpeopleFindFirstArgs} args - Arguments to find a Clientpeople
     * @example
     * // Get one Clientpeople
     * const clientpeople = await prisma.clientpeople.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientpeopleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientpeopleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'clientpeople'> extends True ? CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>> : CheckSelect<T, Prisma__clientpeopleClient<clientpeople | null >, Prisma__clientpeopleClient<clientpeopleGetPayload<T> | null >>

    /**
     * Find zero or more Clientpeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientpeopleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientpeople
     * const clientpeople = await prisma.clientpeople.findMany()
     * 
     * // Get first 10 Clientpeople
     * const clientpeople = await prisma.clientpeople.findMany({ take: 10 })
     * 
     * // Only select the `idClientPeople`
     * const clientpeopleWithIdClientPeopleOnly = await prisma.clientpeople.findMany({ select: { idClientPeople: true } })
     * 
    **/
    findMany<T extends clientpeopleFindManyArgs>(
      args?: SelectSubset<T, clientpeopleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<clientpeople>>, PrismaPromise<Array<clientpeopleGetPayload<T>>>>

    /**
     * Create a Clientpeople.
     * @param {clientpeopleCreateArgs} args - Arguments to create a Clientpeople.
     * @example
     * // Create one Clientpeople
     * const Clientpeople = await prisma.clientpeople.create({
     *   data: {
     *     // ... data to create a Clientpeople
     *   }
     * })
     * 
    **/
    create<T extends clientpeopleCreateArgs>(
      args: SelectSubset<T, clientpeopleCreateArgs>
    ): CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>>

    /**
     * Create many Clientpeople.
     *     @param {clientpeopleCreateManyArgs} args - Arguments to create many Clientpeople.
     *     @example
     *     // Create many Clientpeople
     *     const clientpeople = await prisma.clientpeople.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientpeopleCreateManyArgs>(
      args?: SelectSubset<T, clientpeopleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Clientpeople.
     * @param {clientpeopleDeleteArgs} args - Arguments to delete one Clientpeople.
     * @example
     * // Delete one Clientpeople
     * const Clientpeople = await prisma.clientpeople.delete({
     *   where: {
     *     // ... filter to delete one Clientpeople
     *   }
     * })
     * 
    **/
    delete<T extends clientpeopleDeleteArgs>(
      args: SelectSubset<T, clientpeopleDeleteArgs>
    ): CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>>

    /**
     * Update one Clientpeople.
     * @param {clientpeopleUpdateArgs} args - Arguments to update one Clientpeople.
     * @example
     * // Update one Clientpeople
     * const clientpeople = await prisma.clientpeople.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientpeopleUpdateArgs>(
      args: SelectSubset<T, clientpeopleUpdateArgs>
    ): CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>>

    /**
     * Delete zero or more Clientpeople.
     * @param {clientpeopleDeleteManyArgs} args - Arguments to filter Clientpeople to delete.
     * @example
     * // Delete a few Clientpeople
     * const { count } = await prisma.clientpeople.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientpeopleDeleteManyArgs>(
      args?: SelectSubset<T, clientpeopleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientpeopleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientpeople
     * const clientpeople = await prisma.clientpeople.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientpeopleUpdateManyArgs>(
      args: SelectSubset<T, clientpeopleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientpeople.
     * @param {clientpeopleUpsertArgs} args - Arguments to update or create a Clientpeople.
     * @example
     * // Update or create a Clientpeople
     * const clientpeople = await prisma.clientpeople.upsert({
     *   create: {
     *     // ... data to create a Clientpeople
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientpeople we want to update
     *   }
     * })
    **/
    upsert<T extends clientpeopleUpsertArgs>(
      args: SelectSubset<T, clientpeopleUpsertArgs>
    ): CheckSelect<T, Prisma__clientpeopleClient<clientpeople>, Prisma__clientpeopleClient<clientpeopleGetPayload<T>>>

    /**
     * Count the number of Clientpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientpeopleCountArgs} args - Arguments to filter Clientpeople to count.
     * @example
     * // Count the number of Clientpeople
     * const count = await prisma.clientpeople.count({
     *   where: {
     *     // ... the filter for the Clientpeople we want to count
     *   }
     * })
    **/
    count<T extends clientpeopleCountArgs>(
      args?: Subset<T, clientpeopleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientpeopleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientpeopleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientpeopleAggregateArgs>(args: Subset<T, ClientpeopleAggregateArgs>): PrismaPromise<GetClientpeopleAggregateType<T>>

    /**
     * Group by Clientpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientpeopleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientpeopleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientpeopleGroupByArgs['orderBy'] }
        : { orderBy?: ClientpeopleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientpeopleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientpeopleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientpeople.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientpeopleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientuser<T extends clientuserArgs = {}>(args?: Subset<T, clientuserArgs>): CheckSelect<T, Prisma__clientuserClient<clientuser | null >, Prisma__clientuserClient<clientuserGetPayload<T> | null >>;

    infopeople<T extends infopeopleArgs = {}>(args?: Subset<T, infopeopleArgs>): CheckSelect<T, Prisma__infopeopleClient<infopeople | null >, Prisma__infopeopleClient<infopeopleGetPayload<T> | null >>;

    clientlocation<T extends clientlocationFindManyArgs = {}>(args?: Subset<T, clientlocationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientlocation>>, PrismaPromise<Array<clientlocationGetPayload<T>>>>;

    clientmembership<T extends clientmembershipFindManyArgs = {}>(args?: Subset<T, clientmembershipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientmembership>>, PrismaPromise<Array<clientmembershipGetPayload<T>>>>;

    orderp<T extends orderpFindManyArgs = {}>(args?: Subset<T, orderpFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orderp>>, PrismaPromise<Array<orderpGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * clientpeople findUnique
   */
  export type clientpeopleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * Throw an Error if a clientpeople can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientpeople to fetch.
     * 
    **/
    where: clientpeopleWhereUniqueInput
  }


  /**
   * clientpeople findFirst
   */
  export type clientpeopleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * Throw an Error if a clientpeople can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientpeople to fetch.
     * 
    **/
    where?: clientpeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientpeople to fetch.
     * 
    **/
    orderBy?: Enumerable<clientpeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientpeople.
     * 
    **/
    cursor?: clientpeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientpeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientpeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientpeople.
     * 
    **/
    distinct?: Enumerable<ClientpeopleScalarFieldEnum>
  }


  /**
   * clientpeople findMany
   */
  export type clientpeopleFindManyArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * Filter, which clientpeople to fetch.
     * 
    **/
    where?: clientpeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientpeople to fetch.
     * 
    **/
    orderBy?: Enumerable<clientpeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientpeople.
     * 
    **/
    cursor?: clientpeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientpeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientpeople.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientpeopleScalarFieldEnum>
  }


  /**
   * clientpeople create
   */
  export type clientpeopleCreateArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * The data needed to create a clientpeople.
     * 
    **/
    data: XOR<clientpeopleCreateInput, clientpeopleUncheckedCreateInput>
  }


  /**
   * clientpeople createMany
   */
  export type clientpeopleCreateManyArgs = {
    /**
     * The data used to create many clientpeople.
     * 
    **/
    data: Enumerable<clientpeopleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * clientpeople update
   */
  export type clientpeopleUpdateArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * The data needed to update a clientpeople.
     * 
    **/
    data: XOR<clientpeopleUpdateInput, clientpeopleUncheckedUpdateInput>
    /**
     * Choose, which clientpeople to update.
     * 
    **/
    where: clientpeopleWhereUniqueInput
  }


  /**
   * clientpeople updateMany
   */
  export type clientpeopleUpdateManyArgs = {
    /**
     * The data used to update clientpeople.
     * 
    **/
    data: XOR<clientpeopleUpdateManyMutationInput, clientpeopleUncheckedUpdateManyInput>
    /**
     * Filter which clientpeople to update
     * 
    **/
    where?: clientpeopleWhereInput
  }


  /**
   * clientpeople upsert
   */
  export type clientpeopleUpsertArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * The filter to search for the clientpeople to update in case it exists.
     * 
    **/
    where: clientpeopleWhereUniqueInput
    /**
     * In case the clientpeople found by the `where` argument doesn't exist, create a new clientpeople with this data.
     * 
    **/
    create: XOR<clientpeopleCreateInput, clientpeopleUncheckedCreateInput>
    /**
     * In case the clientpeople was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientpeopleUpdateInput, clientpeopleUncheckedUpdateInput>
  }


  /**
   * clientpeople delete
   */
  export type clientpeopleDeleteArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
    /**
     * Filter which clientpeople to delete.
     * 
    **/
    where: clientpeopleWhereUniqueInput
  }


  /**
   * clientpeople deleteMany
   */
  export type clientpeopleDeleteManyArgs = {
    /**
     * Filter which clientpeople to delete
     * 
    **/
    where?: clientpeopleWhereInput
  }


  /**
   * clientpeople without action
   */
  export type clientpeopleArgs = {
    /**
     * Select specific fields to fetch from the clientpeople
     * 
    **/
    select?: clientpeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientpeopleInclude | null
  }



  /**
   * Model clientuser
   */


  export type AggregateClientuser = {
    _count: ClientuserCountAggregateOutputType | null
    _avg: ClientuserAvgAggregateOutputType | null
    _sum: ClientuserSumAggregateOutputType | null
    _min: ClientuserMinAggregateOutputType | null
    _max: ClientuserMaxAggregateOutputType | null
  }

  export type ClientuserAvgAggregateOutputType = {
    idClientUser: number | null
  }

  export type ClientuserSumAggregateOutputType = {
    idClientUser: number | null
  }

  export type ClientuserMinAggregateOutputType = {
    idClientUser: number | null
    userPassword: Buffer | null
    isActive: boolean | null
  }

  export type ClientuserMaxAggregateOutputType = {
    idClientUser: number | null
    userPassword: Buffer | null
    isActive: boolean | null
  }

  export type ClientuserCountAggregateOutputType = {
    idClientUser: number
    userPassword: number
    isActive: number
    _all: number
  }


  export type ClientuserAvgAggregateInputType = {
    idClientUser?: true
  }

  export type ClientuserSumAggregateInputType = {
    idClientUser?: true
  }

  export type ClientuserMinAggregateInputType = {
    idClientUser?: true
    userPassword?: true
    isActive?: true
  }

  export type ClientuserMaxAggregateInputType = {
    idClientUser?: true
    userPassword?: true
    isActive?: true
  }

  export type ClientuserCountAggregateInputType = {
    idClientUser?: true
    userPassword?: true
    isActive?: true
    _all?: true
  }

  export type ClientuserAggregateArgs = {
    /**
     * Filter which clientuser to aggregate.
     * 
    **/
    where?: clientuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientusers to fetch.
     * 
    **/
    orderBy?: Enumerable<clientuserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clientuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientusers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientusers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientusers
    **/
    _count?: true | ClientuserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientuserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientuserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientuserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientuserMaxAggregateInputType
  }

  export type GetClientuserAggregateType<T extends ClientuserAggregateArgs> = {
        [P in keyof T & keyof AggregateClientuser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientuser[P]>
      : GetScalarType<T[P], AggregateClientuser[P]>
  }




  export type ClientuserGroupByArgs = {
    where?: clientuserWhereInput
    orderBy?: Enumerable<clientuserOrderByWithAggregationInput>
    by: Array<ClientuserScalarFieldEnum>
    having?: clientuserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientuserCountAggregateInputType | true
    _avg?: ClientuserAvgAggregateInputType
    _sum?: ClientuserSumAggregateInputType
    _min?: ClientuserMinAggregateInputType
    _max?: ClientuserMaxAggregateInputType
  }


  export type ClientuserGroupByOutputType = {
    idClientUser: number
    userPassword: Buffer
    isActive: boolean
    _count: ClientuserCountAggregateOutputType | null
    _avg: ClientuserAvgAggregateOutputType | null
    _sum: ClientuserSumAggregateOutputType | null
    _min: ClientuserMinAggregateOutputType | null
    _max: ClientuserMaxAggregateOutputType | null
  }

  type GetClientuserGroupByPayload<T extends ClientuserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClientuserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientuserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientuserGroupByOutputType[P]>
            : GetScalarType<T[P], ClientuserGroupByOutputType[P]>
        }
      >
    >


  export type clientuserSelect = {
    idClientUser?: boolean
    userPassword?: boolean
    isActive?: boolean
    clientpeople?: boolean | clientpeopleFindManyArgs
    review?: boolean | reviewFindManyArgs
    workerreview?: boolean | workerreviewFindManyArgs
    _count?: boolean | ClientuserCountOutputTypeArgs
  }

  export type clientuserInclude = {
    clientpeople?: boolean | clientpeopleFindManyArgs
    review?: boolean | reviewFindManyArgs
    workerreview?: boolean | workerreviewFindManyArgs
    _count?: boolean | ClientuserCountOutputTypeArgs
  }

  export type clientuserGetPayload<
    S extends boolean | null | undefined | clientuserArgs,
    U = keyof S
      > = S extends true
        ? clientuser
    : S extends undefined
    ? never
    : S extends clientuserArgs | clientuserFindManyArgs
    ?'include' extends U
    ? clientuser  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientpeople' ? Array < clientpeopleGetPayload<S['include'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'workerreview' ? Array < workerreviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClientuserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientpeople' ? Array < clientpeopleGetPayload<S['select'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'workerreview' ? Array < workerreviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClientuserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof clientuser ? clientuser[P] : never
  } 
    : clientuser
  : clientuser


  type clientuserCountArgs = Merge<
    Omit<clientuserFindManyArgs, 'select' | 'include'> & {
      select?: ClientuserCountAggregateInputType | true
    }
  >

  export interface clientuserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Clientuser that matches the filter.
     * @param {clientuserFindUniqueArgs} args - Arguments to find a Clientuser
     * @example
     * // Get one Clientuser
     * const clientuser = await prisma.clientuser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clientuserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clientuserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'clientuser'> extends True ? CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>> : CheckSelect<T, Prisma__clientuserClient<clientuser | null >, Prisma__clientuserClient<clientuserGetPayload<T> | null >>

    /**
     * Find the first Clientuser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientuserFindFirstArgs} args - Arguments to find a Clientuser
     * @example
     * // Get one Clientuser
     * const clientuser = await prisma.clientuser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clientuserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clientuserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'clientuser'> extends True ? CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>> : CheckSelect<T, Prisma__clientuserClient<clientuser | null >, Prisma__clientuserClient<clientuserGetPayload<T> | null >>

    /**
     * Find zero or more Clientusers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientuserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientusers
     * const clientusers = await prisma.clientuser.findMany()
     * 
     * // Get first 10 Clientusers
     * const clientusers = await prisma.clientuser.findMany({ take: 10 })
     * 
     * // Only select the `idClientUser`
     * const clientuserWithIdClientUserOnly = await prisma.clientuser.findMany({ select: { idClientUser: true } })
     * 
    **/
    findMany<T extends clientuserFindManyArgs>(
      args?: SelectSubset<T, clientuserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<clientuser>>, PrismaPromise<Array<clientuserGetPayload<T>>>>

    /**
     * Create a Clientuser.
     * @param {clientuserCreateArgs} args - Arguments to create a Clientuser.
     * @example
     * // Create one Clientuser
     * const Clientuser = await prisma.clientuser.create({
     *   data: {
     *     // ... data to create a Clientuser
     *   }
     * })
     * 
    **/
    create<T extends clientuserCreateArgs>(
      args: SelectSubset<T, clientuserCreateArgs>
    ): CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>>

    /**
     * Create many Clientusers.
     *     @param {clientuserCreateManyArgs} args - Arguments to create many Clientusers.
     *     @example
     *     // Create many Clientusers
     *     const clientuser = await prisma.clientuser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clientuserCreateManyArgs>(
      args?: SelectSubset<T, clientuserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Clientuser.
     * @param {clientuserDeleteArgs} args - Arguments to delete one Clientuser.
     * @example
     * // Delete one Clientuser
     * const Clientuser = await prisma.clientuser.delete({
     *   where: {
     *     // ... filter to delete one Clientuser
     *   }
     * })
     * 
    **/
    delete<T extends clientuserDeleteArgs>(
      args: SelectSubset<T, clientuserDeleteArgs>
    ): CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>>

    /**
     * Update one Clientuser.
     * @param {clientuserUpdateArgs} args - Arguments to update one Clientuser.
     * @example
     * // Update one Clientuser
     * const clientuser = await prisma.clientuser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clientuserUpdateArgs>(
      args: SelectSubset<T, clientuserUpdateArgs>
    ): CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>>

    /**
     * Delete zero or more Clientusers.
     * @param {clientuserDeleteManyArgs} args - Arguments to filter Clientusers to delete.
     * @example
     * // Delete a few Clientusers
     * const { count } = await prisma.clientuser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clientuserDeleteManyArgs>(
      args?: SelectSubset<T, clientuserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientuserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientusers
     * const clientuser = await prisma.clientuser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clientuserUpdateManyArgs>(
      args: SelectSubset<T, clientuserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientuser.
     * @param {clientuserUpsertArgs} args - Arguments to update or create a Clientuser.
     * @example
     * // Update or create a Clientuser
     * const clientuser = await prisma.clientuser.upsert({
     *   create: {
     *     // ... data to create a Clientuser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientuser we want to update
     *   }
     * })
    **/
    upsert<T extends clientuserUpsertArgs>(
      args: SelectSubset<T, clientuserUpsertArgs>
    ): CheckSelect<T, Prisma__clientuserClient<clientuser>, Prisma__clientuserClient<clientuserGetPayload<T>>>

    /**
     * Count the number of Clientusers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientuserCountArgs} args - Arguments to filter Clientusers to count.
     * @example
     * // Count the number of Clientusers
     * const count = await prisma.clientuser.count({
     *   where: {
     *     // ... the filter for the Clientusers we want to count
     *   }
     * })
    **/
    count<T extends clientuserCountArgs>(
      args?: Subset<T, clientuserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientuserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientuser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientuserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientuserAggregateArgs>(args: Subset<T, ClientuserAggregateArgs>): PrismaPromise<GetClientuserAggregateType<T>>

    /**
     * Group by Clientuser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientuserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientuserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientuserGroupByArgs['orderBy'] }
        : { orderBy?: ClientuserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientuserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientuserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientuser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clientuserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientpeople<T extends clientpeopleFindManyArgs = {}>(args?: Subset<T, clientpeopleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientpeople>>, PrismaPromise<Array<clientpeopleGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    workerreview<T extends workerreviewFindManyArgs = {}>(args?: Subset<T, workerreviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<workerreview>>, PrismaPromise<Array<workerreviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * clientuser findUnique
   */
  export type clientuserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * Throw an Error if a clientuser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientuser to fetch.
     * 
    **/
    where: clientuserWhereUniqueInput
  }


  /**
   * clientuser findFirst
   */
  export type clientuserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * Throw an Error if a clientuser can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which clientuser to fetch.
     * 
    **/
    where?: clientuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientusers to fetch.
     * 
    **/
    orderBy?: Enumerable<clientuserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientusers.
     * 
    **/
    cursor?: clientuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientusers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientusers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientusers.
     * 
    **/
    distinct?: Enumerable<ClientuserScalarFieldEnum>
  }


  /**
   * clientuser findMany
   */
  export type clientuserFindManyArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * Filter, which clientusers to fetch.
     * 
    **/
    where?: clientuserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientusers to fetch.
     * 
    **/
    orderBy?: Enumerable<clientuserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientusers.
     * 
    **/
    cursor?: clientuserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientusers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientusers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientuserScalarFieldEnum>
  }


  /**
   * clientuser create
   */
  export type clientuserCreateArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * The data needed to create a clientuser.
     * 
    **/
    data: XOR<clientuserCreateInput, clientuserUncheckedCreateInput>
  }


  /**
   * clientuser createMany
   */
  export type clientuserCreateManyArgs = {
    /**
     * The data used to create many clientusers.
     * 
    **/
    data: Enumerable<clientuserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * clientuser update
   */
  export type clientuserUpdateArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * The data needed to update a clientuser.
     * 
    **/
    data: XOR<clientuserUpdateInput, clientuserUncheckedUpdateInput>
    /**
     * Choose, which clientuser to update.
     * 
    **/
    where: clientuserWhereUniqueInput
  }


  /**
   * clientuser updateMany
   */
  export type clientuserUpdateManyArgs = {
    /**
     * The data used to update clientusers.
     * 
    **/
    data: XOR<clientuserUpdateManyMutationInput, clientuserUncheckedUpdateManyInput>
    /**
     * Filter which clientusers to update
     * 
    **/
    where?: clientuserWhereInput
  }


  /**
   * clientuser upsert
   */
  export type clientuserUpsertArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * The filter to search for the clientuser to update in case it exists.
     * 
    **/
    where: clientuserWhereUniqueInput
    /**
     * In case the clientuser found by the `where` argument doesn't exist, create a new clientuser with this data.
     * 
    **/
    create: XOR<clientuserCreateInput, clientuserUncheckedCreateInput>
    /**
     * In case the clientuser was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clientuserUpdateInput, clientuserUncheckedUpdateInput>
  }


  /**
   * clientuser delete
   */
  export type clientuserDeleteArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
    /**
     * Filter which clientuser to delete.
     * 
    **/
    where: clientuserWhereUniqueInput
  }


  /**
   * clientuser deleteMany
   */
  export type clientuserDeleteManyArgs = {
    /**
     * Filter which clientusers to delete
     * 
    **/
    where?: clientuserWhereInput
  }


  /**
   * clientuser without action
   */
  export type clientuserArgs = {
    /**
     * Select specific fields to fetch from the clientuser
     * 
    **/
    select?: clientuserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clientuserInclude | null
  }



  /**
   * Model club
   */


  export type AggregateClub = {
    _count: ClubCountAggregateOutputType | null
    _avg: ClubAvgAggregateOutputType | null
    _sum: ClubSumAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  export type ClubAvgAggregateOutputType = {
    idClub: number | null
    idLocation: number | null
    deliveryCostProp: number | null
    idCash: number | null
  }

  export type ClubSumAggregateOutputType = {
    idClub: number | null
    idLocation: number | null
    deliveryCostProp: number | null
    idCash: number | null
  }

  export type ClubMinAggregateOutputType = {
    idClub: number | null
    clubName: string | null
    idLocation: number | null
    deliveryCostProp: number | null
    idCash: number | null
    isActive: boolean | null
  }

  export type ClubMaxAggregateOutputType = {
    idClub: number | null
    clubName: string | null
    idLocation: number | null
    deliveryCostProp: number | null
    idCash: number | null
    isActive: boolean | null
  }

  export type ClubCountAggregateOutputType = {
    idClub: number
    clubName: number
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: number
    _all: number
  }


  export type ClubAvgAggregateInputType = {
    idClub?: true
    idLocation?: true
    deliveryCostProp?: true
    idCash?: true
  }

  export type ClubSumAggregateInputType = {
    idClub?: true
    idLocation?: true
    deliveryCostProp?: true
    idCash?: true
  }

  export type ClubMinAggregateInputType = {
    idClub?: true
    clubName?: true
    idLocation?: true
    deliveryCostProp?: true
    idCash?: true
    isActive?: true
  }

  export type ClubMaxAggregateInputType = {
    idClub?: true
    clubName?: true
    idLocation?: true
    deliveryCostProp?: true
    idCash?: true
    isActive?: true
  }

  export type ClubCountAggregateInputType = {
    idClub?: true
    clubName?: true
    idLocation?: true
    deliveryCostProp?: true
    idCash?: true
    isActive?: true
    _all?: true
  }

  export type ClubAggregateArgs = {
    /**
     * Filter which club to aggregate.
     * 
    **/
    where?: clubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clubs to fetch.
     * 
    **/
    orderBy?: Enumerable<clubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clubs
    **/
    _count?: true | ClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClubAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClubSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubMaxAggregateInputType
  }

  export type GetClubAggregateType<T extends ClubAggregateArgs> = {
        [P in keyof T & keyof AggregateClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClub[P]>
      : GetScalarType<T[P], AggregateClub[P]>
  }




  export type ClubGroupByArgs = {
    where?: clubWhereInput
    orderBy?: Enumerable<clubOrderByWithAggregationInput>
    by: Array<ClubScalarFieldEnum>
    having?: clubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubCountAggregateInputType | true
    _avg?: ClubAvgAggregateInputType
    _sum?: ClubSumAggregateInputType
    _min?: ClubMinAggregateInputType
    _max?: ClubMaxAggregateInputType
  }


  export type ClubGroupByOutputType = {
    idClub: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    _count: ClubCountAggregateOutputType | null
    _avg: ClubAvgAggregateOutputType | null
    _sum: ClubSumAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  type GetClubGroupByPayload<T extends ClubGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubGroupByOutputType[P]>
            : GetScalarType<T[P], ClubGroupByOutputType[P]>
        }
      >
    >


  export type clubSelect = {
    idClub?: boolean
    clubName?: boolean
    idLocation?: boolean
    deliveryCostProp?: boolean
    idCash?: boolean
    isActive?: boolean
    cash?: boolean | cashArgs
    location?: boolean | locationArgs
    inventory?: boolean | inventoryFindManyArgs
    orderp?: boolean | orderpFindManyArgs
    popularproducts?: boolean | popularproductsFindManyArgs
    _count?: boolean | ClubCountOutputTypeArgs
  }

  export type clubInclude = {
    cash?: boolean | cashArgs
    location?: boolean | locationArgs
    inventory?: boolean | inventoryFindManyArgs
    orderp?: boolean | orderpFindManyArgs
    popularproducts?: boolean | popularproductsFindManyArgs
    _count?: boolean | ClubCountOutputTypeArgs
  }

  export type clubGetPayload<
    S extends boolean | null | undefined | clubArgs,
    U = keyof S
      > = S extends true
        ? club
    : S extends undefined
    ? never
    : S extends clubArgs | clubFindManyArgs
    ?'include' extends U
    ? club  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cash' ? cashGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :
        P extends 'inventory' ? Array < inventoryGetPayload<S['include'][P]>>  :
        P extends 'orderp' ? Array < orderpGetPayload<S['include'][P]>>  :
        P extends 'popularproducts' ? Array < popularproductsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClubCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cash' ? cashGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :
        P extends 'inventory' ? Array < inventoryGetPayload<S['select'][P]>>  :
        P extends 'orderp' ? Array < orderpGetPayload<S['select'][P]>>  :
        P extends 'popularproducts' ? Array < popularproductsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClubCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof club ? club[P] : never
  } 
    : club
  : club


  type clubCountArgs = Merge<
    Omit<clubFindManyArgs, 'select' | 'include'> & {
      select?: ClubCountAggregateInputType | true
    }
  >

  export interface clubDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Club that matches the filter.
     * @param {clubFindUniqueArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clubFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clubFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'club'> extends True ? CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>> : CheckSelect<T, Prisma__clubClient<club | null >, Prisma__clubClient<clubGetPayload<T> | null >>

    /**
     * Find the first Club that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clubFindFirstArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clubFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clubFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'club'> extends True ? CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>> : CheckSelect<T, Prisma__clubClient<club | null >, Prisma__clubClient<clubGetPayload<T> | null >>

    /**
     * Find zero or more Clubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clubFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clubs
     * const clubs = await prisma.club.findMany()
     * 
     * // Get first 10 Clubs
     * const clubs = await prisma.club.findMany({ take: 10 })
     * 
     * // Only select the `idClub`
     * const clubWithIdClubOnly = await prisma.club.findMany({ select: { idClub: true } })
     * 
    **/
    findMany<T extends clubFindManyArgs>(
      args?: SelectSubset<T, clubFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<club>>, PrismaPromise<Array<clubGetPayload<T>>>>

    /**
     * Create a Club.
     * @param {clubCreateArgs} args - Arguments to create a Club.
     * @example
     * // Create one Club
     * const Club = await prisma.club.create({
     *   data: {
     *     // ... data to create a Club
     *   }
     * })
     * 
    **/
    create<T extends clubCreateArgs>(
      args: SelectSubset<T, clubCreateArgs>
    ): CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>>

    /**
     * Create many Clubs.
     *     @param {clubCreateManyArgs} args - Arguments to create many Clubs.
     *     @example
     *     // Create many Clubs
     *     const club = await prisma.club.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clubCreateManyArgs>(
      args?: SelectSubset<T, clubCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Club.
     * @param {clubDeleteArgs} args - Arguments to delete one Club.
     * @example
     * // Delete one Club
     * const Club = await prisma.club.delete({
     *   where: {
     *     // ... filter to delete one Club
     *   }
     * })
     * 
    **/
    delete<T extends clubDeleteArgs>(
      args: SelectSubset<T, clubDeleteArgs>
    ): CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>>

    /**
     * Update one Club.
     * @param {clubUpdateArgs} args - Arguments to update one Club.
     * @example
     * // Update one Club
     * const club = await prisma.club.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clubUpdateArgs>(
      args: SelectSubset<T, clubUpdateArgs>
    ): CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>>

    /**
     * Delete zero or more Clubs.
     * @param {clubDeleteManyArgs} args - Arguments to filter Clubs to delete.
     * @example
     * // Delete a few Clubs
     * const { count } = await prisma.club.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clubDeleteManyArgs>(
      args?: SelectSubset<T, clubDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clubUpdateManyArgs>(
      args: SelectSubset<T, clubUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Club.
     * @param {clubUpsertArgs} args - Arguments to update or create a Club.
     * @example
     * // Update or create a Club
     * const club = await prisma.club.upsert({
     *   create: {
     *     // ... data to create a Club
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Club we want to update
     *   }
     * })
    **/
    upsert<T extends clubUpsertArgs>(
      args: SelectSubset<T, clubUpsertArgs>
    ): CheckSelect<T, Prisma__clubClient<club>, Prisma__clubClient<clubGetPayload<T>>>

    /**
     * Count the number of Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clubCountArgs} args - Arguments to filter Clubs to count.
     * @example
     * // Count the number of Clubs
     * const count = await prisma.club.count({
     *   where: {
     *     // ... the filter for the Clubs we want to count
     *   }
     * })
    **/
    count<T extends clubCountArgs>(
      args?: Subset<T, clubCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubAggregateArgs>(args: Subset<T, ClubAggregateArgs>): PrismaPromise<GetClubAggregateType<T>>

    /**
     * Group by Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubGroupByArgs['orderBy'] }
        : { orderBy?: ClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for club.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clubClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cash<T extends cashArgs = {}>(args?: Subset<T, cashArgs>): CheckSelect<T, Prisma__cashClient<cash | null >, Prisma__cashClient<cashGetPayload<T> | null >>;

    location<T extends locationArgs = {}>(args?: Subset<T, locationArgs>): CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>;

    inventory<T extends inventoryFindManyArgs = {}>(args?: Subset<T, inventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<inventory>>, PrismaPromise<Array<inventoryGetPayload<T>>>>;

    orderp<T extends orderpFindManyArgs = {}>(args?: Subset<T, orderpFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orderp>>, PrismaPromise<Array<orderpGetPayload<T>>>>;

    popularproducts<T extends popularproductsFindManyArgs = {}>(args?: Subset<T, popularproductsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<popularproducts>>, PrismaPromise<Array<popularproductsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * club findUnique
   */
  export type clubFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * Throw an Error if a club can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which club to fetch.
     * 
    **/
    where: clubWhereUniqueInput
  }


  /**
   * club findFirst
   */
  export type clubFindFirstArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * Throw an Error if a club can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which club to fetch.
     * 
    **/
    where?: clubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clubs to fetch.
     * 
    **/
    orderBy?: Enumerable<clubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clubs.
     * 
    **/
    cursor?: clubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clubs.
     * 
    **/
    distinct?: Enumerable<ClubScalarFieldEnum>
  }


  /**
   * club findMany
   */
  export type clubFindManyArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * Filter, which clubs to fetch.
     * 
    **/
    where?: clubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clubs to fetch.
     * 
    **/
    orderBy?: Enumerable<clubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clubs.
     * 
    **/
    cursor?: clubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clubs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClubScalarFieldEnum>
  }


  /**
   * club create
   */
  export type clubCreateArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * The data needed to create a club.
     * 
    **/
    data: XOR<clubCreateInput, clubUncheckedCreateInput>
  }


  /**
   * club createMany
   */
  export type clubCreateManyArgs = {
    /**
     * The data used to create many clubs.
     * 
    **/
    data: Enumerable<clubCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * club update
   */
  export type clubUpdateArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * The data needed to update a club.
     * 
    **/
    data: XOR<clubUpdateInput, clubUncheckedUpdateInput>
    /**
     * Choose, which club to update.
     * 
    **/
    where: clubWhereUniqueInput
  }


  /**
   * club updateMany
   */
  export type clubUpdateManyArgs = {
    /**
     * The data used to update clubs.
     * 
    **/
    data: XOR<clubUpdateManyMutationInput, clubUncheckedUpdateManyInput>
    /**
     * Filter which clubs to update
     * 
    **/
    where?: clubWhereInput
  }


  /**
   * club upsert
   */
  export type clubUpsertArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * The filter to search for the club to update in case it exists.
     * 
    **/
    where: clubWhereUniqueInput
    /**
     * In case the club found by the `where` argument doesn't exist, create a new club with this data.
     * 
    **/
    create: XOR<clubCreateInput, clubUncheckedCreateInput>
    /**
     * In case the club was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clubUpdateInput, clubUncheckedUpdateInput>
  }


  /**
   * club delete
   */
  export type clubDeleteArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
    /**
     * Filter which club to delete.
     * 
    **/
    where: clubWhereUniqueInput
  }


  /**
   * club deleteMany
   */
  export type clubDeleteManyArgs = {
    /**
     * Filter which clubs to delete
     * 
    **/
    where?: clubWhereInput
  }


  /**
   * club without action
   */
  export type clubArgs = {
    /**
     * Select specific fields to fetch from the club
     * 
    **/
    select?: clubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clubInclude | null
  }



  /**
   * Model complaint
   */


  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    idComplaint: number | null
    idWorkerReview: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    idComplaint: number | null
    idWorkerReview: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    idComplaint: number | null
    idWorkerReview: number | null
    compDescription: string | null
    solved: boolean | null
  }

  export type ComplaintMaxAggregateOutputType = {
    idComplaint: number | null
    idWorkerReview: number | null
    compDescription: string | null
    solved: boolean | null
  }

  export type ComplaintCountAggregateOutputType = {
    idComplaint: number
    idWorkerReview: number
    compDescription: number
    solved: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    idComplaint?: true
    idWorkerReview?: true
  }

  export type ComplaintSumAggregateInputType = {
    idComplaint?: true
    idWorkerReview?: true
  }

  export type ComplaintMinAggregateInputType = {
    idComplaint?: true
    idWorkerReview?: true
    compDescription?: true
    solved?: true
  }

  export type ComplaintMaxAggregateInputType = {
    idComplaint?: true
    idWorkerReview?: true
    compDescription?: true
    solved?: true
  }

  export type ComplaintCountAggregateInputType = {
    idComplaint?: true
    idWorkerReview?: true
    compDescription?: true
    solved?: true
    _all?: true
  }

  export type ComplaintAggregateArgs = {
    /**
     * Filter which complaint to aggregate.
     * 
    **/
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     * 
    **/
    orderBy?: Enumerable<complaintOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs = {
    where?: complaintWhereInput
    orderBy?: Enumerable<complaintOrderByWithAggregationInput>
    by: Array<ComplaintScalarFieldEnum>
    having?: complaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }


  export type ComplaintGroupByOutputType = {
    idComplaint: number
    idWorkerReview: number
    compDescription: string
    solved: boolean
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type complaintSelect = {
    idComplaint?: boolean
    idWorkerReview?: boolean
    compDescription?: boolean
    solved?: boolean
    workerreview?: boolean | workerreviewArgs
  }

  export type complaintInclude = {
    workerreview?: boolean | workerreviewArgs
  }

  export type complaintGetPayload<
    S extends boolean | null | undefined | complaintArgs,
    U = keyof S
      > = S extends true
        ? complaint
    : S extends undefined
    ? never
    : S extends complaintArgs | complaintFindManyArgs
    ?'include' extends U
    ? complaint  & {
    [P in TrueKeys<S['include']>]:
        P extends 'workerreview' ? workerreviewGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'workerreview' ? workerreviewGetPayload<S['select'][P]> :  P extends keyof complaint ? complaint[P] : never
  } 
    : complaint
  : complaint


  type complaintCountArgs = Merge<
    Omit<complaintFindManyArgs, 'select' | 'include'> & {
      select?: ComplaintCountAggregateInputType | true
    }
  >

  export interface complaintDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {complaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends complaintFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, complaintFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'complaint'> extends True ? CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>> : CheckSelect<T, Prisma__complaintClient<complaint | null >, Prisma__complaintClient<complaintGetPayload<T> | null >>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends complaintFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, complaintFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'complaint'> extends True ? CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>> : CheckSelect<T, Prisma__complaintClient<complaint | null >, Prisma__complaintClient<complaintGetPayload<T> | null >>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `idComplaint`
     * const complaintWithIdComplaintOnly = await prisma.complaint.findMany({ select: { idComplaint: true } })
     * 
    **/
    findMany<T extends complaintFindManyArgs>(
      args?: SelectSubset<T, complaintFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<complaint>>, PrismaPromise<Array<complaintGetPayload<T>>>>

    /**
     * Create a Complaint.
     * @param {complaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
    **/
    create<T extends complaintCreateArgs>(
      args: SelectSubset<T, complaintCreateArgs>
    ): CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>>

    /**
     * Create many Complaints.
     *     @param {complaintCreateManyArgs} args - Arguments to create many Complaints.
     *     @example
     *     // Create many Complaints
     *     const complaint = await prisma.complaint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends complaintCreateManyArgs>(
      args?: SelectSubset<T, complaintCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {complaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
    **/
    delete<T extends complaintDeleteArgs>(
      args: SelectSubset<T, complaintDeleteArgs>
    ): CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>>

    /**
     * Update one Complaint.
     * @param {complaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends complaintUpdateArgs>(
      args: SelectSubset<T, complaintUpdateArgs>
    ): CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>>

    /**
     * Delete zero or more Complaints.
     * @param {complaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends complaintDeleteManyArgs>(
      args?: SelectSubset<T, complaintDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends complaintUpdateManyArgs>(
      args: SelectSubset<T, complaintUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {complaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
    **/
    upsert<T extends complaintUpsertArgs>(
      args: SelectSubset<T, complaintUpsertArgs>
    ): CheckSelect<T, Prisma__complaintClient<complaint>, Prisma__complaintClient<complaintGetPayload<T>>>

    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends complaintCountArgs>(
      args?: Subset<T, complaintCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__complaintClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workerreview<T extends workerreviewArgs = {}>(args?: Subset<T, workerreviewArgs>): CheckSelect<T, Prisma__workerreviewClient<workerreview | null >, Prisma__workerreviewClient<workerreviewGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * complaint findUnique
   */
  export type complaintFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * Throw an Error if a complaint can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which complaint to fetch.
     * 
    **/
    where: complaintWhereUniqueInput
  }


  /**
   * complaint findFirst
   */
  export type complaintFindFirstArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * Throw an Error if a complaint can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which complaint to fetch.
     * 
    **/
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     * 
    **/
    orderBy?: Enumerable<complaintOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     * 
    **/
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     * 
    **/
    distinct?: Enumerable<ComplaintScalarFieldEnum>
  }


  /**
   * complaint findMany
   */
  export type complaintFindManyArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * Filter, which complaints to fetch.
     * 
    **/
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     * 
    **/
    orderBy?: Enumerable<complaintOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints.
     * 
    **/
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ComplaintScalarFieldEnum>
  }


  /**
   * complaint create
   */
  export type complaintCreateArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * The data needed to create a complaint.
     * 
    **/
    data: XOR<complaintCreateInput, complaintUncheckedCreateInput>
  }


  /**
   * complaint createMany
   */
  export type complaintCreateManyArgs = {
    /**
     * The data used to create many complaints.
     * 
    **/
    data: Enumerable<complaintCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * complaint update
   */
  export type complaintUpdateArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * The data needed to update a complaint.
     * 
    **/
    data: XOR<complaintUpdateInput, complaintUncheckedUpdateInput>
    /**
     * Choose, which complaint to update.
     * 
    **/
    where: complaintWhereUniqueInput
  }


  /**
   * complaint updateMany
   */
  export type complaintUpdateManyArgs = {
    /**
     * The data used to update complaints.
     * 
    **/
    data: XOR<complaintUpdateManyMutationInput, complaintUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     * 
    **/
    where?: complaintWhereInput
  }


  /**
   * complaint upsert
   */
  export type complaintUpsertArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * The filter to search for the complaint to update in case it exists.
     * 
    **/
    where: complaintWhereUniqueInput
    /**
     * In case the complaint found by the `where` argument doesn't exist, create a new complaint with this data.
     * 
    **/
    create: XOR<complaintCreateInput, complaintUncheckedCreateInput>
    /**
     * In case the complaint was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<complaintUpdateInput, complaintUncheckedUpdateInput>
  }


  /**
   * complaint delete
   */
  export type complaintDeleteArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
    /**
     * Filter which complaint to delete.
     * 
    **/
    where: complaintWhereUniqueInput
  }


  /**
   * complaint deleteMany
   */
  export type complaintDeleteManyArgs = {
    /**
     * Filter which complaints to delete
     * 
    **/
    where?: complaintWhereInput
  }


  /**
   * complaint without action
   */
  export type complaintArgs = {
    /**
     * Select specific fields to fetch from the complaint
     * 
    **/
    select?: complaintSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: complaintInclude | null
  }



  /**
   * Model infopeople
   */


  export type AggregateInfopeople = {
    _count: InfopeopleCountAggregateOutputType | null
    _avg: InfopeopleAvgAggregateOutputType | null
    _sum: InfopeopleSumAggregateOutputType | null
    _min: InfopeopleMinAggregateOutputType | null
    _max: InfopeopleMaxAggregateOutputType | null
  }

  export type InfopeopleAvgAggregateOutputType = {
    idInfoPeople: number | null
    phoneNumber: number | null
  }

  export type InfopeopleSumAggregateOutputType = {
    idInfoPeople: number | null
    phoneNumber: number | null
  }

  export type InfopeopleMinAggregateOutputType = {
    idInfoPeople: number | null
    peopleName: string | null
    surname: string | null
    email: string | null
    phoneNumber: number | null
    birthDate: Date | null
    isActive: boolean | null
  }

  export type InfopeopleMaxAggregateOutputType = {
    idInfoPeople: number | null
    peopleName: string | null
    surname: string | null
    email: string | null
    phoneNumber: number | null
    birthDate: Date | null
    isActive: boolean | null
  }

  export type InfopeopleCountAggregateOutputType = {
    idInfoPeople: number
    peopleName: number
    surname: number
    email: number
    phoneNumber: number
    birthDate: number
    isActive: number
    _all: number
  }


  export type InfopeopleAvgAggregateInputType = {
    idInfoPeople?: true
    phoneNumber?: true
  }

  export type InfopeopleSumAggregateInputType = {
    idInfoPeople?: true
    phoneNumber?: true
  }

  export type InfopeopleMinAggregateInputType = {
    idInfoPeople?: true
    peopleName?: true
    surname?: true
    email?: true
    phoneNumber?: true
    birthDate?: true
    isActive?: true
  }

  export type InfopeopleMaxAggregateInputType = {
    idInfoPeople?: true
    peopleName?: true
    surname?: true
    email?: true
    phoneNumber?: true
    birthDate?: true
    isActive?: true
  }

  export type InfopeopleCountAggregateInputType = {
    idInfoPeople?: true
    peopleName?: true
    surname?: true
    email?: true
    phoneNumber?: true
    birthDate?: true
    isActive?: true
    _all?: true
  }

  export type InfopeopleAggregateArgs = {
    /**
     * Filter which infopeople to aggregate.
     * 
    **/
    where?: infopeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopeople to fetch.
     * 
    **/
    orderBy?: Enumerable<infopeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: infopeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned infopeople
    **/
    _count?: true | InfopeopleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfopeopleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfopeopleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfopeopleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfopeopleMaxAggregateInputType
  }

  export type GetInfopeopleAggregateType<T extends InfopeopleAggregateArgs> = {
        [P in keyof T & keyof AggregateInfopeople]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfopeople[P]>
      : GetScalarType<T[P], AggregateInfopeople[P]>
  }




  export type InfopeopleGroupByArgs = {
    where?: infopeopleWhereInput
    orderBy?: Enumerable<infopeopleOrderByWithAggregationInput>
    by: Array<InfopeopleScalarFieldEnum>
    having?: infopeopleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfopeopleCountAggregateInputType | true
    _avg?: InfopeopleAvgAggregateInputType
    _sum?: InfopeopleSumAggregateInputType
    _min?: InfopeopleMinAggregateInputType
    _max?: InfopeopleMaxAggregateInputType
  }


  export type InfopeopleGroupByOutputType = {
    idInfoPeople: number
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date
    isActive: boolean
    _count: InfopeopleCountAggregateOutputType | null
    _avg: InfopeopleAvgAggregateOutputType | null
    _sum: InfopeopleSumAggregateOutputType | null
    _min: InfopeopleMinAggregateOutputType | null
    _max: InfopeopleMaxAggregateOutputType | null
  }

  type GetInfopeopleGroupByPayload<T extends InfopeopleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InfopeopleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfopeopleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfopeopleGroupByOutputType[P]>
            : GetScalarType<T[P], InfopeopleGroupByOutputType[P]>
        }
      >
    >


  export type infopeopleSelect = {
    idInfoPeople?: boolean
    peopleName?: boolean
    surname?: boolean
    email?: boolean
    phoneNumber?: boolean
    birthDate?: boolean
    isActive?: boolean
    card?: boolean | cardFindManyArgs
    clientpeople?: boolean | clientpeopleFindManyArgs
    _count?: boolean | InfopeopleCountOutputTypeArgs
  }

  export type infopeopleInclude = {
    card?: boolean | cardFindManyArgs
    clientpeople?: boolean | clientpeopleFindManyArgs
    _count?: boolean | InfopeopleCountOutputTypeArgs
  }

  export type infopeopleGetPayload<
    S extends boolean | null | undefined | infopeopleArgs,
    U = keyof S
      > = S extends true
        ? infopeople
    : S extends undefined
    ? never
    : S extends infopeopleArgs | infopeopleFindManyArgs
    ?'include' extends U
    ? infopeople  & {
    [P in TrueKeys<S['include']>]:
        P extends 'card' ? Array < cardGetPayload<S['include'][P]>>  :
        P extends 'clientpeople' ? Array < clientpeopleGetPayload<S['include'][P]>>  :
        P extends '_count' ? InfopeopleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'card' ? Array < cardGetPayload<S['select'][P]>>  :
        P extends 'clientpeople' ? Array < clientpeopleGetPayload<S['select'][P]>>  :
        P extends '_count' ? InfopeopleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof infopeople ? infopeople[P] : never
  } 
    : infopeople
  : infopeople


  type infopeopleCountArgs = Merge<
    Omit<infopeopleFindManyArgs, 'select' | 'include'> & {
      select?: InfopeopleCountAggregateInputType | true
    }
  >

  export interface infopeopleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Infopeople that matches the filter.
     * @param {infopeopleFindUniqueArgs} args - Arguments to find a Infopeople
     * @example
     * // Get one Infopeople
     * const infopeople = await prisma.infopeople.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends infopeopleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, infopeopleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'infopeople'> extends True ? CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>> : CheckSelect<T, Prisma__infopeopleClient<infopeople | null >, Prisma__infopeopleClient<infopeopleGetPayload<T> | null >>

    /**
     * Find the first Infopeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopeopleFindFirstArgs} args - Arguments to find a Infopeople
     * @example
     * // Get one Infopeople
     * const infopeople = await prisma.infopeople.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends infopeopleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, infopeopleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'infopeople'> extends True ? CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>> : CheckSelect<T, Prisma__infopeopleClient<infopeople | null >, Prisma__infopeopleClient<infopeopleGetPayload<T> | null >>

    /**
     * Find zero or more Infopeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopeopleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infopeople
     * const infopeople = await prisma.infopeople.findMany()
     * 
     * // Get first 10 Infopeople
     * const infopeople = await prisma.infopeople.findMany({ take: 10 })
     * 
     * // Only select the `idInfoPeople`
     * const infopeopleWithIdInfoPeopleOnly = await prisma.infopeople.findMany({ select: { idInfoPeople: true } })
     * 
    **/
    findMany<T extends infopeopleFindManyArgs>(
      args?: SelectSubset<T, infopeopleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<infopeople>>, PrismaPromise<Array<infopeopleGetPayload<T>>>>

    /**
     * Create a Infopeople.
     * @param {infopeopleCreateArgs} args - Arguments to create a Infopeople.
     * @example
     * // Create one Infopeople
     * const Infopeople = await prisma.infopeople.create({
     *   data: {
     *     // ... data to create a Infopeople
     *   }
     * })
     * 
    **/
    create<T extends infopeopleCreateArgs>(
      args: SelectSubset<T, infopeopleCreateArgs>
    ): CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>>

    /**
     * Create many Infopeople.
     *     @param {infopeopleCreateManyArgs} args - Arguments to create many Infopeople.
     *     @example
     *     // Create many Infopeople
     *     const infopeople = await prisma.infopeople.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends infopeopleCreateManyArgs>(
      args?: SelectSubset<T, infopeopleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Infopeople.
     * @param {infopeopleDeleteArgs} args - Arguments to delete one Infopeople.
     * @example
     * // Delete one Infopeople
     * const Infopeople = await prisma.infopeople.delete({
     *   where: {
     *     // ... filter to delete one Infopeople
     *   }
     * })
     * 
    **/
    delete<T extends infopeopleDeleteArgs>(
      args: SelectSubset<T, infopeopleDeleteArgs>
    ): CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>>

    /**
     * Update one Infopeople.
     * @param {infopeopleUpdateArgs} args - Arguments to update one Infopeople.
     * @example
     * // Update one Infopeople
     * const infopeople = await prisma.infopeople.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends infopeopleUpdateArgs>(
      args: SelectSubset<T, infopeopleUpdateArgs>
    ): CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>>

    /**
     * Delete zero or more Infopeople.
     * @param {infopeopleDeleteManyArgs} args - Arguments to filter Infopeople to delete.
     * @example
     * // Delete a few Infopeople
     * const { count } = await prisma.infopeople.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends infopeopleDeleteManyArgs>(
      args?: SelectSubset<T, infopeopleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infopeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopeopleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infopeople
     * const infopeople = await prisma.infopeople.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends infopeopleUpdateManyArgs>(
      args: SelectSubset<T, infopeopleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Infopeople.
     * @param {infopeopleUpsertArgs} args - Arguments to update or create a Infopeople.
     * @example
     * // Update or create a Infopeople
     * const infopeople = await prisma.infopeople.upsert({
     *   create: {
     *     // ... data to create a Infopeople
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infopeople we want to update
     *   }
     * })
    **/
    upsert<T extends infopeopleUpsertArgs>(
      args: SelectSubset<T, infopeopleUpsertArgs>
    ): CheckSelect<T, Prisma__infopeopleClient<infopeople>, Prisma__infopeopleClient<infopeopleGetPayload<T>>>

    /**
     * Count the number of Infopeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopeopleCountArgs} args - Arguments to filter Infopeople to count.
     * @example
     * // Count the number of Infopeople
     * const count = await prisma.infopeople.count({
     *   where: {
     *     // ... the filter for the Infopeople we want to count
     *   }
     * })
    **/
    count<T extends infopeopleCountArgs>(
      args?: Subset<T, infopeopleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfopeopleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infopeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfopeopleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfopeopleAggregateArgs>(args: Subset<T, InfopeopleAggregateArgs>): PrismaPromise<GetInfopeopleAggregateType<T>>

    /**
     * Group by Infopeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfopeopleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfopeopleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfopeopleGroupByArgs['orderBy'] }
        : { orderBy?: InfopeopleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfopeopleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfopeopleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for infopeople.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__infopeopleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    card<T extends cardFindManyArgs = {}>(args?: Subset<T, cardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<card>>, PrismaPromise<Array<cardGetPayload<T>>>>;

    clientpeople<T extends clientpeopleFindManyArgs = {}>(args?: Subset<T, clientpeopleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientpeople>>, PrismaPromise<Array<clientpeopleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * infopeople findUnique
   */
  export type infopeopleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * Throw an Error if a infopeople can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which infopeople to fetch.
     * 
    **/
    where: infopeopleWhereUniqueInput
  }


  /**
   * infopeople findFirst
   */
  export type infopeopleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * Throw an Error if a infopeople can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which infopeople to fetch.
     * 
    **/
    where?: infopeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopeople to fetch.
     * 
    **/
    orderBy?: Enumerable<infopeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infopeople.
     * 
    **/
    cursor?: infopeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infopeople.
     * 
    **/
    distinct?: Enumerable<InfopeopleScalarFieldEnum>
  }


  /**
   * infopeople findMany
   */
  export type infopeopleFindManyArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * Filter, which infopeople to fetch.
     * 
    **/
    where?: infopeopleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopeople to fetch.
     * 
    **/
    orderBy?: Enumerable<infopeopleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing infopeople.
     * 
    **/
    cursor?: infopeopleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopeople.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InfopeopleScalarFieldEnum>
  }


  /**
   * infopeople create
   */
  export type infopeopleCreateArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * The data needed to create a infopeople.
     * 
    **/
    data: XOR<infopeopleCreateInput, infopeopleUncheckedCreateInput>
  }


  /**
   * infopeople createMany
   */
  export type infopeopleCreateManyArgs = {
    /**
     * The data used to create many infopeople.
     * 
    **/
    data: Enumerable<infopeopleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * infopeople update
   */
  export type infopeopleUpdateArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * The data needed to update a infopeople.
     * 
    **/
    data: XOR<infopeopleUpdateInput, infopeopleUncheckedUpdateInput>
    /**
     * Choose, which infopeople to update.
     * 
    **/
    where: infopeopleWhereUniqueInput
  }


  /**
   * infopeople updateMany
   */
  export type infopeopleUpdateManyArgs = {
    /**
     * The data used to update infopeople.
     * 
    **/
    data: XOR<infopeopleUpdateManyMutationInput, infopeopleUncheckedUpdateManyInput>
    /**
     * Filter which infopeople to update
     * 
    **/
    where?: infopeopleWhereInput
  }


  /**
   * infopeople upsert
   */
  export type infopeopleUpsertArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * The filter to search for the infopeople to update in case it exists.
     * 
    **/
    where: infopeopleWhereUniqueInput
    /**
     * In case the infopeople found by the `where` argument doesn't exist, create a new infopeople with this data.
     * 
    **/
    create: XOR<infopeopleCreateInput, infopeopleUncheckedCreateInput>
    /**
     * In case the infopeople was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<infopeopleUpdateInput, infopeopleUncheckedUpdateInput>
  }


  /**
   * infopeople delete
   */
  export type infopeopleDeleteArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
    /**
     * Filter which infopeople to delete.
     * 
    **/
    where: infopeopleWhereUniqueInput
  }


  /**
   * infopeople deleteMany
   */
  export type infopeopleDeleteManyArgs = {
    /**
     * Filter which infopeople to delete
     * 
    **/
    where?: infopeopleWhereInput
  }


  /**
   * infopeople without action
   */
  export type infopeopleArgs = {
    /**
     * Select specific fields to fetch from the infopeople
     * 
    **/
    select?: infopeopleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: infopeopleInclude | null
  }



  /**
   * Model inventory
   */


  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    idInventory: number | null
    idClub: number | null
    idProduct: number | null
    stock: number | null
  }

  export type InventorySumAggregateOutputType = {
    idInventory: number | null
    idClub: number | null
    idProduct: number | null
    stock: number | null
  }

  export type InventoryMinAggregateOutputType = {
    idInventory: number | null
    idClub: number | null
    idProduct: number | null
    stock: number | null
    isActive: boolean | null
  }

  export type InventoryMaxAggregateOutputType = {
    idInventory: number | null
    idClub: number | null
    idProduct: number | null
    stock: number | null
    isActive: boolean | null
  }

  export type InventoryCountAggregateOutputType = {
    idInventory: number
    idClub: number
    idProduct: number
    stock: number
    isActive: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    idInventory?: true
    idClub?: true
    idProduct?: true
    stock?: true
  }

  export type InventorySumAggregateInputType = {
    idInventory?: true
    idClub?: true
    idProduct?: true
    stock?: true
  }

  export type InventoryMinAggregateInputType = {
    idInventory?: true
    idClub?: true
    idProduct?: true
    stock?: true
    isActive?: true
  }

  export type InventoryMaxAggregateInputType = {
    idInventory?: true
    idClub?: true
    idProduct?: true
    stock?: true
    isActive?: true
  }

  export type InventoryCountAggregateInputType = {
    idInventory?: true
    idClub?: true
    idProduct?: true
    stock?: true
    isActive?: true
    _all?: true
  }

  export type InventoryAggregateArgs = {
    /**
     * Filter which inventory to aggregate.
     * 
    **/
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<inventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs = {
    where?: inventoryWhereInput
    orderBy?: Enumerable<inventoryOrderByWithAggregationInput>
    by: Array<InventoryScalarFieldEnum>
    having?: inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }


  export type InventoryGroupByOutputType = {
    idInventory: number
    idClub: number
    idProduct: number
    stock: number
    isActive: boolean
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type inventorySelect = {
    idInventory?: boolean
    idClub?: boolean
    idProduct?: boolean
    stock?: boolean
    isActive?: boolean
    club?: boolean | clubArgs
    product?: boolean | productArgs
  }

  export type inventoryInclude = {
    club?: boolean | clubArgs
    product?: boolean | productArgs
  }

  export type inventoryGetPayload<
    S extends boolean | null | undefined | inventoryArgs,
    U = keyof S
      > = S extends true
        ? inventory
    : S extends undefined
    ? never
    : S extends inventoryArgs | inventoryFindManyArgs
    ?'include' extends U
    ? inventory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'club' ? clubGetPayload<S['include'][P]> :
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'club' ? clubGetPayload<S['select'][P]> :
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof inventory ? inventory[P] : never
  } 
    : inventory
  : inventory


  type inventoryCountArgs = Merge<
    Omit<inventoryFindManyArgs, 'select' | 'include'> & {
      select?: InventoryCountAggregateInputType | true
    }
  >

  export interface inventoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {inventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inventoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inventoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inventory'> extends True ? CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>> : CheckSelect<T, Prisma__inventoryClient<inventory | null >, Prisma__inventoryClient<inventoryGetPayload<T> | null >>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inventoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inventoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inventory'> extends True ? CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>> : CheckSelect<T, Prisma__inventoryClient<inventory | null >, Prisma__inventoryClient<inventoryGetPayload<T> | null >>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `idInventory`
     * const inventoryWithIdInventoryOnly = await prisma.inventory.findMany({ select: { idInventory: true } })
     * 
    **/
    findMany<T extends inventoryFindManyArgs>(
      args?: SelectSubset<T, inventoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<inventory>>, PrismaPromise<Array<inventoryGetPayload<T>>>>

    /**
     * Create a Inventory.
     * @param {inventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends inventoryCreateArgs>(
      args: SelectSubset<T, inventoryCreateArgs>
    ): CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>>

    /**
     * Create many Inventories.
     *     @param {inventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inventoryCreateManyArgs>(
      args?: SelectSubset<T, inventoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {inventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends inventoryDeleteArgs>(
      args: SelectSubset<T, inventoryDeleteArgs>
    ): CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>>

    /**
     * Update one Inventory.
     * @param {inventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inventoryUpdateArgs>(
      args: SelectSubset<T, inventoryUpdateArgs>
    ): CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>>

    /**
     * Delete zero or more Inventories.
     * @param {inventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inventoryDeleteManyArgs>(
      args?: SelectSubset<T, inventoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inventoryUpdateManyArgs>(
      args: SelectSubset<T, inventoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {inventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends inventoryUpsertArgs>(
      args: SelectSubset<T, inventoryUpsertArgs>
    ): CheckSelect<T, Prisma__inventoryClient<inventory>, Prisma__inventoryClient<inventoryGetPayload<T>>>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoryCountArgs>(
      args?: Subset<T, inventoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inventoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    club<T extends clubArgs = {}>(args?: Subset<T, clubArgs>): CheckSelect<T, Prisma__clubClient<club | null >, Prisma__clubClient<clubGetPayload<T> | null >>;

    product<T extends productArgs = {}>(args?: Subset<T, productArgs>): CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * inventory findUnique
   */
  export type inventoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * Throw an Error if a inventory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which inventory to fetch.
     * 
    **/
    where: inventoryWhereUniqueInput
  }


  /**
   * inventory findFirst
   */
  export type inventoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * Throw an Error if a inventory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which inventory to fetch.
     * 
    **/
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<inventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     * 
    **/
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     * 
    **/
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }


  /**
   * inventory findMany
   */
  export type inventoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * Filter, which inventories to fetch.
     * 
    **/
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     * 
    **/
    orderBy?: Enumerable<inventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     * 
    **/
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InventoryScalarFieldEnum>
  }


  /**
   * inventory create
   */
  export type inventoryCreateArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * The data needed to create a inventory.
     * 
    **/
    data: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
  }


  /**
   * inventory createMany
   */
  export type inventoryCreateManyArgs = {
    /**
     * The data used to create many inventories.
     * 
    **/
    data: Enumerable<inventoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * inventory update
   */
  export type inventoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * The data needed to update a inventory.
     * 
    **/
    data: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
    /**
     * Choose, which inventory to update.
     * 
    **/
    where: inventoryWhereUniqueInput
  }


  /**
   * inventory updateMany
   */
  export type inventoryUpdateManyArgs = {
    /**
     * The data used to update inventories.
     * 
    **/
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     * 
    **/
    where?: inventoryWhereInput
  }


  /**
   * inventory upsert
   */
  export type inventoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * The filter to search for the inventory to update in case it exists.
     * 
    **/
    where: inventoryWhereUniqueInput
    /**
     * In case the inventory found by the `where` argument doesn't exist, create a new inventory with this data.
     * 
    **/
    create: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
    /**
     * In case the inventory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
  }


  /**
   * inventory delete
   */
  export type inventoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
    /**
     * Filter which inventory to delete.
     * 
    **/
    where: inventoryWhereUniqueInput
  }


  /**
   * inventory deleteMany
   */
  export type inventoryDeleteManyArgs = {
    /**
     * Filter which inventories to delete
     * 
    **/
    where?: inventoryWhereInput
  }


  /**
   * inventory without action
   */
  export type inventoryArgs = {
    /**
     * Select specific fields to fetch from the inventory
     * 
    **/
    select?: inventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inventoryInclude | null
  }



  /**
   * Model location
   */


  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    idLocation: number | null
  }

  export type LocationSumAggregateOutputType = {
    idLocation: number | null
  }

  export type LocationMinAggregateOutputType = {
    idLocation: number | null
    typeLocation: boolean | null
    isActive: boolean | null
  }

  export type LocationMaxAggregateOutputType = {
    idLocation: number | null
    typeLocation: boolean | null
    isActive: boolean | null
  }

  export type LocationCountAggregateOutputType = {
    idLocation: number
    typeLocation: number
    isActive: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    idLocation?: true
  }

  export type LocationSumAggregateInputType = {
    idLocation?: true
  }

  export type LocationMinAggregateInputType = {
    idLocation?: true
    typeLocation?: true
    isActive?: true
  }

  export type LocationMaxAggregateInputType = {
    idLocation?: true
    typeLocation?: true
    isActive?: true
  }

  export type LocationCountAggregateInputType = {
    idLocation?: true
    typeLocation?: true
    isActive?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which location to aggregate.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs = {
    where?: locationWhereInput
    orderBy?: Enumerable<locationOrderByWithAggregationInput>
    by: Array<LocationScalarFieldEnum>
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    idLocation: number
    typeLocation: boolean | null
    isActive: boolean
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect = {
    idLocation?: boolean
    typeLocation?: boolean
    isActive?: boolean
    clientlocation?: boolean | clientlocationFindManyArgs
    club?: boolean | clubFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationInclude = {
    clientlocation?: boolean | clientlocationFindManyArgs
    club?: boolean | clubFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationGetPayload<
    S extends boolean | null | undefined | locationArgs,
    U = keyof S
      > = S extends true
        ? location
    : S extends undefined
    ? never
    : S extends locationArgs | locationFindManyArgs
    ?'include' extends U
    ? location  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientlocation' ? Array < clientlocationGetPayload<S['include'][P]>>  :
        P extends 'club' ? Array < clubGetPayload<S['include'][P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientlocation' ? Array < clientlocationGetPayload<S['select'][P]>>  :
        P extends 'club' ? Array < clubGetPayload<S['select'][P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof location ? location[P] : never
  } 
    : location
  : location


  type locationCountArgs = Merge<
    Omit<locationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface locationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `idLocation`
     * const locationWithIdLocationOnly = await prisma.location.findMany({ select: { idLocation: true } })
     * 
    **/
    findMany<T extends locationFindManyArgs>(
      args?: SelectSubset<T, locationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location>>, PrismaPromise<Array<locationGetPayload<T>>>>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends locationDeleteArgs>(
      args: SelectSubset<T, locationDeleteArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationUpdateArgs>(
      args: SelectSubset<T, locationUpdateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationDeleteManyArgs>(
      args?: SelectSubset<T, locationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationUpdateManyArgs>(
      args: SelectSubset<T, locationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientlocation<T extends clientlocationFindManyArgs = {}>(args?: Subset<T, clientlocationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientlocation>>, PrismaPromise<Array<clientlocationGetPayload<T>>>>;

    club<T extends clubFindManyArgs = {}>(args?: Subset<T, clubFindManyArgs>): CheckSelect<T, PrismaPromise<Array<club>>, PrismaPromise<Array<clubGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * location findUnique
   */
  export type locationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location findFirst
   */
  export type locationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     * 
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location findMany
   */
  export type locationFindManyArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter, which locations to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location update
   */
  export type locationUpdateArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The data needed to update a location.
     * 
    **/
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location updateMany
   */
  export type locationUpdateManyArgs = {
    /**
     * The data used to update locations.
     * 
    **/
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location delete
   */
  export type locationDeleteArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter which location to delete.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs = {
    /**
     * Filter which locations to delete
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location without action
   */
  export type locationArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
  }



  /**
   * Model membership
   */


  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipAvgAggregateOutputType = {
    idMembership: number | null
    cost: Decimal | null
    productDiscount: number | null
    deliveryDiscount: number | null
  }

  export type MembershipSumAggregateOutputType = {
    idMembership: number | null
    cost: Decimal | null
    productDiscount: number | null
    deliveryDiscount: number | null
  }

  export type MembershipMinAggregateOutputType = {
    idMembership: number | null
    nameMembership: string | null
    cost: Decimal | null
    productDiscount: number | null
    deliveryDiscount: number | null
    isActive: boolean | null
  }

  export type MembershipMaxAggregateOutputType = {
    idMembership: number | null
    nameMembership: string | null
    cost: Decimal | null
    productDiscount: number | null
    deliveryDiscount: number | null
    isActive: boolean | null
  }

  export type MembershipCountAggregateOutputType = {
    idMembership: number
    nameMembership: number
    cost: number
    productDiscount: number
    deliveryDiscount: number
    isActive: number
    _all: number
  }


  export type MembershipAvgAggregateInputType = {
    idMembership?: true
    cost?: true
    productDiscount?: true
    deliveryDiscount?: true
  }

  export type MembershipSumAggregateInputType = {
    idMembership?: true
    cost?: true
    productDiscount?: true
    deliveryDiscount?: true
  }

  export type MembershipMinAggregateInputType = {
    idMembership?: true
    nameMembership?: true
    cost?: true
    productDiscount?: true
    deliveryDiscount?: true
    isActive?: true
  }

  export type MembershipMaxAggregateInputType = {
    idMembership?: true
    nameMembership?: true
    cost?: true
    productDiscount?: true
    deliveryDiscount?: true
    isActive?: true
  }

  export type MembershipCountAggregateInputType = {
    idMembership?: true
    nameMembership?: true
    cost?: true
    productDiscount?: true
    deliveryDiscount?: true
    isActive?: true
    _all?: true
  }

  export type MembershipAggregateArgs = {
    /**
     * Filter which membership to aggregate.
     * 
    **/
    where?: membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs = {
    where?: membershipWhereInput
    orderBy?: Enumerable<membershipOrderByWithAggregationInput>
    by: Array<MembershipScalarFieldEnum>
    having?: membershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _avg?: MembershipAvgAggregateInputType
    _sum?: MembershipSumAggregateInputType
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }


  export type MembershipGroupByOutputType = {
    idMembership: number
    nameMembership: string
    cost: Decimal
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type membershipSelect = {
    idMembership?: boolean
    nameMembership?: boolean
    cost?: boolean
    productDiscount?: boolean
    deliveryDiscount?: boolean
    isActive?: boolean
    clientmembership?: boolean | clientmembershipFindManyArgs
    _count?: boolean | MembershipCountOutputTypeArgs
  }

  export type membershipInclude = {
    clientmembership?: boolean | clientmembershipFindManyArgs
    _count?: boolean | MembershipCountOutputTypeArgs
  }

  export type membershipGetPayload<
    S extends boolean | null | undefined | membershipArgs,
    U = keyof S
      > = S extends true
        ? membership
    : S extends undefined
    ? never
    : S extends membershipArgs | membershipFindManyArgs
    ?'include' extends U
    ? membership  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientmembership' ? Array < clientmembershipGetPayload<S['include'][P]>>  :
        P extends '_count' ? MembershipCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientmembership' ? Array < clientmembershipGetPayload<S['select'][P]>>  :
        P extends '_count' ? MembershipCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof membership ? membership[P] : never
  } 
    : membership
  : membership


  type membershipCountArgs = Merge<
    Omit<membershipFindManyArgs, 'select' | 'include'> & {
      select?: MembershipCountAggregateInputType | true
    }
  >

  export interface membershipDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Membership that matches the filter.
     * @param {membershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends membershipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, membershipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'membership'> extends True ? CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>> : CheckSelect<T, Prisma__membershipClient<membership | null >, Prisma__membershipClient<membershipGetPayload<T> | null >>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends membershipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, membershipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'membership'> extends True ? CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>> : CheckSelect<T, Prisma__membershipClient<membership | null >, Prisma__membershipClient<membershipGetPayload<T> | null >>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `idMembership`
     * const membershipWithIdMembershipOnly = await prisma.membership.findMany({ select: { idMembership: true } })
     * 
    **/
    findMany<T extends membershipFindManyArgs>(
      args?: SelectSubset<T, membershipFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<membership>>, PrismaPromise<Array<membershipGetPayload<T>>>>

    /**
     * Create a Membership.
     * @param {membershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
    **/
    create<T extends membershipCreateArgs>(
      args: SelectSubset<T, membershipCreateArgs>
    ): CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>>

    /**
     * Create many Memberships.
     *     @param {membershipCreateManyArgs} args - Arguments to create many Memberships.
     *     @example
     *     // Create many Memberships
     *     const membership = await prisma.membership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends membershipCreateManyArgs>(
      args?: SelectSubset<T, membershipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Membership.
     * @param {membershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
    **/
    delete<T extends membershipDeleteArgs>(
      args: SelectSubset<T, membershipDeleteArgs>
    ): CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>>

    /**
     * Update one Membership.
     * @param {membershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends membershipUpdateArgs>(
      args: SelectSubset<T, membershipUpdateArgs>
    ): CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>>

    /**
     * Delete zero or more Memberships.
     * @param {membershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends membershipDeleteManyArgs>(
      args?: SelectSubset<T, membershipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends membershipUpdateManyArgs>(
      args: SelectSubset<T, membershipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Membership.
     * @param {membershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
    **/
    upsert<T extends membershipUpsertArgs>(
      args: SelectSubset<T, membershipUpsertArgs>
    ): CheckSelect<T, Prisma__membershipClient<membership>, Prisma__membershipClient<membershipGetPayload<T>>>

    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends membershipCountArgs>(
      args?: Subset<T, membershipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__membershipClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientmembership<T extends clientmembershipFindManyArgs = {}>(args?: Subset<T, clientmembershipFindManyArgs>): CheckSelect<T, PrismaPromise<Array<clientmembership>>, PrismaPromise<Array<clientmembershipGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * membership findUnique
   */
  export type membershipFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * Throw an Error if a membership can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which membership to fetch.
     * 
    **/
    where: membershipWhereUniqueInput
  }


  /**
   * membership findFirst
   */
  export type membershipFindFirstArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * Throw an Error if a membership can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which membership to fetch.
     * 
    **/
    where?: membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for memberships.
     * 
    **/
    cursor?: membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memberships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of memberships.
     * 
    **/
    distinct?: Enumerable<MembershipScalarFieldEnum>
  }


  /**
   * membership findMany
   */
  export type membershipFindManyArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * Filter, which memberships to fetch.
     * 
    **/
    where?: membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memberships to fetch.
     * 
    **/
    orderBy?: Enumerable<membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing memberships.
     * 
    **/
    cursor?: membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memberships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memberships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MembershipScalarFieldEnum>
  }


  /**
   * membership create
   */
  export type membershipCreateArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * The data needed to create a membership.
     * 
    **/
    data: XOR<membershipCreateInput, membershipUncheckedCreateInput>
  }


  /**
   * membership createMany
   */
  export type membershipCreateManyArgs = {
    /**
     * The data used to create many memberships.
     * 
    **/
    data: Enumerable<membershipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * membership update
   */
  export type membershipUpdateArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * The data needed to update a membership.
     * 
    **/
    data: XOR<membershipUpdateInput, membershipUncheckedUpdateInput>
    /**
     * Choose, which membership to update.
     * 
    **/
    where: membershipWhereUniqueInput
  }


  /**
   * membership updateMany
   */
  export type membershipUpdateManyArgs = {
    /**
     * The data used to update memberships.
     * 
    **/
    data: XOR<membershipUpdateManyMutationInput, membershipUncheckedUpdateManyInput>
    /**
     * Filter which memberships to update
     * 
    **/
    where?: membershipWhereInput
  }


  /**
   * membership upsert
   */
  export type membershipUpsertArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * The filter to search for the membership to update in case it exists.
     * 
    **/
    where: membershipWhereUniqueInput
    /**
     * In case the membership found by the `where` argument doesn't exist, create a new membership with this data.
     * 
    **/
    create: XOR<membershipCreateInput, membershipUncheckedCreateInput>
    /**
     * In case the membership was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<membershipUpdateInput, membershipUncheckedUpdateInput>
  }


  /**
   * membership delete
   */
  export type membershipDeleteArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
    /**
     * Filter which membership to delete.
     * 
    **/
    where: membershipWhereUniqueInput
  }


  /**
   * membership deleteMany
   */
  export type membershipDeleteManyArgs = {
    /**
     * Filter which memberships to delete
     * 
    **/
    where?: membershipWhereInput
  }


  /**
   * membership without action
   */
  export type membershipArgs = {
    /**
     * Select specific fields to fetch from the membership
     * 
    **/
    select?: membershipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: membershipInclude | null
  }



  /**
   * Model orderline
   */


  export type AggregateOrderline = {
    _count: OrderlineCountAggregateOutputType | null
    _avg: OrderlineAvgAggregateOutputType | null
    _sum: OrderlineSumAggregateOutputType | null
    _min: OrderlineMinAggregateOutputType | null
    _max: OrderlineMaxAggregateOutputType | null
  }

  export type OrderlineAvgAggregateOutputType = {
    idOrderLine: number | null
    idOrderP: number | null
    idProduct: number | null
    cost: Decimal | null
    amount: number | null
  }

  export type OrderlineSumAggregateOutputType = {
    idOrderLine: number | null
    idOrderP: number | null
    idProduct: number | null
    cost: Decimal | null
    amount: number | null
  }

  export type OrderlineMinAggregateOutputType = {
    idOrderLine: number | null
    idOrderP: number | null
    idProduct: number | null
    cost: Decimal | null
    amount: number | null
  }

  export type OrderlineMaxAggregateOutputType = {
    idOrderLine: number | null
    idOrderP: number | null
    idProduct: number | null
    cost: Decimal | null
    amount: number | null
  }

  export type OrderlineCountAggregateOutputType = {
    idOrderLine: number
    idOrderP: number
    idProduct: number
    cost: number
    amount: number
    _all: number
  }


  export type OrderlineAvgAggregateInputType = {
    idOrderLine?: true
    idOrderP?: true
    idProduct?: true
    cost?: true
    amount?: true
  }

  export type OrderlineSumAggregateInputType = {
    idOrderLine?: true
    idOrderP?: true
    idProduct?: true
    cost?: true
    amount?: true
  }

  export type OrderlineMinAggregateInputType = {
    idOrderLine?: true
    idOrderP?: true
    idProduct?: true
    cost?: true
    amount?: true
  }

  export type OrderlineMaxAggregateInputType = {
    idOrderLine?: true
    idOrderP?: true
    idProduct?: true
    cost?: true
    amount?: true
  }

  export type OrderlineCountAggregateInputType = {
    idOrderLine?: true
    idOrderP?: true
    idProduct?: true
    cost?: true
    amount?: true
    _all?: true
  }

  export type OrderlineAggregateArgs = {
    /**
     * Filter which orderline to aggregate.
     * 
    **/
    where?: orderlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderlines to fetch.
     * 
    **/
    orderBy?: Enumerable<orderlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: orderlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderlines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderlines
    **/
    _count?: true | OrderlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderlineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderlineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderlineMaxAggregateInputType
  }

  export type GetOrderlineAggregateType<T extends OrderlineAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderline[P]>
      : GetScalarType<T[P], AggregateOrderline[P]>
  }




  export type OrderlineGroupByArgs = {
    where?: orderlineWhereInput
    orderBy?: Enumerable<orderlineOrderByWithAggregationInput>
    by: Array<OrderlineScalarFieldEnum>
    having?: orderlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderlineCountAggregateInputType | true
    _avg?: OrderlineAvgAggregateInputType
    _sum?: OrderlineSumAggregateInputType
    _min?: OrderlineMinAggregateInputType
    _max?: OrderlineMaxAggregateInputType
  }


  export type OrderlineGroupByOutputType = {
    idOrderLine: number
    idOrderP: number
    idProduct: number
    cost: Decimal
    amount: number
    _count: OrderlineCountAggregateOutputType | null
    _avg: OrderlineAvgAggregateOutputType | null
    _sum: OrderlineSumAggregateOutputType | null
    _min: OrderlineMinAggregateOutputType | null
    _max: OrderlineMaxAggregateOutputType | null
  }

  type GetOrderlineGroupByPayload<T extends OrderlineGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderlineGroupByOutputType[P]>
            : GetScalarType<T[P], OrderlineGroupByOutputType[P]>
        }
      >
    >


  export type orderlineSelect = {
    idOrderLine?: boolean
    idOrderP?: boolean
    idProduct?: boolean
    cost?: boolean
    amount?: boolean
    orderp?: boolean | orderpArgs
    product?: boolean | productArgs
  }

  export type orderlineInclude = {
    orderp?: boolean | orderpArgs
    product?: boolean | productArgs
  }

  export type orderlineGetPayload<
    S extends boolean | null | undefined | orderlineArgs,
    U = keyof S
      > = S extends true
        ? orderline
    : S extends undefined
    ? never
    : S extends orderlineArgs | orderlineFindManyArgs
    ?'include' extends U
    ? orderline  & {
    [P in TrueKeys<S['include']>]:
        P extends 'orderp' ? orderpGetPayload<S['include'][P]> :
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'orderp' ? orderpGetPayload<S['select'][P]> :
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof orderline ? orderline[P] : never
  } 
    : orderline
  : orderline


  type orderlineCountArgs = Merge<
    Omit<orderlineFindManyArgs, 'select' | 'include'> & {
      select?: OrderlineCountAggregateInputType | true
    }
  >

  export interface orderlineDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Orderline that matches the filter.
     * @param {orderlineFindUniqueArgs} args - Arguments to find a Orderline
     * @example
     * // Get one Orderline
     * const orderline = await prisma.orderline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderlineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, orderlineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'orderline'> extends True ? CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>> : CheckSelect<T, Prisma__orderlineClient<orderline | null >, Prisma__orderlineClient<orderlineGetPayload<T> | null >>

    /**
     * Find the first Orderline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderlineFindFirstArgs} args - Arguments to find a Orderline
     * @example
     * // Get one Orderline
     * const orderline = await prisma.orderline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderlineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, orderlineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'orderline'> extends True ? CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>> : CheckSelect<T, Prisma__orderlineClient<orderline | null >, Prisma__orderlineClient<orderlineGetPayload<T> | null >>

    /**
     * Find zero or more Orderlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderlineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orderlines
     * const orderlines = await prisma.orderline.findMany()
     * 
     * // Get first 10 Orderlines
     * const orderlines = await prisma.orderline.findMany({ take: 10 })
     * 
     * // Only select the `idOrderLine`
     * const orderlineWithIdOrderLineOnly = await prisma.orderline.findMany({ select: { idOrderLine: true } })
     * 
    **/
    findMany<T extends orderlineFindManyArgs>(
      args?: SelectSubset<T, orderlineFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<orderline>>, PrismaPromise<Array<orderlineGetPayload<T>>>>

    /**
     * Create a Orderline.
     * @param {orderlineCreateArgs} args - Arguments to create a Orderline.
     * @example
     * // Create one Orderline
     * const Orderline = await prisma.orderline.create({
     *   data: {
     *     // ... data to create a Orderline
     *   }
     * })
     * 
    **/
    create<T extends orderlineCreateArgs>(
      args: SelectSubset<T, orderlineCreateArgs>
    ): CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>>

    /**
     * Create many Orderlines.
     *     @param {orderlineCreateManyArgs} args - Arguments to create many Orderlines.
     *     @example
     *     // Create many Orderlines
     *     const orderline = await prisma.orderline.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderlineCreateManyArgs>(
      args?: SelectSubset<T, orderlineCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Orderline.
     * @param {orderlineDeleteArgs} args - Arguments to delete one Orderline.
     * @example
     * // Delete one Orderline
     * const Orderline = await prisma.orderline.delete({
     *   where: {
     *     // ... filter to delete one Orderline
     *   }
     * })
     * 
    **/
    delete<T extends orderlineDeleteArgs>(
      args: SelectSubset<T, orderlineDeleteArgs>
    ): CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>>

    /**
     * Update one Orderline.
     * @param {orderlineUpdateArgs} args - Arguments to update one Orderline.
     * @example
     * // Update one Orderline
     * const orderline = await prisma.orderline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderlineUpdateArgs>(
      args: SelectSubset<T, orderlineUpdateArgs>
    ): CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>>

    /**
     * Delete zero or more Orderlines.
     * @param {orderlineDeleteManyArgs} args - Arguments to filter Orderlines to delete.
     * @example
     * // Delete a few Orderlines
     * const { count } = await prisma.orderline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderlineDeleteManyArgs>(
      args?: SelectSubset<T, orderlineDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orderlines
     * const orderline = await prisma.orderline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderlineUpdateManyArgs>(
      args: SelectSubset<T, orderlineUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orderline.
     * @param {orderlineUpsertArgs} args - Arguments to update or create a Orderline.
     * @example
     * // Update or create a Orderline
     * const orderline = await prisma.orderline.upsert({
     *   create: {
     *     // ... data to create a Orderline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orderline we want to update
     *   }
     * })
    **/
    upsert<T extends orderlineUpsertArgs>(
      args: SelectSubset<T, orderlineUpsertArgs>
    ): CheckSelect<T, Prisma__orderlineClient<orderline>, Prisma__orderlineClient<orderlineGetPayload<T>>>

    /**
     * Count the number of Orderlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderlineCountArgs} args - Arguments to filter Orderlines to count.
     * @example
     * // Count the number of Orderlines
     * const count = await prisma.orderline.count({
     *   where: {
     *     // ... the filter for the Orderlines we want to count
     *   }
     * })
    **/
    count<T extends orderlineCountArgs>(
      args?: Subset<T, orderlineCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orderline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderlineAggregateArgs>(args: Subset<T, OrderlineAggregateArgs>): PrismaPromise<GetOrderlineAggregateType<T>>

    /**
     * Group by Orderline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderlineGroupByArgs['orderBy'] }
        : { orderBy?: OrderlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderlineGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderlineClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orderp<T extends orderpArgs = {}>(args?: Subset<T, orderpArgs>): CheckSelect<T, Prisma__orderpClient<orderp | null >, Prisma__orderpClient<orderpGetPayload<T> | null >>;

    product<T extends productArgs = {}>(args?: Subset<T, productArgs>): CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * orderline findUnique
   */
  export type orderlineFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * Throw an Error if a orderline can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderline to fetch.
     * 
    **/
    where: orderlineWhereUniqueInput
  }


  /**
   * orderline findFirst
   */
  export type orderlineFindFirstArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * Throw an Error if a orderline can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderline to fetch.
     * 
    **/
    where?: orderlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderlines to fetch.
     * 
    **/
    orderBy?: Enumerable<orderlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderlines.
     * 
    **/
    cursor?: orderlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderlines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderlines.
     * 
    **/
    distinct?: Enumerable<OrderlineScalarFieldEnum>
  }


  /**
   * orderline findMany
   */
  export type orderlineFindManyArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * Filter, which orderlines to fetch.
     * 
    **/
    where?: orderlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderlines to fetch.
     * 
    **/
    orderBy?: Enumerable<orderlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderlines.
     * 
    **/
    cursor?: orderlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderlines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderlines.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderlineScalarFieldEnum>
  }


  /**
   * orderline create
   */
  export type orderlineCreateArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * The data needed to create a orderline.
     * 
    **/
    data: XOR<orderlineCreateInput, orderlineUncheckedCreateInput>
  }


  /**
   * orderline createMany
   */
  export type orderlineCreateManyArgs = {
    /**
     * The data used to create many orderlines.
     * 
    **/
    data: Enumerable<orderlineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * orderline update
   */
  export type orderlineUpdateArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * The data needed to update a orderline.
     * 
    **/
    data: XOR<orderlineUpdateInput, orderlineUncheckedUpdateInput>
    /**
     * Choose, which orderline to update.
     * 
    **/
    where: orderlineWhereUniqueInput
  }


  /**
   * orderline updateMany
   */
  export type orderlineUpdateManyArgs = {
    /**
     * The data used to update orderlines.
     * 
    **/
    data: XOR<orderlineUpdateManyMutationInput, orderlineUncheckedUpdateManyInput>
    /**
     * Filter which orderlines to update
     * 
    **/
    where?: orderlineWhereInput
  }


  /**
   * orderline upsert
   */
  export type orderlineUpsertArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * The filter to search for the orderline to update in case it exists.
     * 
    **/
    where: orderlineWhereUniqueInput
    /**
     * In case the orderline found by the `where` argument doesn't exist, create a new orderline with this data.
     * 
    **/
    create: XOR<orderlineCreateInput, orderlineUncheckedCreateInput>
    /**
     * In case the orderline was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<orderlineUpdateInput, orderlineUncheckedUpdateInput>
  }


  /**
   * orderline delete
   */
  export type orderlineDeleteArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
    /**
     * Filter which orderline to delete.
     * 
    **/
    where: orderlineWhereUniqueInput
  }


  /**
   * orderline deleteMany
   */
  export type orderlineDeleteManyArgs = {
    /**
     * Filter which orderlines to delete
     * 
    **/
    where?: orderlineWhereInput
  }


  /**
   * orderline without action
   */
  export type orderlineArgs = {
    /**
     * Select specific fields to fetch from the orderline
     * 
    **/
    select?: orderlineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderlineInclude | null
  }



  /**
   * Model orderp
   */


  export type AggregateOrderp = {
    _count: OrderpCountAggregateOutputType | null
    _avg: OrderpAvgAggregateOutputType | null
    _sum: OrderpSumAggregateOutputType | null
    _min: OrderpMinAggregateOutputType | null
    _max: OrderpMaxAggregateOutputType | null
  }

  export type OrderpAvgAggregateOutputType = {
    idOrderP: number | null
    idClientPeople: number | null
    idClub: number | null
    idEmployer: number | null
    idMailer: number | null
    deliveryCost: Decimal | null
  }

  export type OrderpSumAggregateOutputType = {
    idOrderP: number | null
    idClientPeople: number | null
    idClub: number | null
    idEmployer: number | null
    idMailer: number | null
    deliveryCost: Decimal | null
  }

  export type OrderpMinAggregateOutputType = {
    idOrderP: number | null
    idClientPeople: number | null
    orderDate: Date | null
    idClub: number | null
    idEmployer: number | null
    idMailer: number | null
    deliveryCost: Decimal | null
  }

  export type OrderpMaxAggregateOutputType = {
    idOrderP: number | null
    idClientPeople: number | null
    orderDate: Date | null
    idClub: number | null
    idEmployer: number | null
    idMailer: number | null
    deliveryCost: Decimal | null
  }

  export type OrderpCountAggregateOutputType = {
    idOrderP: number
    idClientPeople: number
    orderDate: number
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: number
    _all: number
  }


  export type OrderpAvgAggregateInputType = {
    idOrderP?: true
    idClientPeople?: true
    idClub?: true
    idEmployer?: true
    idMailer?: true
    deliveryCost?: true
  }

  export type OrderpSumAggregateInputType = {
    idOrderP?: true
    idClientPeople?: true
    idClub?: true
    idEmployer?: true
    idMailer?: true
    deliveryCost?: true
  }

  export type OrderpMinAggregateInputType = {
    idOrderP?: true
    idClientPeople?: true
    orderDate?: true
    idClub?: true
    idEmployer?: true
    idMailer?: true
    deliveryCost?: true
  }

  export type OrderpMaxAggregateInputType = {
    idOrderP?: true
    idClientPeople?: true
    orderDate?: true
    idClub?: true
    idEmployer?: true
    idMailer?: true
    deliveryCost?: true
  }

  export type OrderpCountAggregateInputType = {
    idOrderP?: true
    idClientPeople?: true
    orderDate?: true
    idClub?: true
    idEmployer?: true
    idMailer?: true
    deliveryCost?: true
    _all?: true
  }

  export type OrderpAggregateArgs = {
    /**
     * Filter which orderp to aggregate.
     * 
    **/
    where?: orderpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderps to fetch.
     * 
    **/
    orderBy?: Enumerable<orderpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: orderpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderps
    **/
    _count?: true | OrderpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderpMaxAggregateInputType
  }

  export type GetOrderpAggregateType<T extends OrderpAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderp[P]>
      : GetScalarType<T[P], AggregateOrderp[P]>
  }




  export type OrderpGroupByArgs = {
    where?: orderpWhereInput
    orderBy?: Enumerable<orderpOrderByWithAggregationInput>
    by: Array<OrderpScalarFieldEnum>
    having?: orderpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderpCountAggregateInputType | true
    _avg?: OrderpAvgAggregateInputType
    _sum?: OrderpSumAggregateInputType
    _min?: OrderpMinAggregateInputType
    _max?: OrderpMaxAggregateInputType
  }


  export type OrderpGroupByOutputType = {
    idOrderP: number
    idClientPeople: number
    orderDate: Date
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal
    _count: OrderpCountAggregateOutputType | null
    _avg: OrderpAvgAggregateOutputType | null
    _sum: OrderpSumAggregateOutputType | null
    _min: OrderpMinAggregateOutputType | null
    _max: OrderpMaxAggregateOutputType | null
  }

  type GetOrderpGroupByPayload<T extends OrderpGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderpGroupByOutputType[P]>
            : GetScalarType<T[P], OrderpGroupByOutputType[P]>
        }
      >
    >


  export type orderpSelect = {
    idOrderP?: boolean
    idClientPeople?: boolean
    orderDate?: boolean
    idClub?: boolean
    idEmployer?: boolean
    idMailer?: boolean
    deliveryCost?: boolean
    clientpeople?: boolean | clientpeopleArgs
    club?: boolean | clubArgs
    orderline?: boolean | orderlineFindManyArgs
    _count?: boolean | OrderpCountOutputTypeArgs
  }

  export type orderpInclude = {
    clientpeople?: boolean | clientpeopleArgs
    club?: boolean | clubArgs
    orderline?: boolean | orderlineFindManyArgs
    _count?: boolean | OrderpCountOutputTypeArgs
  }

  export type orderpGetPayload<
    S extends boolean | null | undefined | orderpArgs,
    U = keyof S
      > = S extends true
        ? orderp
    : S extends undefined
    ? never
    : S extends orderpArgs | orderpFindManyArgs
    ?'include' extends U
    ? orderp  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['include'][P]> :
        P extends 'club' ? clubGetPayload<S['include'][P]> :
        P extends 'orderline' ? Array < orderlineGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderpCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientpeople' ? clientpeopleGetPayload<S['select'][P]> :
        P extends 'club' ? clubGetPayload<S['select'][P]> :
        P extends 'orderline' ? Array < orderlineGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderpCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof orderp ? orderp[P] : never
  } 
    : orderp
  : orderp


  type orderpCountArgs = Merge<
    Omit<orderpFindManyArgs, 'select' | 'include'> & {
      select?: OrderpCountAggregateInputType | true
    }
  >

  export interface orderpDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Orderp that matches the filter.
     * @param {orderpFindUniqueArgs} args - Arguments to find a Orderp
     * @example
     * // Get one Orderp
     * const orderp = await prisma.orderp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderpFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, orderpFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'orderp'> extends True ? CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>> : CheckSelect<T, Prisma__orderpClient<orderp | null >, Prisma__orderpClient<orderpGetPayload<T> | null >>

    /**
     * Find the first Orderp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderpFindFirstArgs} args - Arguments to find a Orderp
     * @example
     * // Get one Orderp
     * const orderp = await prisma.orderp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderpFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, orderpFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'orderp'> extends True ? CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>> : CheckSelect<T, Prisma__orderpClient<orderp | null >, Prisma__orderpClient<orderpGetPayload<T> | null >>

    /**
     * Find zero or more Orderps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orderps
     * const orderps = await prisma.orderp.findMany()
     * 
     * // Get first 10 Orderps
     * const orderps = await prisma.orderp.findMany({ take: 10 })
     * 
     * // Only select the `idOrderP`
     * const orderpWithIdOrderPOnly = await prisma.orderp.findMany({ select: { idOrderP: true } })
     * 
    **/
    findMany<T extends orderpFindManyArgs>(
      args?: SelectSubset<T, orderpFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<orderp>>, PrismaPromise<Array<orderpGetPayload<T>>>>

    /**
     * Create a Orderp.
     * @param {orderpCreateArgs} args - Arguments to create a Orderp.
     * @example
     * // Create one Orderp
     * const Orderp = await prisma.orderp.create({
     *   data: {
     *     // ... data to create a Orderp
     *   }
     * })
     * 
    **/
    create<T extends orderpCreateArgs>(
      args: SelectSubset<T, orderpCreateArgs>
    ): CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>>

    /**
     * Create many Orderps.
     *     @param {orderpCreateManyArgs} args - Arguments to create many Orderps.
     *     @example
     *     // Create many Orderps
     *     const orderp = await prisma.orderp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderpCreateManyArgs>(
      args?: SelectSubset<T, orderpCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Orderp.
     * @param {orderpDeleteArgs} args - Arguments to delete one Orderp.
     * @example
     * // Delete one Orderp
     * const Orderp = await prisma.orderp.delete({
     *   where: {
     *     // ... filter to delete one Orderp
     *   }
     * })
     * 
    **/
    delete<T extends orderpDeleteArgs>(
      args: SelectSubset<T, orderpDeleteArgs>
    ): CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>>

    /**
     * Update one Orderp.
     * @param {orderpUpdateArgs} args - Arguments to update one Orderp.
     * @example
     * // Update one Orderp
     * const orderp = await prisma.orderp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderpUpdateArgs>(
      args: SelectSubset<T, orderpUpdateArgs>
    ): CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>>

    /**
     * Delete zero or more Orderps.
     * @param {orderpDeleteManyArgs} args - Arguments to filter Orderps to delete.
     * @example
     * // Delete a few Orderps
     * const { count } = await prisma.orderp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderpDeleteManyArgs>(
      args?: SelectSubset<T, orderpDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orderps
     * const orderp = await prisma.orderp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderpUpdateManyArgs>(
      args: SelectSubset<T, orderpUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orderp.
     * @param {orderpUpsertArgs} args - Arguments to update or create a Orderp.
     * @example
     * // Update or create a Orderp
     * const orderp = await prisma.orderp.upsert({
     *   create: {
     *     // ... data to create a Orderp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orderp we want to update
     *   }
     * })
    **/
    upsert<T extends orderpUpsertArgs>(
      args: SelectSubset<T, orderpUpsertArgs>
    ): CheckSelect<T, Prisma__orderpClient<orderp>, Prisma__orderpClient<orderpGetPayload<T>>>

    /**
     * Count the number of Orderps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderpCountArgs} args - Arguments to filter Orderps to count.
     * @example
     * // Count the number of Orderps
     * const count = await prisma.orderp.count({
     *   where: {
     *     // ... the filter for the Orderps we want to count
     *   }
     * })
    **/
    count<T extends orderpCountArgs>(
      args?: Subset<T, orderpCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orderp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderpAggregateArgs>(args: Subset<T, OrderpAggregateArgs>): PrismaPromise<GetOrderpAggregateType<T>>

    /**
     * Group by Orderp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderpGroupByArgs['orderBy'] }
        : { orderBy?: OrderpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderpGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderpClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientpeople<T extends clientpeopleArgs = {}>(args?: Subset<T, clientpeopleArgs>): CheckSelect<T, Prisma__clientpeopleClient<clientpeople | null >, Prisma__clientpeopleClient<clientpeopleGetPayload<T> | null >>;

    club<T extends clubArgs = {}>(args?: Subset<T, clubArgs>): CheckSelect<T, Prisma__clubClient<club | null >, Prisma__clubClient<clubGetPayload<T> | null >>;

    orderline<T extends orderlineFindManyArgs = {}>(args?: Subset<T, orderlineFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orderline>>, PrismaPromise<Array<orderlineGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * orderp findUnique
   */
  export type orderpFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * Throw an Error if a orderp can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderp to fetch.
     * 
    **/
    where: orderpWhereUniqueInput
  }


  /**
   * orderp findFirst
   */
  export type orderpFindFirstArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * Throw an Error if a orderp can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which orderp to fetch.
     * 
    **/
    where?: orderpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderps to fetch.
     * 
    **/
    orderBy?: Enumerable<orderpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderps.
     * 
    **/
    cursor?: orderpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderps.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderps.
     * 
    **/
    distinct?: Enumerable<OrderpScalarFieldEnum>
  }


  /**
   * orderp findMany
   */
  export type orderpFindManyArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * Filter, which orderps to fetch.
     * 
    **/
    where?: orderpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderps to fetch.
     * 
    **/
    orderBy?: Enumerable<orderpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderps.
     * 
    **/
    cursor?: orderpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderps from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderps.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderpScalarFieldEnum>
  }


  /**
   * orderp create
   */
  export type orderpCreateArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * The data needed to create a orderp.
     * 
    **/
    data: XOR<orderpCreateInput, orderpUncheckedCreateInput>
  }


  /**
   * orderp createMany
   */
  export type orderpCreateManyArgs = {
    /**
     * The data used to create many orderps.
     * 
    **/
    data: Enumerable<orderpCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * orderp update
   */
  export type orderpUpdateArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * The data needed to update a orderp.
     * 
    **/
    data: XOR<orderpUpdateInput, orderpUncheckedUpdateInput>
    /**
     * Choose, which orderp to update.
     * 
    **/
    where: orderpWhereUniqueInput
  }


  /**
   * orderp updateMany
   */
  export type orderpUpdateManyArgs = {
    /**
     * The data used to update orderps.
     * 
    **/
    data: XOR<orderpUpdateManyMutationInput, orderpUncheckedUpdateManyInput>
    /**
     * Filter which orderps to update
     * 
    **/
    where?: orderpWhereInput
  }


  /**
   * orderp upsert
   */
  export type orderpUpsertArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * The filter to search for the orderp to update in case it exists.
     * 
    **/
    where: orderpWhereUniqueInput
    /**
     * In case the orderp found by the `where` argument doesn't exist, create a new orderp with this data.
     * 
    **/
    create: XOR<orderpCreateInput, orderpUncheckedCreateInput>
    /**
     * In case the orderp was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<orderpUpdateInput, orderpUncheckedUpdateInput>
  }


  /**
   * orderp delete
   */
  export type orderpDeleteArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
    /**
     * Filter which orderp to delete.
     * 
    **/
    where: orderpWhereUniqueInput
  }


  /**
   * orderp deleteMany
   */
  export type orderpDeleteManyArgs = {
    /**
     * Filter which orderps to delete
     * 
    **/
    where?: orderpWhereInput
  }


  /**
   * orderp without action
   */
  export type orderpArgs = {
    /**
     * Select specific fields to fetch from the orderp
     * 
    **/
    select?: orderpSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: orderpInclude | null
  }



  /**
   * Model popularproducts
   */


  export type AggregatePopularproducts = {
    _count: PopularproductsCountAggregateOutputType | null
    _avg: PopularproductsAvgAggregateOutputType | null
    _sum: PopularproductsSumAggregateOutputType | null
    _min: PopularproductsMinAggregateOutputType | null
    _max: PopularproductsMaxAggregateOutputType | null
  }

  export type PopularproductsAvgAggregateOutputType = {
    idPopularProducts: number | null
    idProduct: number | null
    amount: number | null
    idClub: number | null
  }

  export type PopularproductsSumAggregateOutputType = {
    idPopularProducts: number | null
    idProduct: number | null
    amount: number | null
    idClub: number | null
  }

  export type PopularproductsMinAggregateOutputType = {
    idPopularProducts: number | null
    idProduct: number | null
    amount: number | null
    idClub: number | null
  }

  export type PopularproductsMaxAggregateOutputType = {
    idPopularProducts: number | null
    idProduct: number | null
    amount: number | null
    idClub: number | null
  }

  export type PopularproductsCountAggregateOutputType = {
    idPopularProducts: number
    idProduct: number
    amount: number
    idClub: number
    _all: number
  }


  export type PopularproductsAvgAggregateInputType = {
    idPopularProducts?: true
    idProduct?: true
    amount?: true
    idClub?: true
  }

  export type PopularproductsSumAggregateInputType = {
    idPopularProducts?: true
    idProduct?: true
    amount?: true
    idClub?: true
  }

  export type PopularproductsMinAggregateInputType = {
    idPopularProducts?: true
    idProduct?: true
    amount?: true
    idClub?: true
  }

  export type PopularproductsMaxAggregateInputType = {
    idPopularProducts?: true
    idProduct?: true
    amount?: true
    idClub?: true
  }

  export type PopularproductsCountAggregateInputType = {
    idPopularProducts?: true
    idProduct?: true
    amount?: true
    idClub?: true
    _all?: true
  }

  export type PopularproductsAggregateArgs = {
    /**
     * Filter which popularproducts to aggregate.
     * 
    **/
    where?: popularproductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popularproducts to fetch.
     * 
    **/
    orderBy?: Enumerable<popularproductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: popularproductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popularproducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popularproducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned popularproducts
    **/
    _count?: true | PopularproductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PopularproductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PopularproductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PopularproductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PopularproductsMaxAggregateInputType
  }

  export type GetPopularproductsAggregateType<T extends PopularproductsAggregateArgs> = {
        [P in keyof T & keyof AggregatePopularproducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopularproducts[P]>
      : GetScalarType<T[P], AggregatePopularproducts[P]>
  }




  export type PopularproductsGroupByArgs = {
    where?: popularproductsWhereInput
    orderBy?: Enumerable<popularproductsOrderByWithAggregationInput>
    by: Array<PopularproductsScalarFieldEnum>
    having?: popularproductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PopularproductsCountAggregateInputType | true
    _avg?: PopularproductsAvgAggregateInputType
    _sum?: PopularproductsSumAggregateInputType
    _min?: PopularproductsMinAggregateInputType
    _max?: PopularproductsMaxAggregateInputType
  }


  export type PopularproductsGroupByOutputType = {
    idPopularProducts: number
    idProduct: number
    amount: number
    idClub: number
    _count: PopularproductsCountAggregateOutputType | null
    _avg: PopularproductsAvgAggregateOutputType | null
    _sum: PopularproductsSumAggregateOutputType | null
    _min: PopularproductsMinAggregateOutputType | null
    _max: PopularproductsMaxAggregateOutputType | null
  }

  type GetPopularproductsGroupByPayload<T extends PopularproductsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PopularproductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PopularproductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PopularproductsGroupByOutputType[P]>
            : GetScalarType<T[P], PopularproductsGroupByOutputType[P]>
        }
      >
    >


  export type popularproductsSelect = {
    idPopularProducts?: boolean
    idProduct?: boolean
    amount?: boolean
    idClub?: boolean
    club?: boolean | clubArgs
    product?: boolean | productArgs
  }

  export type popularproductsInclude = {
    club?: boolean | clubArgs
    product?: boolean | productArgs
  }

  export type popularproductsGetPayload<
    S extends boolean | null | undefined | popularproductsArgs,
    U = keyof S
      > = S extends true
        ? popularproducts
    : S extends undefined
    ? never
    : S extends popularproductsArgs | popularproductsFindManyArgs
    ?'include' extends U
    ? popularproducts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'club' ? clubGetPayload<S['include'][P]> :
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'club' ? clubGetPayload<S['select'][P]> :
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof popularproducts ? popularproducts[P] : never
  } 
    : popularproducts
  : popularproducts


  type popularproductsCountArgs = Merge<
    Omit<popularproductsFindManyArgs, 'select' | 'include'> & {
      select?: PopularproductsCountAggregateInputType | true
    }
  >

  export interface popularproductsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Popularproducts that matches the filter.
     * @param {popularproductsFindUniqueArgs} args - Arguments to find a Popularproducts
     * @example
     * // Get one Popularproducts
     * const popularproducts = await prisma.popularproducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends popularproductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, popularproductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'popularproducts'> extends True ? CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>> : CheckSelect<T, Prisma__popularproductsClient<popularproducts | null >, Prisma__popularproductsClient<popularproductsGetPayload<T> | null >>

    /**
     * Find the first Popularproducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popularproductsFindFirstArgs} args - Arguments to find a Popularproducts
     * @example
     * // Get one Popularproducts
     * const popularproducts = await prisma.popularproducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends popularproductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, popularproductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'popularproducts'> extends True ? CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>> : CheckSelect<T, Prisma__popularproductsClient<popularproducts | null >, Prisma__popularproductsClient<popularproductsGetPayload<T> | null >>

    /**
     * Find zero or more Popularproducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popularproductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Popularproducts
     * const popularproducts = await prisma.popularproducts.findMany()
     * 
     * // Get first 10 Popularproducts
     * const popularproducts = await prisma.popularproducts.findMany({ take: 10 })
     * 
     * // Only select the `idPopularProducts`
     * const popularproductsWithIdPopularProductsOnly = await prisma.popularproducts.findMany({ select: { idPopularProducts: true } })
     * 
    **/
    findMany<T extends popularproductsFindManyArgs>(
      args?: SelectSubset<T, popularproductsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<popularproducts>>, PrismaPromise<Array<popularproductsGetPayload<T>>>>

    /**
     * Create a Popularproducts.
     * @param {popularproductsCreateArgs} args - Arguments to create a Popularproducts.
     * @example
     * // Create one Popularproducts
     * const Popularproducts = await prisma.popularproducts.create({
     *   data: {
     *     // ... data to create a Popularproducts
     *   }
     * })
     * 
    **/
    create<T extends popularproductsCreateArgs>(
      args: SelectSubset<T, popularproductsCreateArgs>
    ): CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>>

    /**
     * Create many Popularproducts.
     *     @param {popularproductsCreateManyArgs} args - Arguments to create many Popularproducts.
     *     @example
     *     // Create many Popularproducts
     *     const popularproducts = await prisma.popularproducts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends popularproductsCreateManyArgs>(
      args?: SelectSubset<T, popularproductsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Popularproducts.
     * @param {popularproductsDeleteArgs} args - Arguments to delete one Popularproducts.
     * @example
     * // Delete one Popularproducts
     * const Popularproducts = await prisma.popularproducts.delete({
     *   where: {
     *     // ... filter to delete one Popularproducts
     *   }
     * })
     * 
    **/
    delete<T extends popularproductsDeleteArgs>(
      args: SelectSubset<T, popularproductsDeleteArgs>
    ): CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>>

    /**
     * Update one Popularproducts.
     * @param {popularproductsUpdateArgs} args - Arguments to update one Popularproducts.
     * @example
     * // Update one Popularproducts
     * const popularproducts = await prisma.popularproducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends popularproductsUpdateArgs>(
      args: SelectSubset<T, popularproductsUpdateArgs>
    ): CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>>

    /**
     * Delete zero or more Popularproducts.
     * @param {popularproductsDeleteManyArgs} args - Arguments to filter Popularproducts to delete.
     * @example
     * // Delete a few Popularproducts
     * const { count } = await prisma.popularproducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends popularproductsDeleteManyArgs>(
      args?: SelectSubset<T, popularproductsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Popularproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popularproductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Popularproducts
     * const popularproducts = await prisma.popularproducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends popularproductsUpdateManyArgs>(
      args: SelectSubset<T, popularproductsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Popularproducts.
     * @param {popularproductsUpsertArgs} args - Arguments to update or create a Popularproducts.
     * @example
     * // Update or create a Popularproducts
     * const popularproducts = await prisma.popularproducts.upsert({
     *   create: {
     *     // ... data to create a Popularproducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Popularproducts we want to update
     *   }
     * })
    **/
    upsert<T extends popularproductsUpsertArgs>(
      args: SelectSubset<T, popularproductsUpsertArgs>
    ): CheckSelect<T, Prisma__popularproductsClient<popularproducts>, Prisma__popularproductsClient<popularproductsGetPayload<T>>>

    /**
     * Count the number of Popularproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popularproductsCountArgs} args - Arguments to filter Popularproducts to count.
     * @example
     * // Count the number of Popularproducts
     * const count = await prisma.popularproducts.count({
     *   where: {
     *     // ... the filter for the Popularproducts we want to count
     *   }
     * })
    **/
    count<T extends popularproductsCountArgs>(
      args?: Subset<T, popularproductsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PopularproductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Popularproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopularproductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PopularproductsAggregateArgs>(args: Subset<T, PopularproductsAggregateArgs>): PrismaPromise<GetPopularproductsAggregateType<T>>

    /**
     * Group by Popularproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PopularproductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PopularproductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PopularproductsGroupByArgs['orderBy'] }
        : { orderBy?: PopularproductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PopularproductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopularproductsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for popularproducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__popularproductsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    club<T extends clubArgs = {}>(args?: Subset<T, clubArgs>): CheckSelect<T, Prisma__clubClient<club | null >, Prisma__clubClient<clubGetPayload<T> | null >>;

    product<T extends productArgs = {}>(args?: Subset<T, productArgs>): CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * popularproducts findUnique
   */
  export type popularproductsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * Throw an Error if a popularproducts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which popularproducts to fetch.
     * 
    **/
    where: popularproductsWhereUniqueInput
  }


  /**
   * popularproducts findFirst
   */
  export type popularproductsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * Throw an Error if a popularproducts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which popularproducts to fetch.
     * 
    **/
    where?: popularproductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popularproducts to fetch.
     * 
    **/
    orderBy?: Enumerable<popularproductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popularproducts.
     * 
    **/
    cursor?: popularproductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popularproducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popularproducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popularproducts.
     * 
    **/
    distinct?: Enumerable<PopularproductsScalarFieldEnum>
  }


  /**
   * popularproducts findMany
   */
  export type popularproductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * Filter, which popularproducts to fetch.
     * 
    **/
    where?: popularproductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popularproducts to fetch.
     * 
    **/
    orderBy?: Enumerable<popularproductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing popularproducts.
     * 
    **/
    cursor?: popularproductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popularproducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popularproducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PopularproductsScalarFieldEnum>
  }


  /**
   * popularproducts create
   */
  export type popularproductsCreateArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * The data needed to create a popularproducts.
     * 
    **/
    data: XOR<popularproductsCreateInput, popularproductsUncheckedCreateInput>
  }


  /**
   * popularproducts createMany
   */
  export type popularproductsCreateManyArgs = {
    /**
     * The data used to create many popularproducts.
     * 
    **/
    data: Enumerable<popularproductsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * popularproducts update
   */
  export type popularproductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * The data needed to update a popularproducts.
     * 
    **/
    data: XOR<popularproductsUpdateInput, popularproductsUncheckedUpdateInput>
    /**
     * Choose, which popularproducts to update.
     * 
    **/
    where: popularproductsWhereUniqueInput
  }


  /**
   * popularproducts updateMany
   */
  export type popularproductsUpdateManyArgs = {
    /**
     * The data used to update popularproducts.
     * 
    **/
    data: XOR<popularproductsUpdateManyMutationInput, popularproductsUncheckedUpdateManyInput>
    /**
     * Filter which popularproducts to update
     * 
    **/
    where?: popularproductsWhereInput
  }


  /**
   * popularproducts upsert
   */
  export type popularproductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * The filter to search for the popularproducts to update in case it exists.
     * 
    **/
    where: popularproductsWhereUniqueInput
    /**
     * In case the popularproducts found by the `where` argument doesn't exist, create a new popularproducts with this data.
     * 
    **/
    create: XOR<popularproductsCreateInput, popularproductsUncheckedCreateInput>
    /**
     * In case the popularproducts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<popularproductsUpdateInput, popularproductsUncheckedUpdateInput>
  }


  /**
   * popularproducts delete
   */
  export type popularproductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
    /**
     * Filter which popularproducts to delete.
     * 
    **/
    where: popularproductsWhereUniqueInput
  }


  /**
   * popularproducts deleteMany
   */
  export type popularproductsDeleteManyArgs = {
    /**
     * Filter which popularproducts to delete
     * 
    **/
    where?: popularproductsWhereInput
  }


  /**
   * popularproducts without action
   */
  export type popularproductsArgs = {
    /**
     * Select specific fields to fetch from the popularproducts
     * 
    **/
    select?: popularproductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: popularproductsInclude | null
  }



  /**
   * Model presentation
   */


  export type AggregatePresentation = {
    _count: PresentationCountAggregateOutputType | null
    _avg: PresentationAvgAggregateOutputType | null
    _sum: PresentationSumAggregateOutputType | null
    _min: PresentationMinAggregateOutputType | null
    _max: PresentationMaxAggregateOutputType | null
  }

  export type PresentationAvgAggregateOutputType = {
    idPresentation: number | null
    idProduct: number | null
    amountBottles: number | null
    sizeBottle: number | null
  }

  export type PresentationSumAggregateOutputType = {
    idPresentation: number | null
    idProduct: number | null
    amountBottles: number | null
    sizeBottle: number | null
  }

  export type PresentationMinAggregateOutputType = {
    idPresentation: number | null
    idProduct: number | null
    amountBottles: number | null
    sizeBottle: number | null
  }

  export type PresentationMaxAggregateOutputType = {
    idPresentation: number | null
    idProduct: number | null
    amountBottles: number | null
    sizeBottle: number | null
  }

  export type PresentationCountAggregateOutputType = {
    idPresentation: number
    idProduct: number
    amountBottles: number
    sizeBottle: number
    _all: number
  }


  export type PresentationAvgAggregateInputType = {
    idPresentation?: true
    idProduct?: true
    amountBottles?: true
    sizeBottle?: true
  }

  export type PresentationSumAggregateInputType = {
    idPresentation?: true
    idProduct?: true
    amountBottles?: true
    sizeBottle?: true
  }

  export type PresentationMinAggregateInputType = {
    idPresentation?: true
    idProduct?: true
    amountBottles?: true
    sizeBottle?: true
  }

  export type PresentationMaxAggregateInputType = {
    idPresentation?: true
    idProduct?: true
    amountBottles?: true
    sizeBottle?: true
  }

  export type PresentationCountAggregateInputType = {
    idPresentation?: true
    idProduct?: true
    amountBottles?: true
    sizeBottle?: true
    _all?: true
  }

  export type PresentationAggregateArgs = {
    /**
     * Filter which presentation to aggregate.
     * 
    **/
    where?: presentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentations to fetch.
     * 
    **/
    orderBy?: Enumerable<presentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: presentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned presentations
    **/
    _count?: true | PresentationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresentationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresentationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresentationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresentationMaxAggregateInputType
  }

  export type GetPresentationAggregateType<T extends PresentationAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentation[P]>
      : GetScalarType<T[P], AggregatePresentation[P]>
  }




  export type PresentationGroupByArgs = {
    where?: presentationWhereInput
    orderBy?: Enumerable<presentationOrderByWithAggregationInput>
    by: Array<PresentationScalarFieldEnum>
    having?: presentationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresentationCountAggregateInputType | true
    _avg?: PresentationAvgAggregateInputType
    _sum?: PresentationSumAggregateInputType
    _min?: PresentationMinAggregateInputType
    _max?: PresentationMaxAggregateInputType
  }


  export type PresentationGroupByOutputType = {
    idPresentation: number
    idProduct: number
    amountBottles: number
    sizeBottle: number
    _count: PresentationCountAggregateOutputType | null
    _avg: PresentationAvgAggregateOutputType | null
    _sum: PresentationSumAggregateOutputType | null
    _min: PresentationMinAggregateOutputType | null
    _max: PresentationMaxAggregateOutputType | null
  }

  type GetPresentationGroupByPayload<T extends PresentationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PresentationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresentationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresentationGroupByOutputType[P]>
            : GetScalarType<T[P], PresentationGroupByOutputType[P]>
        }
      >
    >


  export type presentationSelect = {
    idPresentation?: boolean
    idProduct?: boolean
    amountBottles?: boolean
    sizeBottle?: boolean
    product?: boolean | productArgs
  }

  export type presentationInclude = {
    product?: boolean | productArgs
  }

  export type presentationGetPayload<
    S extends boolean | null | undefined | presentationArgs,
    U = keyof S
      > = S extends true
        ? presentation
    : S extends undefined
    ? never
    : S extends presentationArgs | presentationFindManyArgs
    ?'include' extends U
    ? presentation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof presentation ? presentation[P] : never
  } 
    : presentation
  : presentation


  type presentationCountArgs = Merge<
    Omit<presentationFindManyArgs, 'select' | 'include'> & {
      select?: PresentationCountAggregateInputType | true
    }
  >

  export interface presentationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Presentation that matches the filter.
     * @param {presentationFindUniqueArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends presentationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, presentationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'presentation'> extends True ? CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>> : CheckSelect<T, Prisma__presentationClient<presentation | null >, Prisma__presentationClient<presentationGetPayload<T> | null >>

    /**
     * Find the first Presentation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentationFindFirstArgs} args - Arguments to find a Presentation
     * @example
     * // Get one Presentation
     * const presentation = await prisma.presentation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends presentationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, presentationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'presentation'> extends True ? CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>> : CheckSelect<T, Prisma__presentationClient<presentation | null >, Prisma__presentationClient<presentationGetPayload<T> | null >>

    /**
     * Find zero or more Presentations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presentations
     * const presentations = await prisma.presentation.findMany()
     * 
     * // Get first 10 Presentations
     * const presentations = await prisma.presentation.findMany({ take: 10 })
     * 
     * // Only select the `idPresentation`
     * const presentationWithIdPresentationOnly = await prisma.presentation.findMany({ select: { idPresentation: true } })
     * 
    **/
    findMany<T extends presentationFindManyArgs>(
      args?: SelectSubset<T, presentationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<presentation>>, PrismaPromise<Array<presentationGetPayload<T>>>>

    /**
     * Create a Presentation.
     * @param {presentationCreateArgs} args - Arguments to create a Presentation.
     * @example
     * // Create one Presentation
     * const Presentation = await prisma.presentation.create({
     *   data: {
     *     // ... data to create a Presentation
     *   }
     * })
     * 
    **/
    create<T extends presentationCreateArgs>(
      args: SelectSubset<T, presentationCreateArgs>
    ): CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>>

    /**
     * Create many Presentations.
     *     @param {presentationCreateManyArgs} args - Arguments to create many Presentations.
     *     @example
     *     // Create many Presentations
     *     const presentation = await prisma.presentation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends presentationCreateManyArgs>(
      args?: SelectSubset<T, presentationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Presentation.
     * @param {presentationDeleteArgs} args - Arguments to delete one Presentation.
     * @example
     * // Delete one Presentation
     * const Presentation = await prisma.presentation.delete({
     *   where: {
     *     // ... filter to delete one Presentation
     *   }
     * })
     * 
    **/
    delete<T extends presentationDeleteArgs>(
      args: SelectSubset<T, presentationDeleteArgs>
    ): CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>>

    /**
     * Update one Presentation.
     * @param {presentationUpdateArgs} args - Arguments to update one Presentation.
     * @example
     * // Update one Presentation
     * const presentation = await prisma.presentation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends presentationUpdateArgs>(
      args: SelectSubset<T, presentationUpdateArgs>
    ): CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>>

    /**
     * Delete zero or more Presentations.
     * @param {presentationDeleteManyArgs} args - Arguments to filter Presentations to delete.
     * @example
     * // Delete a few Presentations
     * const { count } = await prisma.presentation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends presentationDeleteManyArgs>(
      args?: SelectSubset<T, presentationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presentations
     * const presentation = await prisma.presentation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends presentationUpdateManyArgs>(
      args: SelectSubset<T, presentationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Presentation.
     * @param {presentationUpsertArgs} args - Arguments to update or create a Presentation.
     * @example
     * // Update or create a Presentation
     * const presentation = await prisma.presentation.upsert({
     *   create: {
     *     // ... data to create a Presentation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presentation we want to update
     *   }
     * })
    **/
    upsert<T extends presentationUpsertArgs>(
      args: SelectSubset<T, presentationUpsertArgs>
    ): CheckSelect<T, Prisma__presentationClient<presentation>, Prisma__presentationClient<presentationGetPayload<T>>>

    /**
     * Count the number of Presentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentationCountArgs} args - Arguments to filter Presentations to count.
     * @example
     * // Count the number of Presentations
     * const count = await prisma.presentation.count({
     *   where: {
     *     // ... the filter for the Presentations we want to count
     *   }
     * })
    **/
    count<T extends presentationCountArgs>(
      args?: Subset<T, presentationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresentationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresentationAggregateArgs>(args: Subset<T, PresentationAggregateArgs>): PrismaPromise<GetPresentationAggregateType<T>>

    /**
     * Group by Presentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresentationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresentationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresentationGroupByArgs['orderBy'] }
        : { orderBy?: PresentationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresentationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for presentation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__presentationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends productArgs = {}>(args?: Subset<T, productArgs>): CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * presentation findUnique
   */
  export type presentationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * Throw an Error if a presentation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which presentation to fetch.
     * 
    **/
    where: presentationWhereUniqueInput
  }


  /**
   * presentation findFirst
   */
  export type presentationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * Throw an Error if a presentation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which presentation to fetch.
     * 
    **/
    where?: presentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentations to fetch.
     * 
    **/
    orderBy?: Enumerable<presentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presentations.
     * 
    **/
    cursor?: presentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presentations.
     * 
    **/
    distinct?: Enumerable<PresentationScalarFieldEnum>
  }


  /**
   * presentation findMany
   */
  export type presentationFindManyArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * Filter, which presentations to fetch.
     * 
    **/
    where?: presentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentations to fetch.
     * 
    **/
    orderBy?: Enumerable<presentationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing presentations.
     * 
    **/
    cursor?: presentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PresentationScalarFieldEnum>
  }


  /**
   * presentation create
   */
  export type presentationCreateArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * The data needed to create a presentation.
     * 
    **/
    data: XOR<presentationCreateInput, presentationUncheckedCreateInput>
  }


  /**
   * presentation createMany
   */
  export type presentationCreateManyArgs = {
    /**
     * The data used to create many presentations.
     * 
    **/
    data: Enumerable<presentationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * presentation update
   */
  export type presentationUpdateArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * The data needed to update a presentation.
     * 
    **/
    data: XOR<presentationUpdateInput, presentationUncheckedUpdateInput>
    /**
     * Choose, which presentation to update.
     * 
    **/
    where: presentationWhereUniqueInput
  }


  /**
   * presentation updateMany
   */
  export type presentationUpdateManyArgs = {
    /**
     * The data used to update presentations.
     * 
    **/
    data: XOR<presentationUpdateManyMutationInput, presentationUncheckedUpdateManyInput>
    /**
     * Filter which presentations to update
     * 
    **/
    where?: presentationWhereInput
  }


  /**
   * presentation upsert
   */
  export type presentationUpsertArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * The filter to search for the presentation to update in case it exists.
     * 
    **/
    where: presentationWhereUniqueInput
    /**
     * In case the presentation found by the `where` argument doesn't exist, create a new presentation with this data.
     * 
    **/
    create: XOR<presentationCreateInput, presentationUncheckedCreateInput>
    /**
     * In case the presentation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<presentationUpdateInput, presentationUncheckedUpdateInput>
  }


  /**
   * presentation delete
   */
  export type presentationDeleteArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
    /**
     * Filter which presentation to delete.
     * 
    **/
    where: presentationWhereUniqueInput
  }


  /**
   * presentation deleteMany
   */
  export type presentationDeleteManyArgs = {
    /**
     * Filter which presentations to delete
     * 
    **/
    where?: presentationWhereInput
  }


  /**
   * presentation without action
   */
  export type presentationArgs = {
    /**
     * Select specific fields to fetch from the presentation
     * 
    **/
    select?: presentationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: presentationInclude | null
  }



  /**
   * Model product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    idProduct: number | null
    cost: Decimal | null
    idProductType: number | null
    idSupplier: number | null
    idCash: number | null
    tier: number | null
  }

  export type ProductSumAggregateOutputType = {
    idProduct: number | null
    cost: Decimal | null
    idProductType: number | null
    idSupplier: number | null
    idCash: number | null
    tier: number | null
  }

  export type ProductMinAggregateOutputType = {
    idProduct: number | null
    productName: string | null
    cost: Decimal | null
    idProductType: number | null
    image: Buffer | null
    idSupplier: number | null
    idCash: number | null
    isActive: boolean | null
    entryDate: Date | null
    tier: number | null
    productDescr: string | null
  }

  export type ProductMaxAggregateOutputType = {
    idProduct: number | null
    productName: string | null
    cost: Decimal | null
    idProductType: number | null
    image: Buffer | null
    idSupplier: number | null
    idCash: number | null
    isActive: boolean | null
    entryDate: Date | null
    tier: number | null
    productDescr: string | null
  }

  export type ProductCountAggregateOutputType = {
    idProduct: number
    productName: number
    cost: number
    idProductType: number
    image: number
    idSupplier: number
    idCash: number
    isActive: number
    entryDate: number
    tier: number
    productDescr: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    idProduct?: true
    cost?: true
    idProductType?: true
    idSupplier?: true
    idCash?: true
    tier?: true
  }

  export type ProductSumAggregateInputType = {
    idProduct?: true
    cost?: true
    idProductType?: true
    idSupplier?: true
    idCash?: true
    tier?: true
  }

  export type ProductMinAggregateInputType = {
    idProduct?: true
    productName?: true
    cost?: true
    idProductType?: true
    image?: true
    idSupplier?: true
    idCash?: true
    isActive?: true
    entryDate?: true
    tier?: true
    productDescr?: true
  }

  export type ProductMaxAggregateInputType = {
    idProduct?: true
    productName?: true
    cost?: true
    idProductType?: true
    image?: true
    idSupplier?: true
    idCash?: true
    isActive?: true
    entryDate?: true
    tier?: true
    productDescr?: true
  }

  export type ProductCountAggregateInputType = {
    idProduct?: true
    productName?: true
    cost?: true
    idProductType?: true
    image?: true
    idSupplier?: true
    idCash?: true
    isActive?: true
    entryDate?: true
    tier?: true
    productDescr?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which product to aggregate.
     * 
    **/
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     * 
    **/
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    idProduct: number
    productName: string | null
    cost: Decimal
    idProductType: number
    image: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date
    tier: number
    productDescr: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect = {
    idProduct?: boolean
    productName?: boolean
    cost?: boolean
    idProductType?: boolean
    image?: boolean
    idSupplier?: boolean
    idCash?: boolean
    isActive?: boolean
    entryDate?: boolean
    tier?: boolean
    productDescr?: boolean
    cash?: boolean | cashArgs
    producttype?: boolean | producttypeArgs
    supplier?: boolean | supplierArgs
    inventory?: boolean | inventoryFindManyArgs
    orderline?: boolean | orderlineFindManyArgs
    popularproducts?: boolean | popularproductsFindManyArgs
    presentation?: boolean | presentationFindManyArgs
    review?: boolean | reviewFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type productInclude = {
    cash?: boolean | cashArgs
    producttype?: boolean | producttypeArgs
    supplier?: boolean | supplierArgs
    inventory?: boolean | inventoryFindManyArgs
    orderline?: boolean | orderlineFindManyArgs
    popularproducts?: boolean | popularproductsFindManyArgs
    presentation?: boolean | presentationFindManyArgs
    review?: boolean | reviewFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type productGetPayload<
    S extends boolean | null | undefined | productArgs,
    U = keyof S
      > = S extends true
        ? product
    : S extends undefined
    ? never
    : S extends productArgs | productFindManyArgs
    ?'include' extends U
    ? product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cash' ? cashGetPayload<S['include'][P]> :
        P extends 'producttype' ? producttypeGetPayload<S['include'][P]> :
        P extends 'supplier' ? supplierGetPayload<S['include'][P]> :
        P extends 'inventory' ? Array < inventoryGetPayload<S['include'][P]>>  :
        P extends 'orderline' ? Array < orderlineGetPayload<S['include'][P]>>  :
        P extends 'popularproducts' ? Array < popularproductsGetPayload<S['include'][P]>>  :
        P extends 'presentation' ? Array < presentationGetPayload<S['include'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cash' ? cashGetPayload<S['select'][P]> :
        P extends 'producttype' ? producttypeGetPayload<S['select'][P]> :
        P extends 'supplier' ? supplierGetPayload<S['select'][P]> :
        P extends 'inventory' ? Array < inventoryGetPayload<S['select'][P]>>  :
        P extends 'orderline' ? Array < orderlineGetPayload<S['select'][P]>>  :
        P extends 'popularproducts' ? Array < popularproductsGetPayload<S['select'][P]>>  :
        P extends 'presentation' ? Array < presentationGetPayload<S['select'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof product ? product[P] : never
  } 
    : product
  : product


  type productCountArgs = Merge<
    Omit<productFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface productDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, productFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'product'> extends True ? CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>> : CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, productFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'product'> extends True ? CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>> : CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `idProduct`
     * const productWithIdProductOnly = await prisma.product.findMany({ select: { idProduct: true } })
     * 
    **/
    findMany<T extends productFindManyArgs>(
      args?: SelectSubset<T, productFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<product>>, PrismaPromise<Array<productGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs>(
      args: SelectSubset<T, productCreateArgs>
    ): CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs>(
      args?: SelectSubset<T, productCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs>(
      args: SelectSubset<T, productDeleteArgs>
    ): CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs>(
      args: SelectSubset<T, productUpdateArgs>
    ): CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs>(
      args?: SelectSubset<T, productDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs>(
      args: SelectSubset<T, productUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs>(
      args: SelectSubset<T, productUpsertArgs>
    ): CheckSelect<T, Prisma__productClient<product>, Prisma__productClient<productGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__productClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cash<T extends cashArgs = {}>(args?: Subset<T, cashArgs>): CheckSelect<T, Prisma__cashClient<cash | null >, Prisma__cashClient<cashGetPayload<T> | null >>;

    producttype<T extends producttypeArgs = {}>(args?: Subset<T, producttypeArgs>): CheckSelect<T, Prisma__producttypeClient<producttype | null >, Prisma__producttypeClient<producttypeGetPayload<T> | null >>;

    supplier<T extends supplierArgs = {}>(args?: Subset<T, supplierArgs>): CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>;

    inventory<T extends inventoryFindManyArgs = {}>(args?: Subset<T, inventoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<inventory>>, PrismaPromise<Array<inventoryGetPayload<T>>>>;

    orderline<T extends orderlineFindManyArgs = {}>(args?: Subset<T, orderlineFindManyArgs>): CheckSelect<T, PrismaPromise<Array<orderline>>, PrismaPromise<Array<orderlineGetPayload<T>>>>;

    popularproducts<T extends popularproductsFindManyArgs = {}>(args?: Subset<T, popularproductsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<popularproducts>>, PrismaPromise<Array<popularproductsGetPayload<T>>>>;

    presentation<T extends presentationFindManyArgs = {}>(args?: Subset<T, presentationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<presentation>>, PrismaPromise<Array<presentationGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * Throw an Error if a product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which product to fetch.
     * 
    **/
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * Throw an Error if a product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which product to fetch.
     * 
    **/
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     * 
    **/
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     * 
    **/
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product findMany
   */
  export type productFindManyArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * Filter, which products to fetch.
     * 
    **/
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     * 
    **/
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     * 
    **/
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product create
   */
  export type productCreateArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * The data needed to create a product.
     * 
    **/
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs = {
    /**
     * The data used to create many products.
     * 
    **/
    data: Enumerable<productCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * The data needed to update a product.
     * 
    **/
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     * 
    **/
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs = {
    /**
     * The data used to update products.
     * 
    **/
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     * 
    **/
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * The filter to search for the product to update in case it exists.
     * 
    **/
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     * 
    **/
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
    /**
     * Filter which product to delete.
     * 
    **/
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs = {
    /**
     * Filter which products to delete
     * 
    **/
    where?: productWhereInput
  }


  /**
   * product without action
   */
  export type productArgs = {
    /**
     * Select specific fields to fetch from the product
     * 
    **/
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: productInclude | null
  }



  /**
   * Model producttype
   */


  export type AggregateProducttype = {
    _count: ProducttypeCountAggregateOutputType | null
    _avg: ProducttypeAvgAggregateOutputType | null
    _sum: ProducttypeSumAggregateOutputType | null
    _min: ProducttypeMinAggregateOutputType | null
    _max: ProducttypeMaxAggregateOutputType | null
  }

  export type ProducttypeAvgAggregateOutputType = {
    idProductType: number | null
  }

  export type ProducttypeSumAggregateOutputType = {
    idProductType: number | null
  }

  export type ProducttypeMinAggregateOutputType = {
    idProductType: number | null
    typeName: string | null
    isActive: boolean | null
  }

  export type ProducttypeMaxAggregateOutputType = {
    idProductType: number | null
    typeName: string | null
    isActive: boolean | null
  }

  export type ProducttypeCountAggregateOutputType = {
    idProductType: number
    typeName: number
    isActive: number
    _all: number
  }


  export type ProducttypeAvgAggregateInputType = {
    idProductType?: true
  }

  export type ProducttypeSumAggregateInputType = {
    idProductType?: true
  }

  export type ProducttypeMinAggregateInputType = {
    idProductType?: true
    typeName?: true
    isActive?: true
  }

  export type ProducttypeMaxAggregateInputType = {
    idProductType?: true
    typeName?: true
    isActive?: true
  }

  export type ProducttypeCountAggregateInputType = {
    idProductType?: true
    typeName?: true
    isActive?: true
    _all?: true
  }

  export type ProducttypeAggregateArgs = {
    /**
     * Filter which producttype to aggregate.
     * 
    **/
    where?: producttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producttypes to fetch.
     * 
    **/
    orderBy?: Enumerable<producttypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: producttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producttypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producttypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned producttypes
    **/
    _count?: true | ProducttypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProducttypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProducttypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProducttypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProducttypeMaxAggregateInputType
  }

  export type GetProducttypeAggregateType<T extends ProducttypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProducttype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducttype[P]>
      : GetScalarType<T[P], AggregateProducttype[P]>
  }




  export type ProducttypeGroupByArgs = {
    where?: producttypeWhereInput
    orderBy?: Enumerable<producttypeOrderByWithAggregationInput>
    by: Array<ProducttypeScalarFieldEnum>
    having?: producttypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProducttypeCountAggregateInputType | true
    _avg?: ProducttypeAvgAggregateInputType
    _sum?: ProducttypeSumAggregateInputType
    _min?: ProducttypeMinAggregateInputType
    _max?: ProducttypeMaxAggregateInputType
  }


  export type ProducttypeGroupByOutputType = {
    idProductType: number
    typeName: string
    isActive: boolean
    _count: ProducttypeCountAggregateOutputType | null
    _avg: ProducttypeAvgAggregateOutputType | null
    _sum: ProducttypeSumAggregateOutputType | null
    _min: ProducttypeMinAggregateOutputType | null
    _max: ProducttypeMaxAggregateOutputType | null
  }

  type GetProducttypeGroupByPayload<T extends ProducttypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProducttypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProducttypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProducttypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProducttypeGroupByOutputType[P]>
        }
      >
    >


  export type producttypeSelect = {
    idProductType?: boolean
    typeName?: boolean
    isActive?: boolean
    product?: boolean | productFindManyArgs
    _count?: boolean | ProducttypeCountOutputTypeArgs
  }

  export type producttypeInclude = {
    product?: boolean | productFindManyArgs
    _count?: boolean | ProducttypeCountOutputTypeArgs
  }

  export type producttypeGetPayload<
    S extends boolean | null | undefined | producttypeArgs,
    U = keyof S
      > = S extends true
        ? producttype
    : S extends undefined
    ? never
    : S extends producttypeArgs | producttypeFindManyArgs
    ?'include' extends U
    ? producttype  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProducttypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProducttypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof producttype ? producttype[P] : never
  } 
    : producttype
  : producttype


  type producttypeCountArgs = Merge<
    Omit<producttypeFindManyArgs, 'select' | 'include'> & {
      select?: ProducttypeCountAggregateInputType | true
    }
  >

  export interface producttypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Producttype that matches the filter.
     * @param {producttypeFindUniqueArgs} args - Arguments to find a Producttype
     * @example
     * // Get one Producttype
     * const producttype = await prisma.producttype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends producttypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, producttypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'producttype'> extends True ? CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>> : CheckSelect<T, Prisma__producttypeClient<producttype | null >, Prisma__producttypeClient<producttypeGetPayload<T> | null >>

    /**
     * Find the first Producttype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producttypeFindFirstArgs} args - Arguments to find a Producttype
     * @example
     * // Get one Producttype
     * const producttype = await prisma.producttype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends producttypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, producttypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'producttype'> extends True ? CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>> : CheckSelect<T, Prisma__producttypeClient<producttype | null >, Prisma__producttypeClient<producttypeGetPayload<T> | null >>

    /**
     * Find zero or more Producttypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producttypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Producttypes
     * const producttypes = await prisma.producttype.findMany()
     * 
     * // Get first 10 Producttypes
     * const producttypes = await prisma.producttype.findMany({ take: 10 })
     * 
     * // Only select the `idProductType`
     * const producttypeWithIdProductTypeOnly = await prisma.producttype.findMany({ select: { idProductType: true } })
     * 
    **/
    findMany<T extends producttypeFindManyArgs>(
      args?: SelectSubset<T, producttypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<producttype>>, PrismaPromise<Array<producttypeGetPayload<T>>>>

    /**
     * Create a Producttype.
     * @param {producttypeCreateArgs} args - Arguments to create a Producttype.
     * @example
     * // Create one Producttype
     * const Producttype = await prisma.producttype.create({
     *   data: {
     *     // ... data to create a Producttype
     *   }
     * })
     * 
    **/
    create<T extends producttypeCreateArgs>(
      args: SelectSubset<T, producttypeCreateArgs>
    ): CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>>

    /**
     * Create many Producttypes.
     *     @param {producttypeCreateManyArgs} args - Arguments to create many Producttypes.
     *     @example
     *     // Create many Producttypes
     *     const producttype = await prisma.producttype.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends producttypeCreateManyArgs>(
      args?: SelectSubset<T, producttypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Producttype.
     * @param {producttypeDeleteArgs} args - Arguments to delete one Producttype.
     * @example
     * // Delete one Producttype
     * const Producttype = await prisma.producttype.delete({
     *   where: {
     *     // ... filter to delete one Producttype
     *   }
     * })
     * 
    **/
    delete<T extends producttypeDeleteArgs>(
      args: SelectSubset<T, producttypeDeleteArgs>
    ): CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>>

    /**
     * Update one Producttype.
     * @param {producttypeUpdateArgs} args - Arguments to update one Producttype.
     * @example
     * // Update one Producttype
     * const producttype = await prisma.producttype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends producttypeUpdateArgs>(
      args: SelectSubset<T, producttypeUpdateArgs>
    ): CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>>

    /**
     * Delete zero or more Producttypes.
     * @param {producttypeDeleteManyArgs} args - Arguments to filter Producttypes to delete.
     * @example
     * // Delete a few Producttypes
     * const { count } = await prisma.producttype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends producttypeDeleteManyArgs>(
      args?: SelectSubset<T, producttypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producttypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Producttypes
     * const producttype = await prisma.producttype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends producttypeUpdateManyArgs>(
      args: SelectSubset<T, producttypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Producttype.
     * @param {producttypeUpsertArgs} args - Arguments to update or create a Producttype.
     * @example
     * // Update or create a Producttype
     * const producttype = await prisma.producttype.upsert({
     *   create: {
     *     // ... data to create a Producttype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producttype we want to update
     *   }
     * })
    **/
    upsert<T extends producttypeUpsertArgs>(
      args: SelectSubset<T, producttypeUpsertArgs>
    ): CheckSelect<T, Prisma__producttypeClient<producttype>, Prisma__producttypeClient<producttypeGetPayload<T>>>

    /**
     * Count the number of Producttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producttypeCountArgs} args - Arguments to filter Producttypes to count.
     * @example
     * // Count the number of Producttypes
     * const count = await prisma.producttype.count({
     *   where: {
     *     // ... the filter for the Producttypes we want to count
     *   }
     * })
    **/
    count<T extends producttypeCountArgs>(
      args?: Subset<T, producttypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProducttypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProducttypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProducttypeAggregateArgs>(args: Subset<T, ProducttypeAggregateArgs>): PrismaPromise<GetProducttypeAggregateType<T>>

    /**
     * Group by Producttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProducttypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProducttypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProducttypeGroupByArgs['orderBy'] }
        : { orderBy?: ProducttypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProducttypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducttypeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for producttype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__producttypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends productFindManyArgs = {}>(args?: Subset<T, productFindManyArgs>): CheckSelect<T, PrismaPromise<Array<product>>, PrismaPromise<Array<productGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * producttype findUnique
   */
  export type producttypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * Throw an Error if a producttype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which producttype to fetch.
     * 
    **/
    where: producttypeWhereUniqueInput
  }


  /**
   * producttype findFirst
   */
  export type producttypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * Throw an Error if a producttype can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which producttype to fetch.
     * 
    **/
    where?: producttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producttypes to fetch.
     * 
    **/
    orderBy?: Enumerable<producttypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producttypes.
     * 
    **/
    cursor?: producttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producttypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producttypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producttypes.
     * 
    **/
    distinct?: Enumerable<ProducttypeScalarFieldEnum>
  }


  /**
   * producttype findMany
   */
  export type producttypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * Filter, which producttypes to fetch.
     * 
    **/
    where?: producttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producttypes to fetch.
     * 
    **/
    orderBy?: Enumerable<producttypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing producttypes.
     * 
    **/
    cursor?: producttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producttypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producttypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProducttypeScalarFieldEnum>
  }


  /**
   * producttype create
   */
  export type producttypeCreateArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * The data needed to create a producttype.
     * 
    **/
    data: XOR<producttypeCreateInput, producttypeUncheckedCreateInput>
  }


  /**
   * producttype createMany
   */
  export type producttypeCreateManyArgs = {
    /**
     * The data used to create many producttypes.
     * 
    **/
    data: Enumerable<producttypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * producttype update
   */
  export type producttypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * The data needed to update a producttype.
     * 
    **/
    data: XOR<producttypeUpdateInput, producttypeUncheckedUpdateInput>
    /**
     * Choose, which producttype to update.
     * 
    **/
    where: producttypeWhereUniqueInput
  }


  /**
   * producttype updateMany
   */
  export type producttypeUpdateManyArgs = {
    /**
     * The data used to update producttypes.
     * 
    **/
    data: XOR<producttypeUpdateManyMutationInput, producttypeUncheckedUpdateManyInput>
    /**
     * Filter which producttypes to update
     * 
    **/
    where?: producttypeWhereInput
  }


  /**
   * producttype upsert
   */
  export type producttypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * The filter to search for the producttype to update in case it exists.
     * 
    **/
    where: producttypeWhereUniqueInput
    /**
     * In case the producttype found by the `where` argument doesn't exist, create a new producttype with this data.
     * 
    **/
    create: XOR<producttypeCreateInput, producttypeUncheckedCreateInput>
    /**
     * In case the producttype was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<producttypeUpdateInput, producttypeUncheckedUpdateInput>
  }


  /**
   * producttype delete
   */
  export type producttypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
    /**
     * Filter which producttype to delete.
     * 
    **/
    where: producttypeWhereUniqueInput
  }


  /**
   * producttype deleteMany
   */
  export type producttypeDeleteManyArgs = {
    /**
     * Filter which producttypes to delete
     * 
    **/
    where?: producttypeWhereInput
  }


  /**
   * producttype without action
   */
  export type producttypeArgs = {
    /**
     * Select specific fields to fetch from the producttype
     * 
    **/
    select?: producttypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: producttypeInclude | null
  }



  /**
   * Model qualification
   */


  export type AggregateQualification = {
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  export type QualificationAvgAggregateOutputType = {
    idQualification: number | null
    idWorkerReview: number | null
  }

  export type QualificationSumAggregateOutputType = {
    idQualification: number | null
    idWorkerReview: number | null
  }

  export type QualificationMinAggregateOutputType = {
    idQualification: number | null
    idWorkerReview: number | null
    qualDescription: string | null
  }

  export type QualificationMaxAggregateOutputType = {
    idQualification: number | null
    idWorkerReview: number | null
    qualDescription: string | null
  }

  export type QualificationCountAggregateOutputType = {
    idQualification: number
    idWorkerReview: number
    qualDescription: number
    _all: number
  }


  export type QualificationAvgAggregateInputType = {
    idQualification?: true
    idWorkerReview?: true
  }

  export type QualificationSumAggregateInputType = {
    idQualification?: true
    idWorkerReview?: true
  }

  export type QualificationMinAggregateInputType = {
    idQualification?: true
    idWorkerReview?: true
    qualDescription?: true
  }

  export type QualificationMaxAggregateInputType = {
    idQualification?: true
    idWorkerReview?: true
    qualDescription?: true
  }

  export type QualificationCountAggregateInputType = {
    idQualification?: true
    idWorkerReview?: true
    qualDescription?: true
    _all?: true
  }

  export type QualificationAggregateArgs = {
    /**
     * Filter which qualification to aggregate.
     * 
    **/
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qualifications
    **/
    _count?: true | QualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualificationMaxAggregateInputType
  }

  export type GetQualificationAggregateType<T extends QualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualification[P]>
      : GetScalarType<T[P], AggregateQualification[P]>
  }




  export type QualificationGroupByArgs = {
    where?: qualificationWhereInput
    orderBy?: Enumerable<qualificationOrderByWithAggregationInput>
    by: Array<QualificationScalarFieldEnum>
    having?: qualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualificationCountAggregateInputType | true
    _avg?: QualificationAvgAggregateInputType
    _sum?: QualificationSumAggregateInputType
    _min?: QualificationMinAggregateInputType
    _max?: QualificationMaxAggregateInputType
  }


  export type QualificationGroupByOutputType = {
    idQualification: number
    idWorkerReview: number
    qualDescription: string
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  type GetQualificationGroupByPayload<T extends QualificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualificationGroupByOutputType[P]>
            : GetScalarType<T[P], QualificationGroupByOutputType[P]>
        }
      >
    >


  export type qualificationSelect = {
    idQualification?: boolean
    idWorkerReview?: boolean
    qualDescription?: boolean
    workerreview?: boolean | workerreviewArgs
  }

  export type qualificationInclude = {
    workerreview?: boolean | workerreviewArgs
  }

  export type qualificationGetPayload<
    S extends boolean | null | undefined | qualificationArgs,
    U = keyof S
      > = S extends true
        ? qualification
    : S extends undefined
    ? never
    : S extends qualificationArgs | qualificationFindManyArgs
    ?'include' extends U
    ? qualification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'workerreview' ? workerreviewGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'workerreview' ? workerreviewGetPayload<S['select'][P]> :  P extends keyof qualification ? qualification[P] : never
  } 
    : qualification
  : qualification


  type qualificationCountArgs = Merge<
    Omit<qualificationFindManyArgs, 'select' | 'include'> & {
      select?: QualificationCountAggregateInputType | true
    }
  >

  export interface qualificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Qualification that matches the filter.
     * @param {qualificationFindUniqueArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qualificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, qualificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'qualification'> extends True ? CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>> : CheckSelect<T, Prisma__qualificationClient<qualification | null >, Prisma__qualificationClient<qualificationGetPayload<T> | null >>

    /**
     * Find the first Qualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindFirstArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qualificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, qualificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'qualification'> extends True ? CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>> : CheckSelect<T, Prisma__qualificationClient<qualification | null >, Prisma__qualificationClient<qualificationGetPayload<T> | null >>

    /**
     * Find zero or more Qualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualifications
     * const qualifications = await prisma.qualification.findMany()
     * 
     * // Get first 10 Qualifications
     * const qualifications = await prisma.qualification.findMany({ take: 10 })
     * 
     * // Only select the `idQualification`
     * const qualificationWithIdQualificationOnly = await prisma.qualification.findMany({ select: { idQualification: true } })
     * 
    **/
    findMany<T extends qualificationFindManyArgs>(
      args?: SelectSubset<T, qualificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<qualification>>, PrismaPromise<Array<qualificationGetPayload<T>>>>

    /**
     * Create a Qualification.
     * @param {qualificationCreateArgs} args - Arguments to create a Qualification.
     * @example
     * // Create one Qualification
     * const Qualification = await prisma.qualification.create({
     *   data: {
     *     // ... data to create a Qualification
     *   }
     * })
     * 
    **/
    create<T extends qualificationCreateArgs>(
      args: SelectSubset<T, qualificationCreateArgs>
    ): CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>>

    /**
     * Create many Qualifications.
     *     @param {qualificationCreateManyArgs} args - Arguments to create many Qualifications.
     *     @example
     *     // Create many Qualifications
     *     const qualification = await prisma.qualification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qualificationCreateManyArgs>(
      args?: SelectSubset<T, qualificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Qualification.
     * @param {qualificationDeleteArgs} args - Arguments to delete one Qualification.
     * @example
     * // Delete one Qualification
     * const Qualification = await prisma.qualification.delete({
     *   where: {
     *     // ... filter to delete one Qualification
     *   }
     * })
     * 
    **/
    delete<T extends qualificationDeleteArgs>(
      args: SelectSubset<T, qualificationDeleteArgs>
    ): CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>>

    /**
     * Update one Qualification.
     * @param {qualificationUpdateArgs} args - Arguments to update one Qualification.
     * @example
     * // Update one Qualification
     * const qualification = await prisma.qualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qualificationUpdateArgs>(
      args: SelectSubset<T, qualificationUpdateArgs>
    ): CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>>

    /**
     * Delete zero or more Qualifications.
     * @param {qualificationDeleteManyArgs} args - Arguments to filter Qualifications to delete.
     * @example
     * // Delete a few Qualifications
     * const { count } = await prisma.qualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qualificationDeleteManyArgs>(
      args?: SelectSubset<T, qualificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualifications
     * const qualification = await prisma.qualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qualificationUpdateManyArgs>(
      args: SelectSubset<T, qualificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Qualification.
     * @param {qualificationUpsertArgs} args - Arguments to update or create a Qualification.
     * @example
     * // Update or create a Qualification
     * const qualification = await prisma.qualification.upsert({
     *   create: {
     *     // ... data to create a Qualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualification we want to update
     *   }
     * })
    **/
    upsert<T extends qualificationUpsertArgs>(
      args: SelectSubset<T, qualificationUpsertArgs>
    ): CheckSelect<T, Prisma__qualificationClient<qualification>, Prisma__qualificationClient<qualificationGetPayload<T>>>

    /**
     * Count the number of Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationCountArgs} args - Arguments to filter Qualifications to count.
     * @example
     * // Count the number of Qualifications
     * const count = await prisma.qualification.count({
     *   where: {
     *     // ... the filter for the Qualifications we want to count
     *   }
     * })
    **/
    count<T extends qualificationCountArgs>(
      args?: Subset<T, qualificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualificationAggregateArgs>(args: Subset<T, QualificationAggregateArgs>): PrismaPromise<GetQualificationAggregateType<T>>

    /**
     * Group by Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualificationGroupByArgs['orderBy'] }
        : { orderBy?: QualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for qualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__qualificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workerreview<T extends workerreviewArgs = {}>(args?: Subset<T, workerreviewArgs>): CheckSelect<T, Prisma__workerreviewClient<workerreview | null >, Prisma__workerreviewClient<workerreviewGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * qualification findUnique
   */
  export type qualificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * Throw an Error if a qualification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which qualification to fetch.
     * 
    **/
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification findFirst
   */
  export type qualificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * Throw an Error if a qualification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which qualification to fetch.
     * 
    **/
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualifications.
     * 
    **/
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualifications.
     * 
    **/
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }


  /**
   * qualification findMany
   */
  export type qualificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * Filter, which qualifications to fetch.
     * 
    **/
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     * 
    **/
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qualifications.
     * 
    **/
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }


  /**
   * qualification create
   */
  export type qualificationCreateArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * The data needed to create a qualification.
     * 
    **/
    data: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
  }


  /**
   * qualification createMany
   */
  export type qualificationCreateManyArgs = {
    /**
     * The data used to create many qualifications.
     * 
    **/
    data: Enumerable<qualificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * qualification update
   */
  export type qualificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * The data needed to update a qualification.
     * 
    **/
    data: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
    /**
     * Choose, which qualification to update.
     * 
    **/
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification updateMany
   */
  export type qualificationUpdateManyArgs = {
    /**
     * The data used to update qualifications.
     * 
    **/
    data: XOR<qualificationUpdateManyMutationInput, qualificationUncheckedUpdateManyInput>
    /**
     * Filter which qualifications to update
     * 
    **/
    where?: qualificationWhereInput
  }


  /**
   * qualification upsert
   */
  export type qualificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * The filter to search for the qualification to update in case it exists.
     * 
    **/
    where: qualificationWhereUniqueInput
    /**
     * In case the qualification found by the `where` argument doesn't exist, create a new qualification with this data.
     * 
    **/
    create: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
    /**
     * In case the qualification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
  }


  /**
   * qualification delete
   */
  export type qualificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
    /**
     * Filter which qualification to delete.
     * 
    **/
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification deleteMany
   */
  export type qualificationDeleteManyArgs = {
    /**
     * Filter which qualifications to delete
     * 
    **/
    where?: qualificationWhereInput
  }


  /**
   * qualification without action
   */
  export type qualificationArgs = {
    /**
     * Select specific fields to fetch from the qualification
     * 
    **/
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: qualificationInclude | null
  }



  /**
   * Model review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    idReview: number | null
    idProduct: number | null
    score: number | null
    idClientUser: number | null
  }

  export type ReviewSumAggregateOutputType = {
    idReview: number | null
    idProduct: number | null
    score: number | null
    idClientUser: number | null
  }

  export type ReviewMinAggregateOutputType = {
    idReview: number | null
    idProduct: number | null
    score: number | null
    revDescription: string | null
    idClientUser: number | null
    revDate: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    idReview: number | null
    idProduct: number | null
    score: number | null
    revDescription: string | null
    idClientUser: number | null
    revDate: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    idReview: number
    idProduct: number
    score: number
    revDescription: number
    idClientUser: number
    revDate: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    idReview?: true
    idProduct?: true
    score?: true
    idClientUser?: true
  }

  export type ReviewSumAggregateInputType = {
    idReview?: true
    idProduct?: true
    score?: true
    idClientUser?: true
  }

  export type ReviewMinAggregateInputType = {
    idReview?: true
    idProduct?: true
    score?: true
    revDescription?: true
    idClientUser?: true
    revDate?: true
  }

  export type ReviewMaxAggregateInputType = {
    idReview?: true
    idProduct?: true
    score?: true
    revDescription?: true
    idClientUser?: true
    revDate?: true
  }

  export type ReviewCountAggregateInputType = {
    idReview?: true
    idProduct?: true
    score?: true
    revDescription?: true
    idClientUser?: true
    revDate?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which review to aggregate.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: reviewWhereInput
    orderBy?: Enumerable<reviewOrderByWithAggregationInput>
    by: Array<ReviewScalarFieldEnum>
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    idReview: number
    idProduct: number
    score: number
    revDescription: string
    idClientUser: number
    revDate: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type reviewSelect = {
    idReview?: boolean
    idProduct?: boolean
    score?: boolean
    revDescription?: boolean
    idClientUser?: boolean
    revDate?: boolean
    clientuser?: boolean | clientuserArgs
    product?: boolean | productArgs
  }

  export type reviewInclude = {
    clientuser?: boolean | clientuserArgs
    product?: boolean | productArgs
  }

  export type reviewGetPayload<
    S extends boolean | null | undefined | reviewArgs,
    U = keyof S
      > = S extends true
        ? review
    : S extends undefined
    ? never
    : S extends reviewArgs | reviewFindManyArgs
    ?'include' extends U
    ? review  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['include'][P]> :
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['select'][P]> :
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof review ? review[P] : never
  } 
    : review
  : review


  type reviewCountArgs = Merge<
    Omit<reviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface reviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `idReview`
     * const reviewWithIdReviewOnly = await prisma.review.findMany({ select: { idReview: true } })
     * 
    **/
    findMany<T extends reviewFindManyArgs>(
      args?: SelectSubset<T, reviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends reviewCreateArgs>(
      args: SelectSubset<T, reviewCreateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reviewCreateManyArgs>(
      args?: SelectSubset<T, reviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends reviewDeleteArgs>(
      args: SelectSubset<T, reviewDeleteArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewUpdateArgs>(
      args: SelectSubset<T, reviewUpdateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewDeleteManyArgs>(
      args?: SelectSubset<T, reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewUpdateManyArgs>(
      args: SelectSubset<T, reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends reviewUpsertArgs>(
      args: SelectSubset<T, reviewUpsertArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientuser<T extends clientuserArgs = {}>(args?: Subset<T, clientuserArgs>): CheckSelect<T, Prisma__clientuserClient<clientuser | null >, Prisma__clientuserClient<clientuserGetPayload<T> | null >>;

    product<T extends productArgs = {}>(args?: Subset<T, productArgs>): CheckSelect<T, Prisma__productClient<product | null >, Prisma__productClient<productGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * review findUnique
   */
  export type reviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review findFirst
   */
  export type reviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review findMany
   */
  export type reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which reviews to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review create
   */
  export type reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to create a review.
     * 
    **/
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }


  /**
   * review createMany
   */
  export type reviewCreateManyArgs = {
    /**
     * The data used to create many reviews.
     * 
    **/
    data: Enumerable<reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * review update
   */
  export type reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to update a review.
     * 
    **/
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs = {
    /**
     * The data used to update reviews.
     * 
    **/
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review upsert
   */
  export type reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The filter to search for the review to update in case it exists.
     * 
    **/
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     * 
    **/
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }


  /**
   * review delete
   */
  export type reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter which review to delete.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs = {
    /**
     * Filter which reviews to delete
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review without action
   */
  export type reviewArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
  }



  /**
   * Model supplier
   */


  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    idSupplier: number | null
  }

  export type SupplierSumAggregateOutputType = {
    idSupplier: number | null
  }

  export type SupplierMinAggregateOutputType = {
    idSupplier: number | null
    supplierName: string | null
    isActive: boolean | null
  }

  export type SupplierMaxAggregateOutputType = {
    idSupplier: number | null
    supplierName: string | null
    isActive: boolean | null
  }

  export type SupplierCountAggregateOutputType = {
    idSupplier: number
    supplierName: number
    isActive: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    idSupplier?: true
  }

  export type SupplierSumAggregateInputType = {
    idSupplier?: true
  }

  export type SupplierMinAggregateInputType = {
    idSupplier?: true
    supplierName?: true
    isActive?: true
  }

  export type SupplierMaxAggregateInputType = {
    idSupplier?: true
    supplierName?: true
    isActive?: true
  }

  export type SupplierCountAggregateInputType = {
    idSupplier?: true
    supplierName?: true
    isActive?: true
    _all?: true
  }

  export type SupplierAggregateArgs = {
    /**
     * Filter which supplier to aggregate.
     * 
    **/
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<supplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs = {
    where?: supplierWhereInput
    orderBy?: Enumerable<supplierOrderByWithAggregationInput>
    by: Array<SupplierScalarFieldEnum>
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }


  export type SupplierGroupByOutputType = {
    idSupplier: number
    supplierName: string
    isActive: boolean
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect = {
    idSupplier?: boolean
    supplierName?: boolean
    isActive?: boolean
    product?: boolean | productFindManyArgs
    _count?: boolean | SupplierCountOutputTypeArgs
  }

  export type supplierInclude = {
    product?: boolean | productFindManyArgs
    _count?: boolean | SupplierCountOutputTypeArgs
  }

  export type supplierGetPayload<
    S extends boolean | null | undefined | supplierArgs,
    U = keyof S
      > = S extends true
        ? supplier
    : S extends undefined
    ? never
    : S extends supplierArgs | supplierFindManyArgs
    ?'include' extends U
    ? supplier  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? SupplierCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? SupplierCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof supplier ? supplier[P] : never
  } 
    : supplier
  : supplier


  type supplierCountArgs = Merge<
    Omit<supplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }
  >

  export interface supplierDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supplierFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, supplierFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'supplier'> extends True ? CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>> : CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supplierFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, supplierFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'supplier'> extends True ? CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>> : CheckSelect<T, Prisma__supplierClient<supplier | null >, Prisma__supplierClient<supplierGetPayload<T> | null >>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `idSupplier`
     * const supplierWithIdSupplierOnly = await prisma.supplier.findMany({ select: { idSupplier: true } })
     * 
    **/
    findMany<T extends supplierFindManyArgs>(
      args?: SelectSubset<T, supplierFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<supplier>>, PrismaPromise<Array<supplierGetPayload<T>>>>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends supplierCreateArgs>(
      args: SelectSubset<T, supplierCreateArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Create many Suppliers.
     *     @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends supplierCreateManyArgs>(
      args?: SelectSubset<T, supplierCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends supplierDeleteArgs>(
      args: SelectSubset<T, supplierDeleteArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supplierUpdateArgs>(
      args: SelectSubset<T, supplierUpdateArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supplierDeleteManyArgs>(
      args?: SelectSubset<T, supplierDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supplierUpdateManyArgs>(
      args: SelectSubset<T, supplierUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends supplierUpsertArgs>(
      args: SelectSubset<T, supplierUpsertArgs>
    ): CheckSelect<T, Prisma__supplierClient<supplier>, Prisma__supplierClient<supplierGetPayload<T>>>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__supplierClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends productFindManyArgs = {}>(args?: Subset<T, productFindManyArgs>): CheckSelect<T, PrismaPromise<Array<product>>, PrismaPromise<Array<productGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * Throw an Error if a supplier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which supplier to fetch.
     * 
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * Throw an Error if a supplier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which supplier to fetch.
     * 
    **/
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<supplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     * 
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     * 
    **/
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * supplier findMany
   */
  export type supplierFindManyArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * Filter, which suppliers to fetch.
     * 
    **/
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<supplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     * 
    **/
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * supplier create
   */
  export type supplierCreateArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * The data needed to create a supplier.
     * 
    **/
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }


  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs = {
    /**
     * The data used to create many suppliers.
     * 
    **/
    data: Enumerable<supplierCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * supplier update
   */
  export type supplierUpdateArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * The data needed to update a supplier.
     * 
    **/
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     * 
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs = {
    /**
     * The data used to update suppliers.
     * 
    **/
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     * 
    **/
    where?: supplierWhereInput
  }


  /**
   * supplier upsert
   */
  export type supplierUpsertArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * The filter to search for the supplier to update in case it exists.
     * 
    **/
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     * 
    **/
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }


  /**
   * supplier delete
   */
  export type supplierDeleteArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
    /**
     * Filter which supplier to delete.
     * 
    **/
    where: supplierWhereUniqueInput
  }


  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs = {
    /**
     * Filter which suppliers to delete
     * 
    **/
    where?: supplierWhereInput
  }


  /**
   * supplier without action
   */
  export type supplierArgs = {
    /**
     * Select specific fields to fetch from the supplier
     * 
    **/
    select?: supplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: supplierInclude | null
  }



  /**
   * Model workerreview
   */


  export type AggregateWorkerreview = {
    _count: WorkerreviewCountAggregateOutputType | null
    _avg: WorkerreviewAvgAggregateOutputType | null
    _sum: WorkerreviewSumAggregateOutputType | null
    _min: WorkerreviewMinAggregateOutputType | null
    _max: WorkerreviewMaxAggregateOutputType | null
  }

  export type WorkerreviewAvgAggregateOutputType = {
    idWorkerReview: number | null
    idClientUser: number | null
    idWorker: number | null
  }

  export type WorkerreviewSumAggregateOutputType = {
    idWorkerReview: number | null
    idClientUser: number | null
    idWorker: number | null
  }

  export type WorkerreviewMinAggregateOutputType = {
    idWorkerReview: number | null
    idClientUser: number | null
    idWorker: number | null
    dateWR: Date | null
  }

  export type WorkerreviewMaxAggregateOutputType = {
    idWorkerReview: number | null
    idClientUser: number | null
    idWorker: number | null
    dateWR: Date | null
  }

  export type WorkerreviewCountAggregateOutputType = {
    idWorkerReview: number
    idClientUser: number
    idWorker: number
    dateWR: number
    _all: number
  }


  export type WorkerreviewAvgAggregateInputType = {
    idWorkerReview?: true
    idClientUser?: true
    idWorker?: true
  }

  export type WorkerreviewSumAggregateInputType = {
    idWorkerReview?: true
    idClientUser?: true
    idWorker?: true
  }

  export type WorkerreviewMinAggregateInputType = {
    idWorkerReview?: true
    idClientUser?: true
    idWorker?: true
    dateWR?: true
  }

  export type WorkerreviewMaxAggregateInputType = {
    idWorkerReview?: true
    idClientUser?: true
    idWorker?: true
    dateWR?: true
  }

  export type WorkerreviewCountAggregateInputType = {
    idWorkerReview?: true
    idClientUser?: true
    idWorker?: true
    dateWR?: true
    _all?: true
  }

  export type WorkerreviewAggregateArgs = {
    /**
     * Filter which workerreview to aggregate.
     * 
    **/
    where?: workerreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workerreviews to fetch.
     * 
    **/
    orderBy?: Enumerable<workerreviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: workerreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workerreviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workerreviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workerreviews
    **/
    _count?: true | WorkerreviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerreviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerreviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerreviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerreviewMaxAggregateInputType
  }

  export type GetWorkerreviewAggregateType<T extends WorkerreviewAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerreview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerreview[P]>
      : GetScalarType<T[P], AggregateWorkerreview[P]>
  }




  export type WorkerreviewGroupByArgs = {
    where?: workerreviewWhereInput
    orderBy?: Enumerable<workerreviewOrderByWithAggregationInput>
    by: Array<WorkerreviewScalarFieldEnum>
    having?: workerreviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerreviewCountAggregateInputType | true
    _avg?: WorkerreviewAvgAggregateInputType
    _sum?: WorkerreviewSumAggregateInputType
    _min?: WorkerreviewMinAggregateInputType
    _max?: WorkerreviewMaxAggregateInputType
  }


  export type WorkerreviewGroupByOutputType = {
    idWorkerReview: number
    idClientUser: number
    idWorker: number
    dateWR: Date
    _count: WorkerreviewCountAggregateOutputType | null
    _avg: WorkerreviewAvgAggregateOutputType | null
    _sum: WorkerreviewSumAggregateOutputType | null
    _min: WorkerreviewMinAggregateOutputType | null
    _max: WorkerreviewMaxAggregateOutputType | null
  }

  type GetWorkerreviewGroupByPayload<T extends WorkerreviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WorkerreviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerreviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerreviewGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerreviewGroupByOutputType[P]>
        }
      >
    >


  export type workerreviewSelect = {
    idWorkerReview?: boolean
    idClientUser?: boolean
    idWorker?: boolean
    dateWR?: boolean
    clientuser?: boolean | clientuserArgs
    complaint?: boolean | complaintFindManyArgs
    qualification?: boolean | qualificationFindManyArgs
    _count?: boolean | WorkerreviewCountOutputTypeArgs
  }

  export type workerreviewInclude = {
    clientuser?: boolean | clientuserArgs
    complaint?: boolean | complaintFindManyArgs
    qualification?: boolean | qualificationFindManyArgs
    _count?: boolean | WorkerreviewCountOutputTypeArgs
  }

  export type workerreviewGetPayload<
    S extends boolean | null | undefined | workerreviewArgs,
    U = keyof S
      > = S extends true
        ? workerreview
    : S extends undefined
    ? never
    : S extends workerreviewArgs | workerreviewFindManyArgs
    ?'include' extends U
    ? workerreview  & {
    [P in TrueKeys<S['include']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['include'][P]> :
        P extends 'complaint' ? Array < complaintGetPayload<S['include'][P]>>  :
        P extends 'qualification' ? Array < qualificationGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkerreviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'clientuser' ? clientuserGetPayload<S['select'][P]> :
        P extends 'complaint' ? Array < complaintGetPayload<S['select'][P]>>  :
        P extends 'qualification' ? Array < qualificationGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkerreviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof workerreview ? workerreview[P] : never
  } 
    : workerreview
  : workerreview


  type workerreviewCountArgs = Merge<
    Omit<workerreviewFindManyArgs, 'select' | 'include'> & {
      select?: WorkerreviewCountAggregateInputType | true
    }
  >

  export interface workerreviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Workerreview that matches the filter.
     * @param {workerreviewFindUniqueArgs} args - Arguments to find a Workerreview
     * @example
     * // Get one Workerreview
     * const workerreview = await prisma.workerreview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends workerreviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, workerreviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'workerreview'> extends True ? CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>> : CheckSelect<T, Prisma__workerreviewClient<workerreview | null >, Prisma__workerreviewClient<workerreviewGetPayload<T> | null >>

    /**
     * Find the first Workerreview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerreviewFindFirstArgs} args - Arguments to find a Workerreview
     * @example
     * // Get one Workerreview
     * const workerreview = await prisma.workerreview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends workerreviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, workerreviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'workerreview'> extends True ? CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>> : CheckSelect<T, Prisma__workerreviewClient<workerreview | null >, Prisma__workerreviewClient<workerreviewGetPayload<T> | null >>

    /**
     * Find zero or more Workerreviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerreviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workerreviews
     * const workerreviews = await prisma.workerreview.findMany()
     * 
     * // Get first 10 Workerreviews
     * const workerreviews = await prisma.workerreview.findMany({ take: 10 })
     * 
     * // Only select the `idWorkerReview`
     * const workerreviewWithIdWorkerReviewOnly = await prisma.workerreview.findMany({ select: { idWorkerReview: true } })
     * 
    **/
    findMany<T extends workerreviewFindManyArgs>(
      args?: SelectSubset<T, workerreviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<workerreview>>, PrismaPromise<Array<workerreviewGetPayload<T>>>>

    /**
     * Create a Workerreview.
     * @param {workerreviewCreateArgs} args - Arguments to create a Workerreview.
     * @example
     * // Create one Workerreview
     * const Workerreview = await prisma.workerreview.create({
     *   data: {
     *     // ... data to create a Workerreview
     *   }
     * })
     * 
    **/
    create<T extends workerreviewCreateArgs>(
      args: SelectSubset<T, workerreviewCreateArgs>
    ): CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>>

    /**
     * Create many Workerreviews.
     *     @param {workerreviewCreateManyArgs} args - Arguments to create many Workerreviews.
     *     @example
     *     // Create many Workerreviews
     *     const workerreview = await prisma.workerreview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends workerreviewCreateManyArgs>(
      args?: SelectSubset<T, workerreviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Workerreview.
     * @param {workerreviewDeleteArgs} args - Arguments to delete one Workerreview.
     * @example
     * // Delete one Workerreview
     * const Workerreview = await prisma.workerreview.delete({
     *   where: {
     *     // ... filter to delete one Workerreview
     *   }
     * })
     * 
    **/
    delete<T extends workerreviewDeleteArgs>(
      args: SelectSubset<T, workerreviewDeleteArgs>
    ): CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>>

    /**
     * Update one Workerreview.
     * @param {workerreviewUpdateArgs} args - Arguments to update one Workerreview.
     * @example
     * // Update one Workerreview
     * const workerreview = await prisma.workerreview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends workerreviewUpdateArgs>(
      args: SelectSubset<T, workerreviewUpdateArgs>
    ): CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>>

    /**
     * Delete zero or more Workerreviews.
     * @param {workerreviewDeleteManyArgs} args - Arguments to filter Workerreviews to delete.
     * @example
     * // Delete a few Workerreviews
     * const { count } = await prisma.workerreview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends workerreviewDeleteManyArgs>(
      args?: SelectSubset<T, workerreviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workerreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerreviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workerreviews
     * const workerreview = await prisma.workerreview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends workerreviewUpdateManyArgs>(
      args: SelectSubset<T, workerreviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Workerreview.
     * @param {workerreviewUpsertArgs} args - Arguments to update or create a Workerreview.
     * @example
     * // Update or create a Workerreview
     * const workerreview = await prisma.workerreview.upsert({
     *   create: {
     *     // ... data to create a Workerreview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workerreview we want to update
     *   }
     * })
    **/
    upsert<T extends workerreviewUpsertArgs>(
      args: SelectSubset<T, workerreviewUpsertArgs>
    ): CheckSelect<T, Prisma__workerreviewClient<workerreview>, Prisma__workerreviewClient<workerreviewGetPayload<T>>>

    /**
     * Count the number of Workerreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workerreviewCountArgs} args - Arguments to filter Workerreviews to count.
     * @example
     * // Count the number of Workerreviews
     * const count = await prisma.workerreview.count({
     *   where: {
     *     // ... the filter for the Workerreviews we want to count
     *   }
     * })
    **/
    count<T extends workerreviewCountArgs>(
      args?: Subset<T, workerreviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerreviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workerreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerreviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerreviewAggregateArgs>(args: Subset<T, WorkerreviewAggregateArgs>): PrismaPromise<GetWorkerreviewAggregateType<T>>

    /**
     * Group by Workerreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerreviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerreviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerreviewGroupByArgs['orderBy'] }
        : { orderBy?: WorkerreviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerreviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerreviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for workerreview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__workerreviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clientuser<T extends clientuserArgs = {}>(args?: Subset<T, clientuserArgs>): CheckSelect<T, Prisma__clientuserClient<clientuser | null >, Prisma__clientuserClient<clientuserGetPayload<T> | null >>;

    complaint<T extends complaintFindManyArgs = {}>(args?: Subset<T, complaintFindManyArgs>): CheckSelect<T, PrismaPromise<Array<complaint>>, PrismaPromise<Array<complaintGetPayload<T>>>>;

    qualification<T extends qualificationFindManyArgs = {}>(args?: Subset<T, qualificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<qualification>>, PrismaPromise<Array<qualificationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * workerreview findUnique
   */
  export type workerreviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * Throw an Error if a workerreview can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which workerreview to fetch.
     * 
    **/
    where: workerreviewWhereUniqueInput
  }


  /**
   * workerreview findFirst
   */
  export type workerreviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * Throw an Error if a workerreview can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which workerreview to fetch.
     * 
    **/
    where?: workerreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workerreviews to fetch.
     * 
    **/
    orderBy?: Enumerable<workerreviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workerreviews.
     * 
    **/
    cursor?: workerreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workerreviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workerreviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workerreviews.
     * 
    **/
    distinct?: Enumerable<WorkerreviewScalarFieldEnum>
  }


  /**
   * workerreview findMany
   */
  export type workerreviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * Filter, which workerreviews to fetch.
     * 
    **/
    where?: workerreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workerreviews to fetch.
     * 
    **/
    orderBy?: Enumerable<workerreviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workerreviews.
     * 
    **/
    cursor?: workerreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workerreviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workerreviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkerreviewScalarFieldEnum>
  }


  /**
   * workerreview create
   */
  export type workerreviewCreateArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * The data needed to create a workerreview.
     * 
    **/
    data: XOR<workerreviewCreateInput, workerreviewUncheckedCreateInput>
  }


  /**
   * workerreview createMany
   */
  export type workerreviewCreateManyArgs = {
    /**
     * The data used to create many workerreviews.
     * 
    **/
    data: Enumerable<workerreviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * workerreview update
   */
  export type workerreviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * The data needed to update a workerreview.
     * 
    **/
    data: XOR<workerreviewUpdateInput, workerreviewUncheckedUpdateInput>
    /**
     * Choose, which workerreview to update.
     * 
    **/
    where: workerreviewWhereUniqueInput
  }


  /**
   * workerreview updateMany
   */
  export type workerreviewUpdateManyArgs = {
    /**
     * The data used to update workerreviews.
     * 
    **/
    data: XOR<workerreviewUpdateManyMutationInput, workerreviewUncheckedUpdateManyInput>
    /**
     * Filter which workerreviews to update
     * 
    **/
    where?: workerreviewWhereInput
  }


  /**
   * workerreview upsert
   */
  export type workerreviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * The filter to search for the workerreview to update in case it exists.
     * 
    **/
    where: workerreviewWhereUniqueInput
    /**
     * In case the workerreview found by the `where` argument doesn't exist, create a new workerreview with this data.
     * 
    **/
    create: XOR<workerreviewCreateInput, workerreviewUncheckedCreateInput>
    /**
     * In case the workerreview was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<workerreviewUpdateInput, workerreviewUncheckedUpdateInput>
  }


  /**
   * workerreview delete
   */
  export type workerreviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
    /**
     * Filter which workerreview to delete.
     * 
    **/
    where: workerreviewWhereUniqueInput
  }


  /**
   * workerreview deleteMany
   */
  export type workerreviewDeleteManyArgs = {
    /**
     * Filter which workerreviews to delete
     * 
    **/
    where?: workerreviewWhereInput
  }


  /**
   * workerreview without action
   */
  export type workerreviewArgs = {
    /**
     * Select specific fields to fetch from the workerreview
     * 
    **/
    select?: workerreviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: workerreviewInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CardScalarFieldEnum: {
    idCard: 'idCard',
    idInfoPeople: 'idInfoPeople',
    cardNumber: 'cardNumber',
    expirationDate: 'expirationDate',
    cvv: 'cvv'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const CashScalarFieldEnum: {
    idCash: 'idCash',
    cashType: 'cashType'
  };

  export type CashScalarFieldEnum = (typeof CashScalarFieldEnum)[keyof typeof CashScalarFieldEnum]


  export const ClientlocationScalarFieldEnum: {
    idClientLocation: 'idClientLocation',
    idClientPeople: 'idClientPeople',
    idLocation: 'idLocation'
  };

  export type ClientlocationScalarFieldEnum = (typeof ClientlocationScalarFieldEnum)[keyof typeof ClientlocationScalarFieldEnum]


  export const ClientmembershipScalarFieldEnum: {
    idClientMembership: 'idClientMembership',
    idMembership: 'idMembership',
    idClientPeople: 'idClientPeople'
  };

  export type ClientmembershipScalarFieldEnum = (typeof ClientmembershipScalarFieldEnum)[keyof typeof ClientmembershipScalarFieldEnum]


  export const ClientpeopleScalarFieldEnum: {
    idClientPeople: 'idClientPeople',
    idClientUser: 'idClientUser',
    idInfoPeople: 'idInfoPeople',
    salesCounter: 'salesCounter',
    isActive: 'isActive'
  };

  export type ClientpeopleScalarFieldEnum = (typeof ClientpeopleScalarFieldEnum)[keyof typeof ClientpeopleScalarFieldEnum]


  export const ClientuserScalarFieldEnum: {
    idClientUser: 'idClientUser',
    userPassword: 'userPassword',
    isActive: 'isActive'
  };

  export type ClientuserScalarFieldEnum = (typeof ClientuserScalarFieldEnum)[keyof typeof ClientuserScalarFieldEnum]


  export const ClubScalarFieldEnum: {
    idClub: 'idClub',
    clubName: 'clubName',
    idLocation: 'idLocation',
    deliveryCostProp: 'deliveryCostProp',
    idCash: 'idCash',
    isActive: 'isActive'
  };

  export type ClubScalarFieldEnum = (typeof ClubScalarFieldEnum)[keyof typeof ClubScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    idComplaint: 'idComplaint',
    idWorkerReview: 'idWorkerReview',
    compDescription: 'compDescription',
    solved: 'solved'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const InfopeopleScalarFieldEnum: {
    idInfoPeople: 'idInfoPeople',
    peopleName: 'peopleName',
    surname: 'surname',
    email: 'email',
    phoneNumber: 'phoneNumber',
    birthDate: 'birthDate',
    isActive: 'isActive'
  };

  export type InfopeopleScalarFieldEnum = (typeof InfopeopleScalarFieldEnum)[keyof typeof InfopeopleScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    idInventory: 'idInventory',
    idClub: 'idClub',
    idProduct: 'idProduct',
    stock: 'stock',
    isActive: 'isActive'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    idLocation: 'idLocation',
    typeLocation: 'typeLocation',
    isActive: 'isActive'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    idMembership: 'idMembership',
    nameMembership: 'nameMembership',
    cost: 'cost',
    productDiscount: 'productDiscount',
    deliveryDiscount: 'deliveryDiscount',
    isActive: 'isActive'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const OrderlineScalarFieldEnum: {
    idOrderLine: 'idOrderLine',
    idOrderP: 'idOrderP',
    idProduct: 'idProduct',
    cost: 'cost',
    amount: 'amount'
  };

  export type OrderlineScalarFieldEnum = (typeof OrderlineScalarFieldEnum)[keyof typeof OrderlineScalarFieldEnum]


  export const OrderpScalarFieldEnum: {
    idOrderP: 'idOrderP',
    idClientPeople: 'idClientPeople',
    orderDate: 'orderDate',
    idClub: 'idClub',
    idEmployer: 'idEmployer',
    idMailer: 'idMailer',
    deliveryCost: 'deliveryCost'
  };

  export type OrderpScalarFieldEnum = (typeof OrderpScalarFieldEnum)[keyof typeof OrderpScalarFieldEnum]


  export const PopularproductsScalarFieldEnum: {
    idPopularProducts: 'idPopularProducts',
    idProduct: 'idProduct',
    amount: 'amount',
    idClub: 'idClub'
  };

  export type PopularproductsScalarFieldEnum = (typeof PopularproductsScalarFieldEnum)[keyof typeof PopularproductsScalarFieldEnum]


  export const PresentationScalarFieldEnum: {
    idPresentation: 'idPresentation',
    idProduct: 'idProduct',
    amountBottles: 'amountBottles',
    sizeBottle: 'sizeBottle'
  };

  export type PresentationScalarFieldEnum = (typeof PresentationScalarFieldEnum)[keyof typeof PresentationScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    idProduct: 'idProduct',
    productName: 'productName',
    cost: 'cost',
    idProductType: 'idProductType',
    image: 'image',
    idSupplier: 'idSupplier',
    idCash: 'idCash',
    isActive: 'isActive',
    entryDate: 'entryDate',
    tier: 'tier',
    productDescr: 'productDescr'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProducttypeScalarFieldEnum: {
    idProductType: 'idProductType',
    typeName: 'typeName',
    isActive: 'isActive'
  };

  export type ProducttypeScalarFieldEnum = (typeof ProducttypeScalarFieldEnum)[keyof typeof ProducttypeScalarFieldEnum]


  export const QualificationScalarFieldEnum: {
    idQualification: 'idQualification',
    idWorkerReview: 'idWorkerReview',
    qualDescription: 'qualDescription'
  };

  export type QualificationScalarFieldEnum = (typeof QualificationScalarFieldEnum)[keyof typeof QualificationScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    idReview: 'idReview',
    idProduct: 'idProduct',
    score: 'score',
    revDescription: 'revDescription',
    idClientUser: 'idClientUser',
    revDate: 'revDate'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    idSupplier: 'idSupplier',
    supplierName: 'supplierName',
    isActive: 'isActive'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const WorkerreviewScalarFieldEnum: {
    idWorkerReview: 'idWorkerReview',
    idClientUser: 'idClientUser',
    idWorker: 'idWorker',
    dateWR: 'dateWR'
  };

  export type WorkerreviewScalarFieldEnum = (typeof WorkerreviewScalarFieldEnum)[keyof typeof WorkerreviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type cardWhereInput = {
    AND?: Enumerable<cardWhereInput>
    OR?: Enumerable<cardWhereInput>
    NOT?: Enumerable<cardWhereInput>
    idCard?: IntFilter | number
    idInfoPeople?: IntFilter | number
    cardNumber?: StringFilter | string
    expirationDate?: DateTimeFilter | Date | string
    cvv?: IntFilter | number
    infopeople?: XOR<InfopeopleRelationFilter, infopeopleWhereInput>
  }

  export type cardOrderByWithRelationInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cardNumber?: SortOrder
    expirationDate?: SortOrder
    cvv?: SortOrder
    infopeople?: infopeopleOrderByWithRelationInput
  }

  export type cardWhereUniqueInput = {
    idCard?: number
  }

  export type cardOrderByWithAggregationInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cardNumber?: SortOrder
    expirationDate?: SortOrder
    cvv?: SortOrder
    _count?: cardCountOrderByAggregateInput
    _avg?: cardAvgOrderByAggregateInput
    _max?: cardMaxOrderByAggregateInput
    _min?: cardMinOrderByAggregateInput
    _sum?: cardSumOrderByAggregateInput
  }

  export type cardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cardScalarWhereWithAggregatesInput>
    OR?: Enumerable<cardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cardScalarWhereWithAggregatesInput>
    idCard?: IntWithAggregatesFilter | number
    idInfoPeople?: IntWithAggregatesFilter | number
    cardNumber?: StringWithAggregatesFilter | string
    expirationDate?: DateTimeWithAggregatesFilter | Date | string
    cvv?: IntWithAggregatesFilter | number
  }

  export type cashWhereInput = {
    AND?: Enumerable<cashWhereInput>
    OR?: Enumerable<cashWhereInput>
    NOT?: Enumerable<cashWhereInput>
    idCash?: IntFilter | number
    cashType?: StringFilter | string
    club?: ClubListRelationFilter
    product?: ProductListRelationFilter
  }

  export type cashOrderByWithRelationInput = {
    idCash?: SortOrder
    cashType?: SortOrder
    club?: clubOrderByRelationAggregateInput
    product?: productOrderByRelationAggregateInput
  }

  export type cashWhereUniqueInput = {
    idCash?: number
  }

  export type cashOrderByWithAggregationInput = {
    idCash?: SortOrder
    cashType?: SortOrder
    _count?: cashCountOrderByAggregateInput
    _avg?: cashAvgOrderByAggregateInput
    _max?: cashMaxOrderByAggregateInput
    _min?: cashMinOrderByAggregateInput
    _sum?: cashSumOrderByAggregateInput
  }

  export type cashScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cashScalarWhereWithAggregatesInput>
    OR?: Enumerable<cashScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cashScalarWhereWithAggregatesInput>
    idCash?: IntWithAggregatesFilter | number
    cashType?: StringWithAggregatesFilter | string
  }

  export type clientlocationWhereInput = {
    AND?: Enumerable<clientlocationWhereInput>
    OR?: Enumerable<clientlocationWhereInput>
    NOT?: Enumerable<clientlocationWhereInput>
    idClientLocation?: IntFilter | number
    idClientPeople?: IntFilter | number
    idLocation?: IntFilter | number
    clientpeople?: XOR<ClientpeopleRelationFilter, clientpeopleWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
  }

  export type clientlocationOrderByWithRelationInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
    clientpeople?: clientpeopleOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
  }

  export type clientlocationWhereUniqueInput = {
    idClientLocation?: number
  }

  export type clientlocationOrderByWithAggregationInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
    _count?: clientlocationCountOrderByAggregateInput
    _avg?: clientlocationAvgOrderByAggregateInput
    _max?: clientlocationMaxOrderByAggregateInput
    _min?: clientlocationMinOrderByAggregateInput
    _sum?: clientlocationSumOrderByAggregateInput
  }

  export type clientlocationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientlocationScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientlocationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientlocationScalarWhereWithAggregatesInput>
    idClientLocation?: IntWithAggregatesFilter | number
    idClientPeople?: IntWithAggregatesFilter | number
    idLocation?: IntWithAggregatesFilter | number
  }

  export type clientmembershipWhereInput = {
    AND?: Enumerable<clientmembershipWhereInput>
    OR?: Enumerable<clientmembershipWhereInput>
    NOT?: Enumerable<clientmembershipWhereInput>
    idClientMembership?: IntFilter | number
    idMembership?: IntFilter | number
    idClientPeople?: IntFilter | number
    clientpeople?: XOR<ClientpeopleRelationFilter, clientpeopleWhereInput>
    membership?: XOR<MembershipRelationFilter, membershipWhereInput>
  }

  export type clientmembershipOrderByWithRelationInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
    clientpeople?: clientpeopleOrderByWithRelationInput
    membership?: membershipOrderByWithRelationInput
  }

  export type clientmembershipWhereUniqueInput = {
    idClientMembership?: number
  }

  export type clientmembershipOrderByWithAggregationInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
    _count?: clientmembershipCountOrderByAggregateInput
    _avg?: clientmembershipAvgOrderByAggregateInput
    _max?: clientmembershipMaxOrderByAggregateInput
    _min?: clientmembershipMinOrderByAggregateInput
    _sum?: clientmembershipSumOrderByAggregateInput
  }

  export type clientmembershipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientmembershipScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientmembershipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientmembershipScalarWhereWithAggregatesInput>
    idClientMembership?: IntWithAggregatesFilter | number
    idMembership?: IntWithAggregatesFilter | number
    idClientPeople?: IntWithAggregatesFilter | number
  }

  export type clientpeopleWhereInput = {
    AND?: Enumerable<clientpeopleWhereInput>
    OR?: Enumerable<clientpeopleWhereInput>
    NOT?: Enumerable<clientpeopleWhereInput>
    idClientPeople?: IntFilter | number
    idClientUser?: IntFilter | number
    idInfoPeople?: IntFilter | number
    salesCounter?: IntFilter | number
    isActive?: BoolFilter | boolean
    clientuser?: XOR<ClientuserRelationFilter, clientuserWhereInput>
    infopeople?: XOR<InfopeopleRelationFilter, infopeopleWhereInput>
    clientlocation?: ClientlocationListRelationFilter
    clientmembership?: ClientmembershipListRelationFilter
    orderp?: OrderpListRelationFilter
  }

  export type clientpeopleOrderByWithRelationInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
    isActive?: SortOrder
    clientuser?: clientuserOrderByWithRelationInput
    infopeople?: infopeopleOrderByWithRelationInput
    clientlocation?: clientlocationOrderByRelationAggregateInput
    clientmembership?: clientmembershipOrderByRelationAggregateInput
    orderp?: orderpOrderByRelationAggregateInput
  }

  export type clientpeopleWhereUniqueInput = {
    idClientPeople?: number
  }

  export type clientpeopleOrderByWithAggregationInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
    isActive?: SortOrder
    _count?: clientpeopleCountOrderByAggregateInput
    _avg?: clientpeopleAvgOrderByAggregateInput
    _max?: clientpeopleMaxOrderByAggregateInput
    _min?: clientpeopleMinOrderByAggregateInput
    _sum?: clientpeopleSumOrderByAggregateInput
  }

  export type clientpeopleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientpeopleScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientpeopleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientpeopleScalarWhereWithAggregatesInput>
    idClientPeople?: IntWithAggregatesFilter | number
    idClientUser?: IntWithAggregatesFilter | number
    idInfoPeople?: IntWithAggregatesFilter | number
    salesCounter?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type clientuserWhereInput = {
    AND?: Enumerable<clientuserWhereInput>
    OR?: Enumerable<clientuserWhereInput>
    NOT?: Enumerable<clientuserWhereInput>
    idClientUser?: IntFilter | number
    userPassword?: BytesFilter | Buffer
    isActive?: BoolFilter | boolean
    clientpeople?: ClientpeopleListRelationFilter
    review?: ReviewListRelationFilter
    workerreview?: WorkerreviewListRelationFilter
  }

  export type clientuserOrderByWithRelationInput = {
    idClientUser?: SortOrder
    userPassword?: SortOrder
    isActive?: SortOrder
    clientpeople?: clientpeopleOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    workerreview?: workerreviewOrderByRelationAggregateInput
  }

  export type clientuserWhereUniqueInput = {
    idClientUser?: number
  }

  export type clientuserOrderByWithAggregationInput = {
    idClientUser?: SortOrder
    userPassword?: SortOrder
    isActive?: SortOrder
    _count?: clientuserCountOrderByAggregateInput
    _avg?: clientuserAvgOrderByAggregateInput
    _max?: clientuserMaxOrderByAggregateInput
    _min?: clientuserMinOrderByAggregateInput
    _sum?: clientuserSumOrderByAggregateInput
  }

  export type clientuserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clientuserScalarWhereWithAggregatesInput>
    OR?: Enumerable<clientuserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clientuserScalarWhereWithAggregatesInput>
    idClientUser?: IntWithAggregatesFilter | number
    userPassword?: BytesWithAggregatesFilter | Buffer
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type clubWhereInput = {
    AND?: Enumerable<clubWhereInput>
    OR?: Enumerable<clubWhereInput>
    NOT?: Enumerable<clubWhereInput>
    idClub?: IntFilter | number
    clubName?: StringFilter | string
    idLocation?: IntFilter | number
    deliveryCostProp?: FloatFilter | number
    idCash?: IntFilter | number
    isActive?: BoolFilter | boolean
    cash?: XOR<CashRelationFilter, cashWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    inventory?: InventoryListRelationFilter
    orderp?: OrderpListRelationFilter
    popularproducts?: PopularproductsListRelationFilter
  }

  export type clubOrderByWithRelationInput = {
    idClub?: SortOrder
    clubName?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    cash?: cashOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
    inventory?: inventoryOrderByRelationAggregateInput
    orderp?: orderpOrderByRelationAggregateInput
    popularproducts?: popularproductsOrderByRelationAggregateInput
  }

  export type clubWhereUniqueInput = {
    idClub?: number
  }

  export type clubOrderByWithAggregationInput = {
    idClub?: SortOrder
    clubName?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    _count?: clubCountOrderByAggregateInput
    _avg?: clubAvgOrderByAggregateInput
    _max?: clubMaxOrderByAggregateInput
    _min?: clubMinOrderByAggregateInput
    _sum?: clubSumOrderByAggregateInput
  }

  export type clubScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clubScalarWhereWithAggregatesInput>
    OR?: Enumerable<clubScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clubScalarWhereWithAggregatesInput>
    idClub?: IntWithAggregatesFilter | number
    clubName?: StringWithAggregatesFilter | string
    idLocation?: IntWithAggregatesFilter | number
    deliveryCostProp?: FloatWithAggregatesFilter | number
    idCash?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type complaintWhereInput = {
    AND?: Enumerable<complaintWhereInput>
    OR?: Enumerable<complaintWhereInput>
    NOT?: Enumerable<complaintWhereInput>
    idComplaint?: IntFilter | number
    idWorkerReview?: IntFilter | number
    compDescription?: StringFilter | string
    solved?: BoolFilter | boolean
    workerreview?: XOR<WorkerreviewRelationFilter, workerreviewWhereInput>
  }

  export type complaintOrderByWithRelationInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
    compDescription?: SortOrder
    solved?: SortOrder
    workerreview?: workerreviewOrderByWithRelationInput
  }

  export type complaintWhereUniqueInput = {
    idComplaint?: number
  }

  export type complaintOrderByWithAggregationInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
    compDescription?: SortOrder
    solved?: SortOrder
    _count?: complaintCountOrderByAggregateInput
    _avg?: complaintAvgOrderByAggregateInput
    _max?: complaintMaxOrderByAggregateInput
    _min?: complaintMinOrderByAggregateInput
    _sum?: complaintSumOrderByAggregateInput
  }

  export type complaintScalarWhereWithAggregatesInput = {
    AND?: Enumerable<complaintScalarWhereWithAggregatesInput>
    OR?: Enumerable<complaintScalarWhereWithAggregatesInput>
    NOT?: Enumerable<complaintScalarWhereWithAggregatesInput>
    idComplaint?: IntWithAggregatesFilter | number
    idWorkerReview?: IntWithAggregatesFilter | number
    compDescription?: StringWithAggregatesFilter | string
    solved?: BoolWithAggregatesFilter | boolean
  }

  export type infopeopleWhereInput = {
    AND?: Enumerable<infopeopleWhereInput>
    OR?: Enumerable<infopeopleWhereInput>
    NOT?: Enumerable<infopeopleWhereInput>
    idInfoPeople?: IntFilter | number
    peopleName?: StringFilter | string
    surname?: StringFilter | string
    email?: StringFilter | string
    phoneNumber?: IntFilter | number
    birthDate?: DateTimeFilter | Date | string
    isActive?: BoolFilter | boolean
    card?: CardListRelationFilter
    clientpeople?: ClientpeopleListRelationFilter
  }

  export type infopeopleOrderByWithRelationInput = {
    idInfoPeople?: SortOrder
    peopleName?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    card?: cardOrderByRelationAggregateInput
    clientpeople?: clientpeopleOrderByRelationAggregateInput
  }

  export type infopeopleWhereUniqueInput = {
    idInfoPeople?: number
  }

  export type infopeopleOrderByWithAggregationInput = {
    idInfoPeople?: SortOrder
    peopleName?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    _count?: infopeopleCountOrderByAggregateInput
    _avg?: infopeopleAvgOrderByAggregateInput
    _max?: infopeopleMaxOrderByAggregateInput
    _min?: infopeopleMinOrderByAggregateInput
    _sum?: infopeopleSumOrderByAggregateInput
  }

  export type infopeopleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<infopeopleScalarWhereWithAggregatesInput>
    OR?: Enumerable<infopeopleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<infopeopleScalarWhereWithAggregatesInput>
    idInfoPeople?: IntWithAggregatesFilter | number
    peopleName?: StringWithAggregatesFilter | string
    surname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phoneNumber?: IntWithAggregatesFilter | number
    birthDate?: DateTimeWithAggregatesFilter | Date | string
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type inventoryWhereInput = {
    AND?: Enumerable<inventoryWhereInput>
    OR?: Enumerable<inventoryWhereInput>
    NOT?: Enumerable<inventoryWhereInput>
    idInventory?: IntFilter | number
    idClub?: IntFilter | number
    idProduct?: IntFilter | number
    stock?: IntFilter | number
    isActive?: BoolFilter | boolean
    club?: XOR<ClubRelationFilter, clubWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type inventoryOrderByWithRelationInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    club?: clubOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type inventoryWhereUniqueInput = {
    idInventory?: number
  }

  export type inventoryOrderByWithAggregationInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    _count?: inventoryCountOrderByAggregateInput
    _avg?: inventoryAvgOrderByAggregateInput
    _max?: inventoryMaxOrderByAggregateInput
    _min?: inventoryMinOrderByAggregateInput
    _sum?: inventorySumOrderByAggregateInput
  }

  export type inventoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inventoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<inventoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inventoryScalarWhereWithAggregatesInput>
    idInventory?: IntWithAggregatesFilter | number
    idClub?: IntWithAggregatesFilter | number
    idProduct?: IntWithAggregatesFilter | number
    stock?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type locationWhereInput = {
    AND?: Enumerable<locationWhereInput>
    OR?: Enumerable<locationWhereInput>
    NOT?: Enumerable<locationWhereInput>
    idLocation?: IntFilter | number
    typeLocation?: BoolNullableFilter | boolean | null
    isActive?: BoolFilter | boolean
    clientlocation?: ClientlocationListRelationFilter
    club?: ClubListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    idLocation?: SortOrder
    typeLocation?: SortOrder
    isActive?: SortOrder
    clientlocation?: clientlocationOrderByRelationAggregateInput
    club?: clubOrderByRelationAggregateInput
  }

  export type locationWhereUniqueInput = {
    idLocation?: number
  }

  export type locationOrderByWithAggregationInput = {
    idLocation?: SortOrder
    typeLocation?: SortOrder
    isActive?: SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationScalarWhereWithAggregatesInput>
    idLocation?: IntWithAggregatesFilter | number
    typeLocation?: BoolNullableWithAggregatesFilter | boolean | null
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type membershipWhereInput = {
    AND?: Enumerable<membershipWhereInput>
    OR?: Enumerable<membershipWhereInput>
    NOT?: Enumerable<membershipWhereInput>
    idMembership?: IntFilter | number
    nameMembership?: StringFilter | string
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFilter | number
    deliveryDiscount?: FloatFilter | number
    isActive?: BoolFilter | boolean
    clientmembership?: ClientmembershipListRelationFilter
  }

  export type membershipOrderByWithRelationInput = {
    idMembership?: SortOrder
    nameMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    isActive?: SortOrder
    clientmembership?: clientmembershipOrderByRelationAggregateInput
  }

  export type membershipWhereUniqueInput = {
    idMembership?: number
  }

  export type membershipOrderByWithAggregationInput = {
    idMembership?: SortOrder
    nameMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    isActive?: SortOrder
    _count?: membershipCountOrderByAggregateInput
    _avg?: membershipAvgOrderByAggregateInput
    _max?: membershipMaxOrderByAggregateInput
    _min?: membershipMinOrderByAggregateInput
    _sum?: membershipSumOrderByAggregateInput
  }

  export type membershipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<membershipScalarWhereWithAggregatesInput>
    OR?: Enumerable<membershipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<membershipScalarWhereWithAggregatesInput>
    idMembership?: IntWithAggregatesFilter | number
    nameMembership?: StringWithAggregatesFilter | string
    cost?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatWithAggregatesFilter | number
    deliveryDiscount?: FloatWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type orderlineWhereInput = {
    AND?: Enumerable<orderlineWhereInput>
    OR?: Enumerable<orderlineWhereInput>
    NOT?: Enumerable<orderlineWhereInput>
    idOrderLine?: IntFilter | number
    idOrderP?: IntFilter | number
    idProduct?: IntFilter | number
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    amount?: IntFilter | number
    orderp?: XOR<OrderpRelationFilter, orderpWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type orderlineOrderByWithRelationInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
    orderp?: orderpOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type orderlineWhereUniqueInput = {
    idOrderLine?: number
  }

  export type orderlineOrderByWithAggregationInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
    _count?: orderlineCountOrderByAggregateInput
    _avg?: orderlineAvgOrderByAggregateInput
    _max?: orderlineMaxOrderByAggregateInput
    _min?: orderlineMinOrderByAggregateInput
    _sum?: orderlineSumOrderByAggregateInput
  }

  export type orderlineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<orderlineScalarWhereWithAggregatesInput>
    OR?: Enumerable<orderlineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<orderlineScalarWhereWithAggregatesInput>
    idOrderLine?: IntWithAggregatesFilter | number
    idOrderP?: IntWithAggregatesFilter | number
    idProduct?: IntWithAggregatesFilter | number
    cost?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    amount?: IntWithAggregatesFilter | number
  }

  export type orderpWhereInput = {
    AND?: Enumerable<orderpWhereInput>
    OR?: Enumerable<orderpWhereInput>
    NOT?: Enumerable<orderpWhereInput>
    idOrderP?: IntFilter | number
    idClientPeople?: IntFilter | number
    orderDate?: DateTimeFilter | Date | string
    idClub?: IntFilter | number
    idEmployer?: IntFilter | number
    idMailer?: IntFilter | number
    deliveryCost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    clientpeople?: XOR<ClientpeopleRelationFilter, clientpeopleWhereInput>
    club?: XOR<ClubRelationFilter, clubWhereInput>
    orderline?: OrderlineListRelationFilter
  }

  export type orderpOrderByWithRelationInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    orderDate?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
    clientpeople?: clientpeopleOrderByWithRelationInput
    club?: clubOrderByWithRelationInput
    orderline?: orderlineOrderByRelationAggregateInput
  }

  export type orderpWhereUniqueInput = {
    idOrderP?: number
  }

  export type orderpOrderByWithAggregationInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    orderDate?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
    _count?: orderpCountOrderByAggregateInput
    _avg?: orderpAvgOrderByAggregateInput
    _max?: orderpMaxOrderByAggregateInput
    _min?: orderpMinOrderByAggregateInput
    _sum?: orderpSumOrderByAggregateInput
  }

  export type orderpScalarWhereWithAggregatesInput = {
    AND?: Enumerable<orderpScalarWhereWithAggregatesInput>
    OR?: Enumerable<orderpScalarWhereWithAggregatesInput>
    NOT?: Enumerable<orderpScalarWhereWithAggregatesInput>
    idOrderP?: IntWithAggregatesFilter | number
    idClientPeople?: IntWithAggregatesFilter | number
    orderDate?: DateTimeWithAggregatesFilter | Date | string
    idClub?: IntWithAggregatesFilter | number
    idEmployer?: IntWithAggregatesFilter | number
    idMailer?: IntWithAggregatesFilter | number
    deliveryCost?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type popularproductsWhereInput = {
    AND?: Enumerable<popularproductsWhereInput>
    OR?: Enumerable<popularproductsWhereInput>
    NOT?: Enumerable<popularproductsWhereInput>
    idPopularProducts?: IntFilter | number
    idProduct?: IntFilter | number
    amount?: IntFilter | number
    idClub?: IntFilter | number
    club?: XOR<ClubRelationFilter, clubWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type popularproductsOrderByWithRelationInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
    club?: clubOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type popularproductsWhereUniqueInput = {
    idPopularProducts?: number
  }

  export type popularproductsOrderByWithAggregationInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
    _count?: popularproductsCountOrderByAggregateInput
    _avg?: popularproductsAvgOrderByAggregateInput
    _max?: popularproductsMaxOrderByAggregateInput
    _min?: popularproductsMinOrderByAggregateInput
    _sum?: popularproductsSumOrderByAggregateInput
  }

  export type popularproductsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<popularproductsScalarWhereWithAggregatesInput>
    OR?: Enumerable<popularproductsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<popularproductsScalarWhereWithAggregatesInput>
    idPopularProducts?: IntWithAggregatesFilter | number
    idProduct?: IntWithAggregatesFilter | number
    amount?: IntWithAggregatesFilter | number
    idClub?: IntWithAggregatesFilter | number
  }

  export type presentationWhereInput = {
    AND?: Enumerable<presentationWhereInput>
    OR?: Enumerable<presentationWhereInput>
    NOT?: Enumerable<presentationWhereInput>
    idPresentation?: IntFilter | number
    idProduct?: IntFilter | number
    amountBottles?: IntFilter | number
    sizeBottle?: IntFilter | number
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type presentationOrderByWithRelationInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type presentationWhereUniqueInput = {
    idPresentation?: number
  }

  export type presentationOrderByWithAggregationInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
    _count?: presentationCountOrderByAggregateInput
    _avg?: presentationAvgOrderByAggregateInput
    _max?: presentationMaxOrderByAggregateInput
    _min?: presentationMinOrderByAggregateInput
    _sum?: presentationSumOrderByAggregateInput
  }

  export type presentationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<presentationScalarWhereWithAggregatesInput>
    OR?: Enumerable<presentationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<presentationScalarWhereWithAggregatesInput>
    idPresentation?: IntWithAggregatesFilter | number
    idProduct?: IntWithAggregatesFilter | number
    amountBottles?: IntWithAggregatesFilter | number
    sizeBottle?: IntWithAggregatesFilter | number
  }

  export type productWhereInput = {
    AND?: Enumerable<productWhereInput>
    OR?: Enumerable<productWhereInput>
    NOT?: Enumerable<productWhereInput>
    idProduct?: IntFilter | number
    productName?: StringNullableFilter | string | null
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    idProductType?: IntFilter | number
    image?: BytesNullableFilter | Buffer | null
    idSupplier?: IntFilter | number
    idCash?: IntFilter | number
    isActive?: BoolFilter | boolean
    entryDate?: DateTimeFilter | Date | string
    tier?: IntFilter | number
    productDescr?: StringNullableFilter | string | null
    cash?: XOR<CashRelationFilter, cashWhereInput>
    producttype?: XOR<ProducttypeRelationFilter, producttypeWhereInput>
    supplier?: XOR<SupplierRelationFilter, supplierWhereInput>
    inventory?: InventoryListRelationFilter
    orderline?: OrderlineListRelationFilter
    popularproducts?: PopularproductsListRelationFilter
    presentation?: PresentationListRelationFilter
    review?: ReviewListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    idProduct?: SortOrder
    productName?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    image?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    entryDate?: SortOrder
    tier?: SortOrder
    productDescr?: SortOrder
    cash?: cashOrderByWithRelationInput
    producttype?: producttypeOrderByWithRelationInput
    supplier?: supplierOrderByWithRelationInput
    inventory?: inventoryOrderByRelationAggregateInput
    orderline?: orderlineOrderByRelationAggregateInput
    popularproducts?: popularproductsOrderByRelationAggregateInput
    presentation?: presentationOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = {
    idProduct?: number
  }

  export type productOrderByWithAggregationInput = {
    idProduct?: SortOrder
    productName?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    image?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    entryDate?: SortOrder
    tier?: SortOrder
    productDescr?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: Enumerable<productScalarWhereWithAggregatesInput>
    OR?: Enumerable<productScalarWhereWithAggregatesInput>
    NOT?: Enumerable<productScalarWhereWithAggregatesInput>
    idProduct?: IntWithAggregatesFilter | number
    productName?: StringNullableWithAggregatesFilter | string | null
    cost?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    idProductType?: IntWithAggregatesFilter | number
    image?: BytesNullableWithAggregatesFilter | Buffer | null
    idSupplier?: IntWithAggregatesFilter | number
    idCash?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    entryDate?: DateTimeWithAggregatesFilter | Date | string
    tier?: IntWithAggregatesFilter | number
    productDescr?: StringNullableWithAggregatesFilter | string | null
  }

  export type producttypeWhereInput = {
    AND?: Enumerable<producttypeWhereInput>
    OR?: Enumerable<producttypeWhereInput>
    NOT?: Enumerable<producttypeWhereInput>
    idProductType?: IntFilter | number
    typeName?: StringFilter | string
    isActive?: BoolFilter | boolean
    product?: ProductListRelationFilter
  }

  export type producttypeOrderByWithRelationInput = {
    idProductType?: SortOrder
    typeName?: SortOrder
    isActive?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type producttypeWhereUniqueInput = {
    idProductType?: number
  }

  export type producttypeOrderByWithAggregationInput = {
    idProductType?: SortOrder
    typeName?: SortOrder
    isActive?: SortOrder
    _count?: producttypeCountOrderByAggregateInput
    _avg?: producttypeAvgOrderByAggregateInput
    _max?: producttypeMaxOrderByAggregateInput
    _min?: producttypeMinOrderByAggregateInput
    _sum?: producttypeSumOrderByAggregateInput
  }

  export type producttypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<producttypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<producttypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<producttypeScalarWhereWithAggregatesInput>
    idProductType?: IntWithAggregatesFilter | number
    typeName?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type qualificationWhereInput = {
    AND?: Enumerable<qualificationWhereInput>
    OR?: Enumerable<qualificationWhereInput>
    NOT?: Enumerable<qualificationWhereInput>
    idQualification?: IntFilter | number
    idWorkerReview?: IntFilter | number
    qualDescription?: StringFilter | string
    workerreview?: XOR<WorkerreviewRelationFilter, workerreviewWhereInput>
  }

  export type qualificationOrderByWithRelationInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
    qualDescription?: SortOrder
    workerreview?: workerreviewOrderByWithRelationInput
  }

  export type qualificationWhereUniqueInput = {
    idQualification?: number
  }

  export type qualificationOrderByWithAggregationInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
    qualDescription?: SortOrder
    _count?: qualificationCountOrderByAggregateInput
    _avg?: qualificationAvgOrderByAggregateInput
    _max?: qualificationMaxOrderByAggregateInput
    _min?: qualificationMinOrderByAggregateInput
    _sum?: qualificationSumOrderByAggregateInput
  }

  export type qualificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    idQualification?: IntWithAggregatesFilter | number
    idWorkerReview?: IntWithAggregatesFilter | number
    qualDescription?: StringWithAggregatesFilter | string
  }

  export type reviewWhereInput = {
    AND?: Enumerable<reviewWhereInput>
    OR?: Enumerable<reviewWhereInput>
    NOT?: Enumerable<reviewWhereInput>
    idReview?: IntFilter | number
    idProduct?: IntFilter | number
    score?: IntFilter | number
    revDescription?: StringFilter | string
    idClientUser?: IntFilter | number
    revDate?: DateTimeFilter | Date | string
    clientuser?: XOR<ClientuserRelationFilter, clientuserWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type reviewOrderByWithRelationInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    revDescription?: SortOrder
    idClientUser?: SortOrder
    revDate?: SortOrder
    clientuser?: clientuserOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type reviewWhereUniqueInput = {
    idReview?: number
  }

  export type reviewOrderByWithAggregationInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    revDescription?: SortOrder
    idClientUser?: SortOrder
    revDate?: SortOrder
    _count?: reviewCountOrderByAggregateInput
    _avg?: reviewAvgOrderByAggregateInput
    _max?: reviewMaxOrderByAggregateInput
    _min?: reviewMinOrderByAggregateInput
    _sum?: reviewSumOrderByAggregateInput
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reviewScalarWhereWithAggregatesInput>
    idReview?: IntWithAggregatesFilter | number
    idProduct?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    revDescription?: StringWithAggregatesFilter | string
    idClientUser?: IntWithAggregatesFilter | number
    revDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type supplierWhereInput = {
    AND?: Enumerable<supplierWhereInput>
    OR?: Enumerable<supplierWhereInput>
    NOT?: Enumerable<supplierWhereInput>
    idSupplier?: IntFilter | number
    supplierName?: StringFilter | string
    isActive?: BoolFilter | boolean
    product?: ProductListRelationFilter
  }

  export type supplierOrderByWithRelationInput = {
    idSupplier?: SortOrder
    supplierName?: SortOrder
    isActive?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type supplierWhereUniqueInput = {
    idSupplier?: number
  }

  export type supplierOrderByWithAggregationInput = {
    idSupplier?: SortOrder
    supplierName?: SortOrder
    isActive?: SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: Enumerable<supplierScalarWhereWithAggregatesInput>
    OR?: Enumerable<supplierScalarWhereWithAggregatesInput>
    NOT?: Enumerable<supplierScalarWhereWithAggregatesInput>
    idSupplier?: IntWithAggregatesFilter | number
    supplierName?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type workerreviewWhereInput = {
    AND?: Enumerable<workerreviewWhereInput>
    OR?: Enumerable<workerreviewWhereInput>
    NOT?: Enumerable<workerreviewWhereInput>
    idWorkerReview?: IntFilter | number
    idClientUser?: IntFilter | number
    idWorker?: IntFilter | number
    dateWR?: DateTimeFilter | Date | string
    clientuser?: XOR<ClientuserRelationFilter, clientuserWhereInput>
    complaint?: ComplaintListRelationFilter
    qualification?: QualificationListRelationFilter
  }

  export type workerreviewOrderByWithRelationInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
    dateWR?: SortOrder
    clientuser?: clientuserOrderByWithRelationInput
    complaint?: complaintOrderByRelationAggregateInput
    qualification?: qualificationOrderByRelationAggregateInput
  }

  export type workerreviewWhereUniqueInput = {
    idWorkerReview?: number
  }

  export type workerreviewOrderByWithAggregationInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
    dateWR?: SortOrder
    _count?: workerreviewCountOrderByAggregateInput
    _avg?: workerreviewAvgOrderByAggregateInput
    _max?: workerreviewMaxOrderByAggregateInput
    _min?: workerreviewMinOrderByAggregateInput
    _sum?: workerreviewSumOrderByAggregateInput
  }

  export type workerreviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<workerreviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<workerreviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<workerreviewScalarWhereWithAggregatesInput>
    idWorkerReview?: IntWithAggregatesFilter | number
    idClientUser?: IntWithAggregatesFilter | number
    idWorker?: IntWithAggregatesFilter | number
    dateWR?: DateTimeWithAggregatesFilter | Date | string
  }

  export type cardCreateInput = {
    cardNumber: string
    expirationDate: Date | string
    cvv: number
    infopeople: infopeopleCreateNestedOneWithoutCardInput
  }

  export type cardUncheckedCreateInput = {
    idCard?: number
    idInfoPeople: number
    cardNumber: string
    expirationDate: Date | string
    cvv: number
  }

  export type cardUpdateInput = {
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
    infopeople?: infopeopleUpdateOneRequiredWithoutCardInput
  }

  export type cardUncheckedUpdateInput = {
    idCard?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type cardCreateManyInput = {
    idCard?: number
    idInfoPeople: number
    cardNumber: string
    expirationDate: Date | string
    cvv: number
  }

  export type cardUpdateManyMutationInput = {
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateManyInput = {
    idCard?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type cashCreateInput = {
    cashType: string
    club?: clubCreateNestedManyWithoutCashInput
    product?: productCreateNestedManyWithoutCashInput
  }

  export type cashUncheckedCreateInput = {
    idCash?: number
    cashType: string
    club?: clubUncheckedCreateNestedManyWithoutCashInput
    product?: productUncheckedCreateNestedManyWithoutCashInput
  }

  export type cashUpdateInput = {
    cashType?: StringFieldUpdateOperationsInput | string
    club?: clubUpdateManyWithoutCashInput
    product?: productUpdateManyWithoutCashInput
  }

  export type cashUncheckedUpdateInput = {
    idCash?: IntFieldUpdateOperationsInput | number
    cashType?: StringFieldUpdateOperationsInput | string
    club?: clubUncheckedUpdateManyWithoutCashInput
    product?: productUncheckedUpdateManyWithoutCashInput
  }

  export type cashCreateManyInput = {
    idCash?: number
    cashType: string
  }

  export type cashUpdateManyMutationInput = {
    cashType?: StringFieldUpdateOperationsInput | string
  }

  export type cashUncheckedUpdateManyInput = {
    idCash?: IntFieldUpdateOperationsInput | number
    cashType?: StringFieldUpdateOperationsInput | string
  }

  export type clientlocationCreateInput = {
    clientpeople: clientpeopleCreateNestedOneWithoutClientlocationInput
    location: locationCreateNestedOneWithoutClientlocationInput
  }

  export type clientlocationUncheckedCreateInput = {
    idClientLocation?: number
    idClientPeople: number
    idLocation: number
  }

  export type clientlocationUpdateInput = {
    clientpeople?: clientpeopleUpdateOneRequiredWithoutClientlocationInput
    location?: locationUpdateOneRequiredWithoutClientlocationInput
  }

  export type clientlocationUncheckedUpdateInput = {
    idClientLocation?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idLocation?: IntFieldUpdateOperationsInput | number
  }

  export type clientlocationCreateManyInput = {
    idClientLocation?: number
    idClientPeople: number
    idLocation: number
  }

  export type clientlocationUpdateManyMutationInput = {

  }

  export type clientlocationUncheckedUpdateManyInput = {
    idClientLocation?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idLocation?: IntFieldUpdateOperationsInput | number
  }

  export type clientmembershipCreateInput = {
    clientpeople: clientpeopleCreateNestedOneWithoutClientmembershipInput
    membership: membershipCreateNestedOneWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedCreateInput = {
    idClientMembership?: number
    idMembership: number
    idClientPeople: number
  }

  export type clientmembershipUpdateInput = {
    clientpeople?: clientpeopleUpdateOneRequiredWithoutClientmembershipInput
    membership?: membershipUpdateOneRequiredWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedUpdateInput = {
    idClientMembership?: IntFieldUpdateOperationsInput | number
    idMembership?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
  }

  export type clientmembershipCreateManyInput = {
    idClientMembership?: number
    idMembership: number
    idClientPeople: number
  }

  export type clientmembershipUpdateManyMutationInput = {

  }

  export type clientmembershipUncheckedUpdateManyInput = {
    idClientMembership?: IntFieldUpdateOperationsInput | number
    idMembership?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
  }

  export type clientpeopleCreateInput = {
    salesCounter?: number
    isActive: boolean
    clientuser: clientuserCreateNestedOneWithoutClientpeopleInput
    infopeople: infopeopleCreateNestedOneWithoutClientpeopleInput
    clientlocation?: clientlocationCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateInput = {
    idClientPeople?: number
    idClientUser: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
    clientlocation?: clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUpdateInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientuser?: clientuserUpdateOneRequiredWithoutClientpeopleInput
    infopeople?: infopeopleUpdateOneRequiredWithoutClientpeopleInput
    clientlocation?: clientlocationUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUpdateManyWithoutClientpeopleInput
    orderp?: orderpUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutClientpeopleInput
    orderp?: orderpUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateManyInput = {
    idClientPeople?: number
    idClientUser: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
  }

  export type clientpeopleUpdateManyMutationInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clientpeopleUncheckedUpdateManyInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clientuserCreateInput = {
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleCreateNestedManyWithoutClientuserInput
    review?: reviewCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewCreateNestedManyWithoutClientuserInput
  }

  export type clientuserUncheckedCreateInput = {
    idClientUser?: number
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleUncheckedCreateNestedManyWithoutClientuserInput
    review?: reviewUncheckedCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedCreateNestedManyWithoutClientuserInput
  }

  export type clientuserUpdateInput = {
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUpdateManyWithoutClientuserInput
    review?: reviewUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUpdateManyWithoutClientuserInput
  }

  export type clientuserUncheckedUpdateInput = {
    idClientUser?: IntFieldUpdateOperationsInput | number
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUncheckedUpdateManyWithoutClientuserInput
    review?: reviewUncheckedUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedUpdateManyWithoutClientuserInput
  }

  export type clientuserCreateManyInput = {
    idClientUser?: number
    userPassword: Buffer
    isActive: boolean
  }

  export type clientuserUpdateManyMutationInput = {
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clientuserUncheckedUpdateManyInput = {
    idClientUser?: IntFieldUpdateOperationsInput | number
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clubCreateInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    cash: cashCreateNestedOneWithoutClubInput
    location: locationCreateNestedOneWithoutClubInput
    inventory?: inventoryCreateNestedManyWithoutClubInput
    orderp?: orderpCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    inventory?: inventoryUncheckedCreateNestedManyWithoutClubInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubUpdateInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    cash?: cashUpdateOneRequiredWithoutClubInput
    location?: locationUpdateOneRequiredWithoutClubInput
    inventory?: inventoryUpdateManyWithoutClubInput
    orderp?: orderpUpdateManyWithoutClubInput
    popularproducts?: popularproductsUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inventory?: inventoryUncheckedUpdateManyWithoutClubInput
    orderp?: orderpUncheckedUpdateManyWithoutClubInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutClubInput
  }

  export type clubCreateManyInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
  }

  export type clubUpdateManyMutationInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clubUncheckedUpdateManyInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintCreateInput = {
    compDescription: string
    solved: boolean
    workerreview: workerreviewCreateNestedOneWithoutComplaintInput
  }

  export type complaintUncheckedCreateInput = {
    idComplaint?: number
    idWorkerReview: number
    compDescription: string
    solved: boolean
  }

  export type complaintUpdateInput = {
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
    workerreview?: workerreviewUpdateOneRequiredWithoutComplaintInput
  }

  export type complaintUncheckedUpdateInput = {
    idComplaint?: IntFieldUpdateOperationsInput | number
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintCreateManyInput = {
    idComplaint?: number
    idWorkerReview: number
    compDescription: string
    solved: boolean
  }

  export type complaintUpdateManyMutationInput = {
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintUncheckedUpdateManyInput = {
    idComplaint?: IntFieldUpdateOperationsInput | number
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type infopeopleCreateInput = {
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    card?: cardCreateNestedManyWithoutInfopeopleInput
    clientpeople?: clientpeopleCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedCreateInput = {
    idInfoPeople?: number
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    card?: cardUncheckedCreateNestedManyWithoutInfopeopleInput
    clientpeople?: clientpeopleUncheckedCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleUpdateInput = {
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    card?: cardUpdateManyWithoutInfopeopleInput
    clientpeople?: clientpeopleUpdateManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedUpdateInput = {
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    card?: cardUncheckedUpdateManyWithoutInfopeopleInput
    clientpeople?: clientpeopleUncheckedUpdateManyWithoutInfopeopleInput
  }

  export type infopeopleCreateManyInput = {
    idInfoPeople?: number
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
  }

  export type infopeopleUpdateManyMutationInput = {
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type infopeopleUncheckedUpdateManyInput = {
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventoryCreateInput = {
    stock?: number
    isActive: boolean
    club: clubCreateNestedOneWithoutInventoryInput
    product: productCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateInput = {
    idInventory?: number
    idClub: number
    idProduct: number
    stock?: number
    isActive: boolean
  }

  export type inventoryUpdateInput = {
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    club?: clubUpdateOneRequiredWithoutInventoryInput
    product?: productUpdateOneRequiredWithoutInventoryInput
  }

  export type inventoryUncheckedUpdateInput = {
    idInventory?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventoryCreateManyInput = {
    idInventory?: number
    idClub: number
    idProduct: number
    stock?: number
    isActive: boolean
  }

  export type inventoryUpdateManyMutationInput = {
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventoryUncheckedUpdateManyInput = {
    idInventory?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type locationUpdateInput = {
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUpdateManyWithoutLocationInput
    club?: clubUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateInput = {
    idLocation?: IntFieldUpdateOperationsInput | number
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutLocationInput
    club?: clubUncheckedUpdateManyWithoutLocationInput
  }

  export type locationUpdateManyMutationInput = {
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type locationUncheckedUpdateManyInput = {
    idLocation?: IntFieldUpdateOperationsInput | number
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type membershipCreateInput = {
    nameMembership: string
    cost: Decimal | DecimalJsLike | number | string
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
    clientmembership?: clientmembershipCreateNestedManyWithoutMembershipInput
  }

  export type membershipUncheckedCreateInput = {
    idMembership?: number
    nameMembership: string
    cost: Decimal | DecimalJsLike | number | string
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type membershipUpdateInput = {
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientmembership?: clientmembershipUpdateManyWithoutMembershipInput
  }

  export type membershipUncheckedUpdateInput = {
    idMembership?: IntFieldUpdateOperationsInput | number
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutMembershipInput
  }

  export type membershipCreateManyInput = {
    idMembership?: number
    nameMembership: string
    cost: Decimal | DecimalJsLike | number | string
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
  }

  export type membershipUpdateManyMutationInput = {
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type membershipUncheckedUpdateManyInput = {
    idMembership?: IntFieldUpdateOperationsInput | number
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type orderlineCreateInput = {
    cost: Decimal | DecimalJsLike | number | string
    amount: number
    orderp: orderpCreateNestedOneWithoutOrderlineInput
    product: productCreateNestedOneWithoutOrderlineInput
  }

  export type orderlineUncheckedCreateInput = {
    idOrderLine?: number
    idOrderP: number
    idProduct: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type orderlineUpdateInput = {
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
    orderp?: orderpUpdateOneRequiredWithoutOrderlineInput
    product?: productUpdateOneRequiredWithoutOrderlineInput
  }

  export type orderlineUncheckedUpdateInput = {
    idOrderLine?: IntFieldUpdateOperationsInput | number
    idOrderP?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type orderlineCreateManyInput = {
    idOrderLine?: number
    idOrderP: number
    idProduct: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type orderlineUpdateManyMutationInput = {
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type orderlineUncheckedUpdateManyInput = {
    idOrderLine?: IntFieldUpdateOperationsInput | number
    idOrderP?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type orderpCreateInput = {
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    clientpeople: clientpeopleCreateNestedOneWithoutOrderpInput
    club: clubCreateNestedOneWithoutOrderpInput
    orderline?: orderlineCreateNestedManyWithoutOrderpInput
  }

  export type orderpUncheckedCreateInput = {
    idOrderP?: number
    idClientPeople: number
    orderDate: Date | string
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedCreateNestedManyWithoutOrderpInput
  }

  export type orderpUpdateInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientpeople?: clientpeopleUpdateOneRequiredWithoutOrderpInput
    club?: clubUpdateOneRequiredWithoutOrderpInput
    orderline?: orderlineUpdateManyWithoutOrderpInput
  }

  export type orderpUncheckedUpdateInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idClub?: IntFieldUpdateOperationsInput | number
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedUpdateManyWithoutOrderpInput
  }

  export type orderpCreateManyInput = {
    idOrderP?: number
    idClientPeople: number
    orderDate: Date | string
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
  }

  export type orderpUpdateManyMutationInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type orderpUncheckedUpdateManyInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idClub?: IntFieldUpdateOperationsInput | number
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type popularproductsCreateInput = {
    amount?: number
    club: clubCreateNestedOneWithoutPopularproductsInput
    product: productCreateNestedOneWithoutPopularproductsInput
  }

  export type popularproductsUncheckedCreateInput = {
    idPopularProducts?: number
    idProduct: number
    amount?: number
    idClub: number
  }

  export type popularproductsUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    club?: clubUpdateOneRequiredWithoutPopularproductsInput
    product?: productUpdateOneRequiredWithoutPopularproductsInput
  }

  export type popularproductsUncheckedUpdateInput = {
    idPopularProducts?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
  }

  export type popularproductsCreateManyInput = {
    idPopularProducts?: number
    idProduct: number
    amount?: number
    idClub: number
  }

  export type popularproductsUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type popularproductsUncheckedUpdateManyInput = {
    idPopularProducts?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
  }

  export type presentationCreateInput = {
    amountBottles: number
    sizeBottle: number
    product: productCreateNestedOneWithoutPresentationInput
  }

  export type presentationUncheckedCreateInput = {
    idPresentation?: number
    idProduct: number
    amountBottles: number
    sizeBottle: number
  }

  export type presentationUpdateInput = {
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutPresentationInput
  }

  export type presentationUncheckedUpdateInput = {
    idPresentation?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type presentationCreateManyInput = {
    idPresentation?: number
    idProduct: number
    amountBottles: number
    sizeBottle: number
  }

  export type presentationUpdateManyMutationInput = {
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type presentationUncheckedUpdateManyInput = {
    idPresentation?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type productCreateInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type productCreateManyInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
  }

  export type productUpdateManyMutationInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productUncheckedUpdateManyInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type producttypeCreateInput = {
    typeName: string
    isActive: boolean
    product?: productCreateNestedManyWithoutProducttypeInput
  }

  export type producttypeUncheckedCreateInput = {
    idProductType?: number
    typeName: string
    isActive: boolean
    product?: productUncheckedCreateNestedManyWithoutProducttypeInput
  }

  export type producttypeUpdateInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateManyWithoutProducttypeInput
  }

  export type producttypeUncheckedUpdateInput = {
    idProductType?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: productUncheckedUpdateManyWithoutProducttypeInput
  }

  export type producttypeCreateManyInput = {
    idProductType?: number
    typeName: string
    isActive: boolean
  }

  export type producttypeUpdateManyMutationInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type producttypeUncheckedUpdateManyInput = {
    idProductType?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qualificationCreateInput = {
    qualDescription: string
    workerreview: workerreviewCreateNestedOneWithoutQualificationInput
  }

  export type qualificationUncheckedCreateInput = {
    idQualification?: number
    idWorkerReview: number
    qualDescription: string
  }

  export type qualificationUpdateInput = {
    qualDescription?: StringFieldUpdateOperationsInput | string
    workerreview?: workerreviewUpdateOneRequiredWithoutQualificationInput
  }

  export type qualificationUncheckedUpdateInput = {
    idQualification?: IntFieldUpdateOperationsInput | number
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    qualDescription?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationCreateManyInput = {
    idQualification?: number
    idWorkerReview: number
    qualDescription: string
  }

  export type qualificationUpdateManyMutationInput = {
    qualDescription?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateManyInput = {
    idQualification?: IntFieldUpdateOperationsInput | number
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    qualDescription?: StringFieldUpdateOperationsInput | string
  }

  export type reviewCreateInput = {
    score: number
    revDescription: string
    revDate: Date | string
    clientuser: clientuserCreateNestedOneWithoutReviewInput
    product: productCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    idReview?: number
    idProduct: number
    score: number
    revDescription: string
    idClientUser: number
    revDate: Date | string
  }

  export type reviewUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientuser?: clientuserUpdateOneRequiredWithoutReviewInput
    product?: productUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateInput = {
    idReview?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    idClientUser?: IntFieldUpdateOperationsInput | number
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewCreateManyInput = {
    idReview?: number
    idProduct: number
    score: number
    revDescription: string
    idClientUser: number
    revDate: Date | string
  }

  export type reviewUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewUncheckedUpdateManyInput = {
    idReview?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    idClientUser?: IntFieldUpdateOperationsInput | number
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierCreateInput = {
    supplierName: string
    isActive: boolean
    product?: productCreateNestedManyWithoutSupplierInput
  }

  export type supplierUncheckedCreateInput = {
    idSupplier?: number
    supplierName: string
    isActive: boolean
    product?: productUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type supplierUpdateInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateManyWithoutSupplierInput
  }

  export type supplierUncheckedUpdateInput = {
    idSupplier?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: productUncheckedUpdateManyWithoutSupplierInput
  }

  export type supplierCreateManyInput = {
    idSupplier?: number
    supplierName: string
    isActive: boolean
  }

  export type supplierUpdateManyMutationInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type supplierUncheckedUpdateManyInput = {
    idSupplier?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type workerreviewCreateInput = {
    idWorker: number
    dateWR: Date | string
    clientuser: clientuserCreateNestedOneWithoutWorkerreviewInput
    complaint?: complaintCreateNestedManyWithoutWorkerreviewInput
    qualification?: qualificationCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedCreateInput = {
    idWorkerReview?: number
    idClientUser: number
    idWorker: number
    dateWR: Date | string
    complaint?: complaintUncheckedCreateNestedManyWithoutWorkerreviewInput
    qualification?: qualificationUncheckedCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewUpdateInput = {
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    clientuser?: clientuserUpdateOneRequiredWithoutWorkerreviewInput
    complaint?: complaintUpdateManyWithoutWorkerreviewInput
    qualification?: qualificationUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedUpdateInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: complaintUncheckedUpdateManyWithoutWorkerreviewInput
    qualification?: qualificationUncheckedUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewCreateManyInput = {
    idWorkerReview?: number
    idClientUser: number
    idWorker: number
    dateWR: Date | string
  }

  export type workerreviewUpdateManyMutationInput = {
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workerreviewUncheckedUpdateManyInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type InfopeopleRelationFilter = {
    is?: infopeopleWhereInput
    isNot?: infopeopleWhereInput
  }

  export type cardCountOrderByAggregateInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cardNumber?: SortOrder
    expirationDate?: SortOrder
    cvv?: SortOrder
  }

  export type cardAvgOrderByAggregateInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cvv?: SortOrder
  }

  export type cardMaxOrderByAggregateInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cardNumber?: SortOrder
    expirationDate?: SortOrder
    cvv?: SortOrder
  }

  export type cardMinOrderByAggregateInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cardNumber?: SortOrder
    expirationDate?: SortOrder
    cvv?: SortOrder
  }

  export type cardSumOrderByAggregateInput = {
    idCard?: SortOrder
    idInfoPeople?: SortOrder
    cvv?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type ClubListRelationFilter = {
    every?: clubWhereInput
    some?: clubWhereInput
    none?: clubWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type clubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cashCountOrderByAggregateInput = {
    idCash?: SortOrder
    cashType?: SortOrder
  }

  export type cashAvgOrderByAggregateInput = {
    idCash?: SortOrder
  }

  export type cashMaxOrderByAggregateInput = {
    idCash?: SortOrder
    cashType?: SortOrder
  }

  export type cashMinOrderByAggregateInput = {
    idCash?: SortOrder
    cashType?: SortOrder
  }

  export type cashSumOrderByAggregateInput = {
    idCash?: SortOrder
  }

  export type ClientpeopleRelationFilter = {
    is?: clientpeopleWhereInput
    isNot?: clientpeopleWhereInput
  }

  export type LocationRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type clientlocationCountOrderByAggregateInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
  }

  export type clientlocationAvgOrderByAggregateInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
  }

  export type clientlocationMaxOrderByAggregateInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
  }

  export type clientlocationMinOrderByAggregateInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
  }

  export type clientlocationSumOrderByAggregateInput = {
    idClientLocation?: SortOrder
    idClientPeople?: SortOrder
    idLocation?: SortOrder
  }

  export type MembershipRelationFilter = {
    is?: membershipWhereInput
    isNot?: membershipWhereInput
  }

  export type clientmembershipCountOrderByAggregateInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
  }

  export type clientmembershipAvgOrderByAggregateInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
  }

  export type clientmembershipMaxOrderByAggregateInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
  }

  export type clientmembershipMinOrderByAggregateInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
  }

  export type clientmembershipSumOrderByAggregateInput = {
    idClientMembership?: SortOrder
    idMembership?: SortOrder
    idClientPeople?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ClientuserRelationFilter = {
    is?: clientuserWhereInput
    isNot?: clientuserWhereInput
  }

  export type ClientlocationListRelationFilter = {
    every?: clientlocationWhereInput
    some?: clientlocationWhereInput
    none?: clientlocationWhereInput
  }

  export type ClientmembershipListRelationFilter = {
    every?: clientmembershipWhereInput
    some?: clientmembershipWhereInput
    none?: clientmembershipWhereInput
  }

  export type OrderpListRelationFilter = {
    every?: orderpWhereInput
    some?: orderpWhereInput
    none?: orderpWhereInput
  }

  export type clientlocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientmembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientpeopleCountOrderByAggregateInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
    isActive?: SortOrder
  }

  export type clientpeopleAvgOrderByAggregateInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
  }

  export type clientpeopleMaxOrderByAggregateInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
    isActive?: SortOrder
  }

  export type clientpeopleMinOrderByAggregateInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
    isActive?: SortOrder
  }

  export type clientpeopleSumOrderByAggregateInput = {
    idClientPeople?: SortOrder
    idClientUser?: SortOrder
    idInfoPeople?: SortOrder
    salesCounter?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type ClientpeopleListRelationFilter = {
    every?: clientpeopleWhereInput
    some?: clientpeopleWhereInput
    none?: clientpeopleWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type WorkerreviewListRelationFilter = {
    every?: workerreviewWhereInput
    some?: workerreviewWhereInput
    none?: workerreviewWhereInput
  }

  export type clientpeopleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type workerreviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientuserCountOrderByAggregateInput = {
    idClientUser?: SortOrder
    userPassword?: SortOrder
    isActive?: SortOrder
  }

  export type clientuserAvgOrderByAggregateInput = {
    idClientUser?: SortOrder
  }

  export type clientuserMaxOrderByAggregateInput = {
    idClientUser?: SortOrder
    userPassword?: SortOrder
    isActive?: SortOrder
  }

  export type clientuserMinOrderByAggregateInput = {
    idClientUser?: SortOrder
    userPassword?: SortOrder
    isActive?: SortOrder
  }

  export type clientuserSumOrderByAggregateInput = {
    idClientUser?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CashRelationFilter = {
    is?: cashWhereInput
    isNot?: cashWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: inventoryWhereInput
    some?: inventoryWhereInput
    none?: inventoryWhereInput
  }

  export type PopularproductsListRelationFilter = {
    every?: popularproductsWhereInput
    some?: popularproductsWhereInput
    none?: popularproductsWhereInput
  }

  export type inventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type popularproductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clubCountOrderByAggregateInput = {
    idClub?: SortOrder
    clubName?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
  }

  export type clubAvgOrderByAggregateInput = {
    idClub?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
  }

  export type clubMaxOrderByAggregateInput = {
    idClub?: SortOrder
    clubName?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
  }

  export type clubMinOrderByAggregateInput = {
    idClub?: SortOrder
    clubName?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
  }

  export type clubSumOrderByAggregateInput = {
    idClub?: SortOrder
    idLocation?: SortOrder
    deliveryCostProp?: SortOrder
    idCash?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type WorkerreviewRelationFilter = {
    is?: workerreviewWhereInput
    isNot?: workerreviewWhereInput
  }

  export type complaintCountOrderByAggregateInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
    compDescription?: SortOrder
    solved?: SortOrder
  }

  export type complaintAvgOrderByAggregateInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
  }

  export type complaintMaxOrderByAggregateInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
    compDescription?: SortOrder
    solved?: SortOrder
  }

  export type complaintMinOrderByAggregateInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
    compDescription?: SortOrder
    solved?: SortOrder
  }

  export type complaintSumOrderByAggregateInput = {
    idComplaint?: SortOrder
    idWorkerReview?: SortOrder
  }

  export type CardListRelationFilter = {
    every?: cardWhereInput
    some?: cardWhereInput
    none?: cardWhereInput
  }

  export type cardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type infopeopleCountOrderByAggregateInput = {
    idInfoPeople?: SortOrder
    peopleName?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
  }

  export type infopeopleAvgOrderByAggregateInput = {
    idInfoPeople?: SortOrder
    phoneNumber?: SortOrder
  }

  export type infopeopleMaxOrderByAggregateInput = {
    idInfoPeople?: SortOrder
    peopleName?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
  }

  export type infopeopleMinOrderByAggregateInput = {
    idInfoPeople?: SortOrder
    peopleName?: SortOrder
    surname?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
  }

  export type infopeopleSumOrderByAggregateInput = {
    idInfoPeople?: SortOrder
    phoneNumber?: SortOrder
  }

  export type ClubRelationFilter = {
    is?: clubWhereInput
    isNot?: clubWhereInput
  }

  export type ProductRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type inventoryCountOrderByAggregateInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
  }

  export type inventoryAvgOrderByAggregateInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
  }

  export type inventoryMaxOrderByAggregateInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
  }

  export type inventoryMinOrderByAggregateInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
  }

  export type inventorySumOrderByAggregateInput = {
    idInventory?: SortOrder
    idClub?: SortOrder
    idProduct?: SortOrder
    stock?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type locationCountOrderByAggregateInput = {
    idLocation?: SortOrder
    typeLocation?: SortOrder
    isActive?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    idLocation?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    idLocation?: SortOrder
    typeLocation?: SortOrder
    isActive?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    idLocation?: SortOrder
    typeLocation?: SortOrder
    isActive?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    idLocation?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type membershipCountOrderByAggregateInput = {
    idMembership?: SortOrder
    nameMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    isActive?: SortOrder
  }

  export type membershipAvgOrderByAggregateInput = {
    idMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
  }

  export type membershipMaxOrderByAggregateInput = {
    idMembership?: SortOrder
    nameMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    isActive?: SortOrder
  }

  export type membershipMinOrderByAggregateInput = {
    idMembership?: SortOrder
    nameMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
    isActive?: SortOrder
  }

  export type membershipSumOrderByAggregateInput = {
    idMembership?: SortOrder
    cost?: SortOrder
    productDiscount?: SortOrder
    deliveryDiscount?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type OrderpRelationFilter = {
    is?: orderpWhereInput
    isNot?: orderpWhereInput
  }

  export type orderlineCountOrderByAggregateInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
  }

  export type orderlineAvgOrderByAggregateInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
  }

  export type orderlineMaxOrderByAggregateInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
  }

  export type orderlineMinOrderByAggregateInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
  }

  export type orderlineSumOrderByAggregateInput = {
    idOrderLine?: SortOrder
    idOrderP?: SortOrder
    idProduct?: SortOrder
    cost?: SortOrder
    amount?: SortOrder
  }

  export type OrderlineListRelationFilter = {
    every?: orderlineWhereInput
    some?: orderlineWhereInput
    none?: orderlineWhereInput
  }

  export type orderlineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderpCountOrderByAggregateInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    orderDate?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
  }

  export type orderpAvgOrderByAggregateInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
  }

  export type orderpMaxOrderByAggregateInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    orderDate?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
  }

  export type orderpMinOrderByAggregateInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    orderDate?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
  }

  export type orderpSumOrderByAggregateInput = {
    idOrderP?: SortOrder
    idClientPeople?: SortOrder
    idClub?: SortOrder
    idEmployer?: SortOrder
    idMailer?: SortOrder
    deliveryCost?: SortOrder
  }

  export type popularproductsCountOrderByAggregateInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
  }

  export type popularproductsAvgOrderByAggregateInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
  }

  export type popularproductsMaxOrderByAggregateInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
  }

  export type popularproductsMinOrderByAggregateInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
  }

  export type popularproductsSumOrderByAggregateInput = {
    idPopularProducts?: SortOrder
    idProduct?: SortOrder
    amount?: SortOrder
    idClub?: SortOrder
  }

  export type presentationCountOrderByAggregateInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
  }

  export type presentationAvgOrderByAggregateInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
  }

  export type presentationMaxOrderByAggregateInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
  }

  export type presentationMinOrderByAggregateInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
  }

  export type presentationSumOrderByAggregateInput = {
    idPresentation?: SortOrder
    idProduct?: SortOrder
    amountBottles?: SortOrder
    sizeBottle?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type ProducttypeRelationFilter = {
    is?: producttypeWhereInput
    isNot?: producttypeWhereInput
  }

  export type SupplierRelationFilter = {
    is?: supplierWhereInput
    isNot?: supplierWhereInput
  }

  export type PresentationListRelationFilter = {
    every?: presentationWhereInput
    some?: presentationWhereInput
    none?: presentationWhereInput
  }

  export type presentationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    idProduct?: SortOrder
    productName?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    image?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    entryDate?: SortOrder
    tier?: SortOrder
    productDescr?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    idProduct?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    tier?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    idProduct?: SortOrder
    productName?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    image?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    entryDate?: SortOrder
    tier?: SortOrder
    productDescr?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    idProduct?: SortOrder
    productName?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    image?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    isActive?: SortOrder
    entryDate?: SortOrder
    tier?: SortOrder
    productDescr?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    idProduct?: SortOrder
    cost?: SortOrder
    idProductType?: SortOrder
    idSupplier?: SortOrder
    idCash?: SortOrder
    tier?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type producttypeCountOrderByAggregateInput = {
    idProductType?: SortOrder
    typeName?: SortOrder
    isActive?: SortOrder
  }

  export type producttypeAvgOrderByAggregateInput = {
    idProductType?: SortOrder
  }

  export type producttypeMaxOrderByAggregateInput = {
    idProductType?: SortOrder
    typeName?: SortOrder
    isActive?: SortOrder
  }

  export type producttypeMinOrderByAggregateInput = {
    idProductType?: SortOrder
    typeName?: SortOrder
    isActive?: SortOrder
  }

  export type producttypeSumOrderByAggregateInput = {
    idProductType?: SortOrder
  }

  export type qualificationCountOrderByAggregateInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
    qualDescription?: SortOrder
  }

  export type qualificationAvgOrderByAggregateInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
  }

  export type qualificationMaxOrderByAggregateInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
    qualDescription?: SortOrder
  }

  export type qualificationMinOrderByAggregateInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
    qualDescription?: SortOrder
  }

  export type qualificationSumOrderByAggregateInput = {
    idQualification?: SortOrder
    idWorkerReview?: SortOrder
  }

  export type reviewCountOrderByAggregateInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    revDescription?: SortOrder
    idClientUser?: SortOrder
    revDate?: SortOrder
  }

  export type reviewAvgOrderByAggregateInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    idClientUser?: SortOrder
  }

  export type reviewMaxOrderByAggregateInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    revDescription?: SortOrder
    idClientUser?: SortOrder
    revDate?: SortOrder
  }

  export type reviewMinOrderByAggregateInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    revDescription?: SortOrder
    idClientUser?: SortOrder
    revDate?: SortOrder
  }

  export type reviewSumOrderByAggregateInput = {
    idReview?: SortOrder
    idProduct?: SortOrder
    score?: SortOrder
    idClientUser?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    idSupplier?: SortOrder
    supplierName?: SortOrder
    isActive?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    idSupplier?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    idSupplier?: SortOrder
    supplierName?: SortOrder
    isActive?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    idSupplier?: SortOrder
    supplierName?: SortOrder
    isActive?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    idSupplier?: SortOrder
  }

  export type ComplaintListRelationFilter = {
    every?: complaintWhereInput
    some?: complaintWhereInput
    none?: complaintWhereInput
  }

  export type QualificationListRelationFilter = {
    every?: qualificationWhereInput
    some?: qualificationWhereInput
    none?: qualificationWhereInput
  }

  export type complaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type workerreviewCountOrderByAggregateInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
    dateWR?: SortOrder
  }

  export type workerreviewAvgOrderByAggregateInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
  }

  export type workerreviewMaxOrderByAggregateInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
    dateWR?: SortOrder
  }

  export type workerreviewMinOrderByAggregateInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
    dateWR?: SortOrder
  }

  export type workerreviewSumOrderByAggregateInput = {
    idWorkerReview?: SortOrder
    idClientUser?: SortOrder
    idWorker?: SortOrder
  }

  export type infopeopleCreateNestedOneWithoutCardInput = {
    create?: XOR<infopeopleCreateWithoutCardInput, infopeopleUncheckedCreateWithoutCardInput>
    connectOrCreate?: infopeopleCreateOrConnectWithoutCardInput
    connect?: infopeopleWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type infopeopleUpdateOneRequiredWithoutCardInput = {
    create?: XOR<infopeopleCreateWithoutCardInput, infopeopleUncheckedCreateWithoutCardInput>
    connectOrCreate?: infopeopleCreateOrConnectWithoutCardInput
    upsert?: infopeopleUpsertWithoutCardInput
    connect?: infopeopleWhereUniqueInput
    update?: XOR<infopeopleUpdateWithoutCardInput, infopeopleUncheckedUpdateWithoutCardInput>
  }

  export type clubCreateNestedManyWithoutCashInput = {
    create?: XOR<Enumerable<clubCreateWithoutCashInput>, Enumerable<clubUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutCashInput>
    createMany?: clubCreateManyCashInputEnvelope
    connect?: Enumerable<clubWhereUniqueInput>
  }

  export type productCreateNestedManyWithoutCashInput = {
    create?: XOR<Enumerable<productCreateWithoutCashInput>, Enumerable<productUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCashInput>
    createMany?: productCreateManyCashInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type clubUncheckedCreateNestedManyWithoutCashInput = {
    create?: XOR<Enumerable<clubCreateWithoutCashInput>, Enumerable<clubUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutCashInput>
    createMany?: clubCreateManyCashInputEnvelope
    connect?: Enumerable<clubWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutCashInput = {
    create?: XOR<Enumerable<productCreateWithoutCashInput>, Enumerable<productUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCashInput>
    createMany?: productCreateManyCashInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type clubUpdateManyWithoutCashInput = {
    create?: XOR<Enumerable<clubCreateWithoutCashInput>, Enumerable<clubUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutCashInput>
    upsert?: Enumerable<clubUpsertWithWhereUniqueWithoutCashInput>
    createMany?: clubCreateManyCashInputEnvelope
    set?: Enumerable<clubWhereUniqueInput>
    disconnect?: Enumerable<clubWhereUniqueInput>
    delete?: Enumerable<clubWhereUniqueInput>
    connect?: Enumerable<clubWhereUniqueInput>
    update?: Enumerable<clubUpdateWithWhereUniqueWithoutCashInput>
    updateMany?: Enumerable<clubUpdateManyWithWhereWithoutCashInput>
    deleteMany?: Enumerable<clubScalarWhereInput>
  }

  export type productUpdateManyWithoutCashInput = {
    create?: XOR<Enumerable<productCreateWithoutCashInput>, Enumerable<productUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCashInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutCashInput>
    createMany?: productCreateManyCashInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutCashInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutCashInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type clubUncheckedUpdateManyWithoutCashInput = {
    create?: XOR<Enumerable<clubCreateWithoutCashInput>, Enumerable<clubUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutCashInput>
    upsert?: Enumerable<clubUpsertWithWhereUniqueWithoutCashInput>
    createMany?: clubCreateManyCashInputEnvelope
    set?: Enumerable<clubWhereUniqueInput>
    disconnect?: Enumerable<clubWhereUniqueInput>
    delete?: Enumerable<clubWhereUniqueInput>
    connect?: Enumerable<clubWhereUniqueInput>
    update?: Enumerable<clubUpdateWithWhereUniqueWithoutCashInput>
    updateMany?: Enumerable<clubUpdateManyWithWhereWithoutCashInput>
    deleteMany?: Enumerable<clubScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutCashInput = {
    create?: XOR<Enumerable<productCreateWithoutCashInput>, Enumerable<productUncheckedCreateWithoutCashInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCashInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutCashInput>
    createMany?: productCreateManyCashInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutCashInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutCashInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type clientpeopleCreateNestedOneWithoutClientlocationInput = {
    create?: XOR<clientpeopleCreateWithoutClientlocationInput, clientpeopleUncheckedCreateWithoutClientlocationInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutClientlocationInput
    connect?: clientpeopleWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutClientlocationInput = {
    connect?: locationWhereUniqueInput
  }

  export type clientpeopleUpdateOneRequiredWithoutClientlocationInput = {
    create?: XOR<clientpeopleCreateWithoutClientlocationInput, clientpeopleUncheckedCreateWithoutClientlocationInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutClientlocationInput
    upsert?: clientpeopleUpsertWithoutClientlocationInput
    connect?: clientpeopleWhereUniqueInput
    update?: XOR<clientpeopleUpdateWithoutClientlocationInput, clientpeopleUncheckedUpdateWithoutClientlocationInput>
  }

  export type locationUpdateOneRequiredWithoutClientlocationInput = {
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutClientlocationInput, locationUncheckedUpdateWithoutClientlocationInput>
  }

  export type clientpeopleCreateNestedOneWithoutClientmembershipInput = {
    create?: XOR<clientpeopleCreateWithoutClientmembershipInput, clientpeopleUncheckedCreateWithoutClientmembershipInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutClientmembershipInput
    connect?: clientpeopleWhereUniqueInput
  }

  export type membershipCreateNestedOneWithoutClientmembershipInput = {
    create?: XOR<membershipCreateWithoutClientmembershipInput, membershipUncheckedCreateWithoutClientmembershipInput>
    connectOrCreate?: membershipCreateOrConnectWithoutClientmembershipInput
    connect?: membershipWhereUniqueInput
  }

  export type clientpeopleUpdateOneRequiredWithoutClientmembershipInput = {
    create?: XOR<clientpeopleCreateWithoutClientmembershipInput, clientpeopleUncheckedCreateWithoutClientmembershipInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutClientmembershipInput
    upsert?: clientpeopleUpsertWithoutClientmembershipInput
    connect?: clientpeopleWhereUniqueInput
    update?: XOR<clientpeopleUpdateWithoutClientmembershipInput, clientpeopleUncheckedUpdateWithoutClientmembershipInput>
  }

  export type membershipUpdateOneRequiredWithoutClientmembershipInput = {
    create?: XOR<membershipCreateWithoutClientmembershipInput, membershipUncheckedCreateWithoutClientmembershipInput>
    connectOrCreate?: membershipCreateOrConnectWithoutClientmembershipInput
    upsert?: membershipUpsertWithoutClientmembershipInput
    connect?: membershipWhereUniqueInput
    update?: XOR<membershipUpdateWithoutClientmembershipInput, membershipUncheckedUpdateWithoutClientmembershipInput>
  }

  export type clientuserCreateNestedOneWithoutClientpeopleInput = {
    create?: XOR<clientuserCreateWithoutClientpeopleInput, clientuserUncheckedCreateWithoutClientpeopleInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutClientpeopleInput
    connect?: clientuserWhereUniqueInput
  }

  export type infopeopleCreateNestedOneWithoutClientpeopleInput = {
    create?: XOR<infopeopleCreateWithoutClientpeopleInput, infopeopleUncheckedCreateWithoutClientpeopleInput>
    connectOrCreate?: infopeopleCreateOrConnectWithoutClientpeopleInput
    connect?: infopeopleWhereUniqueInput
  }

  export type clientlocationCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutClientpeopleInput>, Enumerable<clientlocationUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutClientpeopleInput>
    createMany?: clientlocationCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<clientlocationWhereUniqueInput>
  }

  export type clientmembershipCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutClientpeopleInput>, Enumerable<clientmembershipUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutClientpeopleInput>
    createMany?: clientmembershipCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<clientmembershipWhereUniqueInput>
  }

  export type orderpCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClientpeopleInput>, Enumerable<orderpUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClientpeopleInput>
    createMany?: orderpCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<orderpWhereUniqueInput>
  }

  export type clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutClientpeopleInput>, Enumerable<clientlocationUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutClientpeopleInput>
    createMany?: clientlocationCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<clientlocationWhereUniqueInput>
  }

  export type clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutClientpeopleInput>, Enumerable<clientmembershipUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutClientpeopleInput>
    createMany?: clientmembershipCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<clientmembershipWhereUniqueInput>
  }

  export type orderpUncheckedCreateNestedManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClientpeopleInput>, Enumerable<orderpUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClientpeopleInput>
    createMany?: orderpCreateManyClientpeopleInputEnvelope
    connect?: Enumerable<orderpWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type clientuserUpdateOneRequiredWithoutClientpeopleInput = {
    create?: XOR<clientuserCreateWithoutClientpeopleInput, clientuserUncheckedCreateWithoutClientpeopleInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutClientpeopleInput
    upsert?: clientuserUpsertWithoutClientpeopleInput
    connect?: clientuserWhereUniqueInput
    update?: XOR<clientuserUpdateWithoutClientpeopleInput, clientuserUncheckedUpdateWithoutClientpeopleInput>
  }

  export type infopeopleUpdateOneRequiredWithoutClientpeopleInput = {
    create?: XOR<infopeopleCreateWithoutClientpeopleInput, infopeopleUncheckedCreateWithoutClientpeopleInput>
    connectOrCreate?: infopeopleCreateOrConnectWithoutClientpeopleInput
    upsert?: infopeopleUpsertWithoutClientpeopleInput
    connect?: infopeopleWhereUniqueInput
    update?: XOR<infopeopleUpdateWithoutClientpeopleInput, infopeopleUncheckedUpdateWithoutClientpeopleInput>
  }

  export type clientlocationUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutClientpeopleInput>, Enumerable<clientlocationUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<clientlocationUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: clientlocationCreateManyClientpeopleInputEnvelope
    set?: Enumerable<clientlocationWhereUniqueInput>
    disconnect?: Enumerable<clientlocationWhereUniqueInput>
    delete?: Enumerable<clientlocationWhereUniqueInput>
    connect?: Enumerable<clientlocationWhereUniqueInput>
    update?: Enumerable<clientlocationUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<clientlocationUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<clientlocationScalarWhereInput>
  }

  export type clientmembershipUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutClientpeopleInput>, Enumerable<clientmembershipUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<clientmembershipUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: clientmembershipCreateManyClientpeopleInputEnvelope
    set?: Enumerable<clientmembershipWhereUniqueInput>
    disconnect?: Enumerable<clientmembershipWhereUniqueInput>
    delete?: Enumerable<clientmembershipWhereUniqueInput>
    connect?: Enumerable<clientmembershipWhereUniqueInput>
    update?: Enumerable<clientmembershipUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<clientmembershipUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<clientmembershipScalarWhereInput>
  }

  export type orderpUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClientpeopleInput>, Enumerable<orderpUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<orderpUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: orderpCreateManyClientpeopleInputEnvelope
    set?: Enumerable<orderpWhereUniqueInput>
    disconnect?: Enumerable<orderpWhereUniqueInput>
    delete?: Enumerable<orderpWhereUniqueInput>
    connect?: Enumerable<orderpWhereUniqueInput>
    update?: Enumerable<orderpUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<orderpUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<orderpScalarWhereInput>
  }

  export type clientlocationUncheckedUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutClientpeopleInput>, Enumerable<clientlocationUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<clientlocationUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: clientlocationCreateManyClientpeopleInputEnvelope
    set?: Enumerable<clientlocationWhereUniqueInput>
    disconnect?: Enumerable<clientlocationWhereUniqueInput>
    delete?: Enumerable<clientlocationWhereUniqueInput>
    connect?: Enumerable<clientlocationWhereUniqueInput>
    update?: Enumerable<clientlocationUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<clientlocationUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<clientlocationScalarWhereInput>
  }

  export type clientmembershipUncheckedUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutClientpeopleInput>, Enumerable<clientmembershipUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<clientmembershipUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: clientmembershipCreateManyClientpeopleInputEnvelope
    set?: Enumerable<clientmembershipWhereUniqueInput>
    disconnect?: Enumerable<clientmembershipWhereUniqueInput>
    delete?: Enumerable<clientmembershipWhereUniqueInput>
    connect?: Enumerable<clientmembershipWhereUniqueInput>
    update?: Enumerable<clientmembershipUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<clientmembershipUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<clientmembershipScalarWhereInput>
  }

  export type orderpUncheckedUpdateManyWithoutClientpeopleInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClientpeopleInput>, Enumerable<orderpUncheckedCreateWithoutClientpeopleInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClientpeopleInput>
    upsert?: Enumerable<orderpUpsertWithWhereUniqueWithoutClientpeopleInput>
    createMany?: orderpCreateManyClientpeopleInputEnvelope
    set?: Enumerable<orderpWhereUniqueInput>
    disconnect?: Enumerable<orderpWhereUniqueInput>
    delete?: Enumerable<orderpWhereUniqueInput>
    connect?: Enumerable<orderpWhereUniqueInput>
    update?: Enumerable<orderpUpdateWithWhereUniqueWithoutClientpeopleInput>
    updateMany?: Enumerable<orderpUpdateManyWithWhereWithoutClientpeopleInput>
    deleteMany?: Enumerable<orderpScalarWhereInput>
  }

  export type clientpeopleCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutClientuserInput>, Enumerable<clientpeopleUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutClientuserInput>
    createMany?: clientpeopleCreateManyClientuserInputEnvelope
    connect?: Enumerable<clientpeopleWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClientuserInput>, Enumerable<reviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClientuserInput>
    createMany?: reviewCreateManyClientuserInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type workerreviewCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<workerreviewCreateWithoutClientuserInput>, Enumerable<workerreviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<workerreviewCreateOrConnectWithoutClientuserInput>
    createMany?: workerreviewCreateManyClientuserInputEnvelope
    connect?: Enumerable<workerreviewWhereUniqueInput>
  }

  export type clientpeopleUncheckedCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutClientuserInput>, Enumerable<clientpeopleUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutClientuserInput>
    createMany?: clientpeopleCreateManyClientuserInputEnvelope
    connect?: Enumerable<clientpeopleWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClientuserInput>, Enumerable<reviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClientuserInput>
    createMany?: reviewCreateManyClientuserInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type workerreviewUncheckedCreateNestedManyWithoutClientuserInput = {
    create?: XOR<Enumerable<workerreviewCreateWithoutClientuserInput>, Enumerable<workerreviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<workerreviewCreateOrConnectWithoutClientuserInput>
    createMany?: workerreviewCreateManyClientuserInputEnvelope
    connect?: Enumerable<workerreviewWhereUniqueInput>
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type clientpeopleUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutClientuserInput>, Enumerable<clientpeopleUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<clientpeopleUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: clientpeopleCreateManyClientuserInputEnvelope
    set?: Enumerable<clientpeopleWhereUniqueInput>
    disconnect?: Enumerable<clientpeopleWhereUniqueInput>
    delete?: Enumerable<clientpeopleWhereUniqueInput>
    connect?: Enumerable<clientpeopleWhereUniqueInput>
    update?: Enumerable<clientpeopleUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<clientpeopleUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<clientpeopleScalarWhereInput>
  }

  export type reviewUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClientuserInput>, Enumerable<reviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: reviewCreateManyClientuserInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type workerreviewUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<workerreviewCreateWithoutClientuserInput>, Enumerable<workerreviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<workerreviewCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<workerreviewUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: workerreviewCreateManyClientuserInputEnvelope
    set?: Enumerable<workerreviewWhereUniqueInput>
    disconnect?: Enumerable<workerreviewWhereUniqueInput>
    delete?: Enumerable<workerreviewWhereUniqueInput>
    connect?: Enumerable<workerreviewWhereUniqueInput>
    update?: Enumerable<workerreviewUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<workerreviewUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<workerreviewScalarWhereInput>
  }

  export type clientpeopleUncheckedUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutClientuserInput>, Enumerable<clientpeopleUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<clientpeopleUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: clientpeopleCreateManyClientuserInputEnvelope
    set?: Enumerable<clientpeopleWhereUniqueInput>
    disconnect?: Enumerable<clientpeopleWhereUniqueInput>
    delete?: Enumerable<clientpeopleWhereUniqueInput>
    connect?: Enumerable<clientpeopleWhereUniqueInput>
    update?: Enumerable<clientpeopleUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<clientpeopleUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<clientpeopleScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutClientuserInput>, Enumerable<reviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: reviewCreateManyClientuserInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type workerreviewUncheckedUpdateManyWithoutClientuserInput = {
    create?: XOR<Enumerable<workerreviewCreateWithoutClientuserInput>, Enumerable<workerreviewUncheckedCreateWithoutClientuserInput>>
    connectOrCreate?: Enumerable<workerreviewCreateOrConnectWithoutClientuserInput>
    upsert?: Enumerable<workerreviewUpsertWithWhereUniqueWithoutClientuserInput>
    createMany?: workerreviewCreateManyClientuserInputEnvelope
    set?: Enumerable<workerreviewWhereUniqueInput>
    disconnect?: Enumerable<workerreviewWhereUniqueInput>
    delete?: Enumerable<workerreviewWhereUniqueInput>
    connect?: Enumerable<workerreviewWhereUniqueInput>
    update?: Enumerable<workerreviewUpdateWithWhereUniqueWithoutClientuserInput>
    updateMany?: Enumerable<workerreviewUpdateManyWithWhereWithoutClientuserInput>
    deleteMany?: Enumerable<workerreviewScalarWhereInput>
  }

  export type cashCreateNestedOneWithoutClubInput = {
    create?: XOR<cashCreateWithoutClubInput, cashUncheckedCreateWithoutClubInput>
    connectOrCreate?: cashCreateOrConnectWithoutClubInput
    connect?: cashWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutClubInput = {
    connect?: locationWhereUniqueInput
  }

  export type inventoryCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutClubInput>, Enumerable<inventoryUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutClubInput>
    createMany?: inventoryCreateManyClubInputEnvelope
    connect?: Enumerable<inventoryWhereUniqueInput>
  }

  export type orderpCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClubInput>, Enumerable<orderpUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClubInput>
    createMany?: orderpCreateManyClubInputEnvelope
    connect?: Enumerable<orderpWhereUniqueInput>
  }

  export type popularproductsCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutClubInput>, Enumerable<popularproductsUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutClubInput>
    createMany?: popularproductsCreateManyClubInputEnvelope
    connect?: Enumerable<popularproductsWhereUniqueInput>
  }

  export type inventoryUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutClubInput>, Enumerable<inventoryUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutClubInput>
    createMany?: inventoryCreateManyClubInputEnvelope
    connect?: Enumerable<inventoryWhereUniqueInput>
  }

  export type orderpUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClubInput>, Enumerable<orderpUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClubInput>
    createMany?: orderpCreateManyClubInputEnvelope
    connect?: Enumerable<orderpWhereUniqueInput>
  }

  export type popularproductsUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutClubInput>, Enumerable<popularproductsUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutClubInput>
    createMany?: popularproductsCreateManyClubInputEnvelope
    connect?: Enumerable<popularproductsWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cashUpdateOneRequiredWithoutClubInput = {
    create?: XOR<cashCreateWithoutClubInput, cashUncheckedCreateWithoutClubInput>
    connectOrCreate?: cashCreateOrConnectWithoutClubInput
    upsert?: cashUpsertWithoutClubInput
    connect?: cashWhereUniqueInput
    update?: XOR<cashUpdateWithoutClubInput, cashUncheckedUpdateWithoutClubInput>
  }

  export type locationUpdateOneRequiredWithoutClubInput = {
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutClubInput, locationUncheckedUpdateWithoutClubInput>
  }

  export type inventoryUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutClubInput>, Enumerable<inventoryUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<inventoryUpsertWithWhereUniqueWithoutClubInput>
    createMany?: inventoryCreateManyClubInputEnvelope
    set?: Enumerable<inventoryWhereUniqueInput>
    disconnect?: Enumerable<inventoryWhereUniqueInput>
    delete?: Enumerable<inventoryWhereUniqueInput>
    connect?: Enumerable<inventoryWhereUniqueInput>
    update?: Enumerable<inventoryUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<inventoryUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<inventoryScalarWhereInput>
  }

  export type orderpUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClubInput>, Enumerable<orderpUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<orderpUpsertWithWhereUniqueWithoutClubInput>
    createMany?: orderpCreateManyClubInputEnvelope
    set?: Enumerable<orderpWhereUniqueInput>
    disconnect?: Enumerable<orderpWhereUniqueInput>
    delete?: Enumerable<orderpWhereUniqueInput>
    connect?: Enumerable<orderpWhereUniqueInput>
    update?: Enumerable<orderpUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<orderpUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<orderpScalarWhereInput>
  }

  export type popularproductsUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutClubInput>, Enumerable<popularproductsUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<popularproductsUpsertWithWhereUniqueWithoutClubInput>
    createMany?: popularproductsCreateManyClubInputEnvelope
    set?: Enumerable<popularproductsWhereUniqueInput>
    disconnect?: Enumerable<popularproductsWhereUniqueInput>
    delete?: Enumerable<popularproductsWhereUniqueInput>
    connect?: Enumerable<popularproductsWhereUniqueInput>
    update?: Enumerable<popularproductsUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<popularproductsUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<popularproductsScalarWhereInput>
  }

  export type inventoryUncheckedUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutClubInput>, Enumerable<inventoryUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<inventoryUpsertWithWhereUniqueWithoutClubInput>
    createMany?: inventoryCreateManyClubInputEnvelope
    set?: Enumerable<inventoryWhereUniqueInput>
    disconnect?: Enumerable<inventoryWhereUniqueInput>
    delete?: Enumerable<inventoryWhereUniqueInput>
    connect?: Enumerable<inventoryWhereUniqueInput>
    update?: Enumerable<inventoryUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<inventoryUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<inventoryScalarWhereInput>
  }

  export type orderpUncheckedUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<orderpCreateWithoutClubInput>, Enumerable<orderpUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<orderpCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<orderpUpsertWithWhereUniqueWithoutClubInput>
    createMany?: orderpCreateManyClubInputEnvelope
    set?: Enumerable<orderpWhereUniqueInput>
    disconnect?: Enumerable<orderpWhereUniqueInput>
    delete?: Enumerable<orderpWhereUniqueInput>
    connect?: Enumerable<orderpWhereUniqueInput>
    update?: Enumerable<orderpUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<orderpUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<orderpScalarWhereInput>
  }

  export type popularproductsUncheckedUpdateManyWithoutClubInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutClubInput>, Enumerable<popularproductsUncheckedCreateWithoutClubInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutClubInput>
    upsert?: Enumerable<popularproductsUpsertWithWhereUniqueWithoutClubInput>
    createMany?: popularproductsCreateManyClubInputEnvelope
    set?: Enumerable<popularproductsWhereUniqueInput>
    disconnect?: Enumerable<popularproductsWhereUniqueInput>
    delete?: Enumerable<popularproductsWhereUniqueInput>
    connect?: Enumerable<popularproductsWhereUniqueInput>
    update?: Enumerable<popularproductsUpdateWithWhereUniqueWithoutClubInput>
    updateMany?: Enumerable<popularproductsUpdateManyWithWhereWithoutClubInput>
    deleteMany?: Enumerable<popularproductsScalarWhereInput>
  }

  export type workerreviewCreateNestedOneWithoutComplaintInput = {
    create?: XOR<workerreviewCreateWithoutComplaintInput, workerreviewUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: workerreviewCreateOrConnectWithoutComplaintInput
    connect?: workerreviewWhereUniqueInput
  }

  export type workerreviewUpdateOneRequiredWithoutComplaintInput = {
    create?: XOR<workerreviewCreateWithoutComplaintInput, workerreviewUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: workerreviewCreateOrConnectWithoutComplaintInput
    upsert?: workerreviewUpsertWithoutComplaintInput
    connect?: workerreviewWhereUniqueInput
    update?: XOR<workerreviewUpdateWithoutComplaintInput, workerreviewUncheckedUpdateWithoutComplaintInput>
  }

  export type cardCreateNestedManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<cardCreateWithoutInfopeopleInput>, Enumerable<cardUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutInfopeopleInput>
    createMany?: cardCreateManyInfopeopleInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type clientpeopleCreateNestedManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutInfopeopleInput>, Enumerable<clientpeopleUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutInfopeopleInput>
    createMany?: clientpeopleCreateManyInfopeopleInputEnvelope
    connect?: Enumerable<clientpeopleWhereUniqueInput>
  }

  export type cardUncheckedCreateNestedManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<cardCreateWithoutInfopeopleInput>, Enumerable<cardUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutInfopeopleInput>
    createMany?: cardCreateManyInfopeopleInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type clientpeopleUncheckedCreateNestedManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutInfopeopleInput>, Enumerable<clientpeopleUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutInfopeopleInput>
    createMany?: clientpeopleCreateManyInfopeopleInputEnvelope
    connect?: Enumerable<clientpeopleWhereUniqueInput>
  }

  export type cardUpdateManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<cardCreateWithoutInfopeopleInput>, Enumerable<cardUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutInfopeopleInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutInfopeopleInput>
    createMany?: cardCreateManyInfopeopleInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutInfopeopleInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutInfopeopleInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type clientpeopleUpdateManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutInfopeopleInput>, Enumerable<clientpeopleUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutInfopeopleInput>
    upsert?: Enumerable<clientpeopleUpsertWithWhereUniqueWithoutInfopeopleInput>
    createMany?: clientpeopleCreateManyInfopeopleInputEnvelope
    set?: Enumerable<clientpeopleWhereUniqueInput>
    disconnect?: Enumerable<clientpeopleWhereUniqueInput>
    delete?: Enumerable<clientpeopleWhereUniqueInput>
    connect?: Enumerable<clientpeopleWhereUniqueInput>
    update?: Enumerable<clientpeopleUpdateWithWhereUniqueWithoutInfopeopleInput>
    updateMany?: Enumerable<clientpeopleUpdateManyWithWhereWithoutInfopeopleInput>
    deleteMany?: Enumerable<clientpeopleScalarWhereInput>
  }

  export type cardUncheckedUpdateManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<cardCreateWithoutInfopeopleInput>, Enumerable<cardUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutInfopeopleInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutInfopeopleInput>
    createMany?: cardCreateManyInfopeopleInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutInfopeopleInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutInfopeopleInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type clientpeopleUncheckedUpdateManyWithoutInfopeopleInput = {
    create?: XOR<Enumerable<clientpeopleCreateWithoutInfopeopleInput>, Enumerable<clientpeopleUncheckedCreateWithoutInfopeopleInput>>
    connectOrCreate?: Enumerable<clientpeopleCreateOrConnectWithoutInfopeopleInput>
    upsert?: Enumerable<clientpeopleUpsertWithWhereUniqueWithoutInfopeopleInput>
    createMany?: clientpeopleCreateManyInfopeopleInputEnvelope
    set?: Enumerable<clientpeopleWhereUniqueInput>
    disconnect?: Enumerable<clientpeopleWhereUniqueInput>
    delete?: Enumerable<clientpeopleWhereUniqueInput>
    connect?: Enumerable<clientpeopleWhereUniqueInput>
    update?: Enumerable<clientpeopleUpdateWithWhereUniqueWithoutInfopeopleInput>
    updateMany?: Enumerable<clientpeopleUpdateManyWithWhereWithoutInfopeopleInput>
    deleteMany?: Enumerable<clientpeopleScalarWhereInput>
  }

  export type clubCreateNestedOneWithoutInventoryInput = {
    create?: XOR<clubCreateWithoutInventoryInput, clubUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: clubCreateOrConnectWithoutInventoryInput
    connect?: clubWhereUniqueInput
  }

  export type productCreateNestedOneWithoutInventoryInput = {
    create?: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productCreateOrConnectWithoutInventoryInput
    connect?: productWhereUniqueInput
  }

  export type clubUpdateOneRequiredWithoutInventoryInput = {
    create?: XOR<clubCreateWithoutInventoryInput, clubUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: clubCreateOrConnectWithoutInventoryInput
    upsert?: clubUpsertWithoutInventoryInput
    connect?: clubWhereUniqueInput
    update?: XOR<clubUpdateWithoutInventoryInput, clubUncheckedUpdateWithoutInventoryInput>
  }

  export type productUpdateOneRequiredWithoutInventoryInput = {
    create?: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productCreateOrConnectWithoutInventoryInput
    upsert?: productUpsertWithoutInventoryInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutInventoryInput, productUncheckedUpdateWithoutInventoryInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type clientlocationUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutLocationInput>, Enumerable<clientlocationUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<clientlocationUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: clientlocationCreateManyLocationInputEnvelope
    set?: Enumerable<clientlocationWhereUniqueInput>
    disconnect?: Enumerable<clientlocationWhereUniqueInput>
    delete?: Enumerable<clientlocationWhereUniqueInput>
    connect?: Enumerable<clientlocationWhereUniqueInput>
    update?: Enumerable<clientlocationUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<clientlocationUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<clientlocationScalarWhereInput>
  }

  export type clubUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<clubCreateWithoutLocationInput>, Enumerable<clubUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<clubUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: clubCreateManyLocationInputEnvelope
    set?: Enumerable<clubWhereUniqueInput>
    disconnect?: Enumerable<clubWhereUniqueInput>
    delete?: Enumerable<clubWhereUniqueInput>
    connect?: Enumerable<clubWhereUniqueInput>
    update?: Enumerable<clubUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<clubUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<clubScalarWhereInput>
  }

  export type clientlocationUncheckedUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<clientlocationCreateWithoutLocationInput>, Enumerable<clientlocationUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<clientlocationCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<clientlocationUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: clientlocationCreateManyLocationInputEnvelope
    set?: Enumerable<clientlocationWhereUniqueInput>
    disconnect?: Enumerable<clientlocationWhereUniqueInput>
    delete?: Enumerable<clientlocationWhereUniqueInput>
    connect?: Enumerable<clientlocationWhereUniqueInput>
    update?: Enumerable<clientlocationUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<clientlocationUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<clientlocationScalarWhereInput>
  }

  export type clubUncheckedUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<clubCreateWithoutLocationInput>, Enumerable<clubUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<clubCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<clubUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: clubCreateManyLocationInputEnvelope
    set?: Enumerable<clubWhereUniqueInput>
    disconnect?: Enumerable<clubWhereUniqueInput>
    delete?: Enumerable<clubWhereUniqueInput>
    connect?: Enumerable<clubWhereUniqueInput>
    update?: Enumerable<clubUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<clubUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<clubScalarWhereInput>
  }

  export type clientmembershipCreateNestedManyWithoutMembershipInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutMembershipInput>, Enumerable<clientmembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutMembershipInput>
    createMany?: clientmembershipCreateManyMembershipInputEnvelope
    connect?: Enumerable<clientmembershipWhereUniqueInput>
  }

  export type clientmembershipUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutMembershipInput>, Enumerable<clientmembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutMembershipInput>
    createMany?: clientmembershipCreateManyMembershipInputEnvelope
    connect?: Enumerable<clientmembershipWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type clientmembershipUpdateManyWithoutMembershipInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutMembershipInput>, Enumerable<clientmembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutMembershipInput>
    upsert?: Enumerable<clientmembershipUpsertWithWhereUniqueWithoutMembershipInput>
    createMany?: clientmembershipCreateManyMembershipInputEnvelope
    set?: Enumerable<clientmembershipWhereUniqueInput>
    disconnect?: Enumerable<clientmembershipWhereUniqueInput>
    delete?: Enumerable<clientmembershipWhereUniqueInput>
    connect?: Enumerable<clientmembershipWhereUniqueInput>
    update?: Enumerable<clientmembershipUpdateWithWhereUniqueWithoutMembershipInput>
    updateMany?: Enumerable<clientmembershipUpdateManyWithWhereWithoutMembershipInput>
    deleteMany?: Enumerable<clientmembershipScalarWhereInput>
  }

  export type clientmembershipUncheckedUpdateManyWithoutMembershipInput = {
    create?: XOR<Enumerable<clientmembershipCreateWithoutMembershipInput>, Enumerable<clientmembershipUncheckedCreateWithoutMembershipInput>>
    connectOrCreate?: Enumerable<clientmembershipCreateOrConnectWithoutMembershipInput>
    upsert?: Enumerable<clientmembershipUpsertWithWhereUniqueWithoutMembershipInput>
    createMany?: clientmembershipCreateManyMembershipInputEnvelope
    set?: Enumerable<clientmembershipWhereUniqueInput>
    disconnect?: Enumerable<clientmembershipWhereUniqueInput>
    delete?: Enumerable<clientmembershipWhereUniqueInput>
    connect?: Enumerable<clientmembershipWhereUniqueInput>
    update?: Enumerable<clientmembershipUpdateWithWhereUniqueWithoutMembershipInput>
    updateMany?: Enumerable<clientmembershipUpdateManyWithWhereWithoutMembershipInput>
    deleteMany?: Enumerable<clientmembershipScalarWhereInput>
  }

  export type orderpCreateNestedOneWithoutOrderlineInput = {
    create?: XOR<orderpCreateWithoutOrderlineInput, orderpUncheckedCreateWithoutOrderlineInput>
    connectOrCreate?: orderpCreateOrConnectWithoutOrderlineInput
    connect?: orderpWhereUniqueInput
  }

  export type productCreateNestedOneWithoutOrderlineInput = {
    create?: XOR<productCreateWithoutOrderlineInput, productUncheckedCreateWithoutOrderlineInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderlineInput
    connect?: productWhereUniqueInput
  }

  export type orderpUpdateOneRequiredWithoutOrderlineInput = {
    create?: XOR<orderpCreateWithoutOrderlineInput, orderpUncheckedCreateWithoutOrderlineInput>
    connectOrCreate?: orderpCreateOrConnectWithoutOrderlineInput
    upsert?: orderpUpsertWithoutOrderlineInput
    connect?: orderpWhereUniqueInput
    update?: XOR<orderpUpdateWithoutOrderlineInput, orderpUncheckedUpdateWithoutOrderlineInput>
  }

  export type productUpdateOneRequiredWithoutOrderlineInput = {
    create?: XOR<productCreateWithoutOrderlineInput, productUncheckedCreateWithoutOrderlineInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderlineInput
    upsert?: productUpsertWithoutOrderlineInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutOrderlineInput, productUncheckedUpdateWithoutOrderlineInput>
  }

  export type clientpeopleCreateNestedOneWithoutOrderpInput = {
    create?: XOR<clientpeopleCreateWithoutOrderpInput, clientpeopleUncheckedCreateWithoutOrderpInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutOrderpInput
    connect?: clientpeopleWhereUniqueInput
  }

  export type clubCreateNestedOneWithoutOrderpInput = {
    create?: XOR<clubCreateWithoutOrderpInput, clubUncheckedCreateWithoutOrderpInput>
    connectOrCreate?: clubCreateOrConnectWithoutOrderpInput
    connect?: clubWhereUniqueInput
  }

  export type orderlineCreateNestedManyWithoutOrderpInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutOrderpInput>, Enumerable<orderlineUncheckedCreateWithoutOrderpInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutOrderpInput>
    createMany?: orderlineCreateManyOrderpInputEnvelope
    connect?: Enumerable<orderlineWhereUniqueInput>
  }

  export type orderlineUncheckedCreateNestedManyWithoutOrderpInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutOrderpInput>, Enumerable<orderlineUncheckedCreateWithoutOrderpInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutOrderpInput>
    createMany?: orderlineCreateManyOrderpInputEnvelope
    connect?: Enumerable<orderlineWhereUniqueInput>
  }

  export type clientpeopleUpdateOneRequiredWithoutOrderpInput = {
    create?: XOR<clientpeopleCreateWithoutOrderpInput, clientpeopleUncheckedCreateWithoutOrderpInput>
    connectOrCreate?: clientpeopleCreateOrConnectWithoutOrderpInput
    upsert?: clientpeopleUpsertWithoutOrderpInput
    connect?: clientpeopleWhereUniqueInput
    update?: XOR<clientpeopleUpdateWithoutOrderpInput, clientpeopleUncheckedUpdateWithoutOrderpInput>
  }

  export type clubUpdateOneRequiredWithoutOrderpInput = {
    create?: XOR<clubCreateWithoutOrderpInput, clubUncheckedCreateWithoutOrderpInput>
    connectOrCreate?: clubCreateOrConnectWithoutOrderpInput
    upsert?: clubUpsertWithoutOrderpInput
    connect?: clubWhereUniqueInput
    update?: XOR<clubUpdateWithoutOrderpInput, clubUncheckedUpdateWithoutOrderpInput>
  }

  export type orderlineUpdateManyWithoutOrderpInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutOrderpInput>, Enumerable<orderlineUncheckedCreateWithoutOrderpInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutOrderpInput>
    upsert?: Enumerable<orderlineUpsertWithWhereUniqueWithoutOrderpInput>
    createMany?: orderlineCreateManyOrderpInputEnvelope
    set?: Enumerable<orderlineWhereUniqueInput>
    disconnect?: Enumerable<orderlineWhereUniqueInput>
    delete?: Enumerable<orderlineWhereUniqueInput>
    connect?: Enumerable<orderlineWhereUniqueInput>
    update?: Enumerable<orderlineUpdateWithWhereUniqueWithoutOrderpInput>
    updateMany?: Enumerable<orderlineUpdateManyWithWhereWithoutOrderpInput>
    deleteMany?: Enumerable<orderlineScalarWhereInput>
  }

  export type orderlineUncheckedUpdateManyWithoutOrderpInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutOrderpInput>, Enumerable<orderlineUncheckedCreateWithoutOrderpInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutOrderpInput>
    upsert?: Enumerable<orderlineUpsertWithWhereUniqueWithoutOrderpInput>
    createMany?: orderlineCreateManyOrderpInputEnvelope
    set?: Enumerable<orderlineWhereUniqueInput>
    disconnect?: Enumerable<orderlineWhereUniqueInput>
    delete?: Enumerable<orderlineWhereUniqueInput>
    connect?: Enumerable<orderlineWhereUniqueInput>
    update?: Enumerable<orderlineUpdateWithWhereUniqueWithoutOrderpInput>
    updateMany?: Enumerable<orderlineUpdateManyWithWhereWithoutOrderpInput>
    deleteMany?: Enumerable<orderlineScalarWhereInput>
  }

  export type clubCreateNestedOneWithoutPopularproductsInput = {
    create?: XOR<clubCreateWithoutPopularproductsInput, clubUncheckedCreateWithoutPopularproductsInput>
    connectOrCreate?: clubCreateOrConnectWithoutPopularproductsInput
    connect?: clubWhereUniqueInput
  }

  export type productCreateNestedOneWithoutPopularproductsInput = {
    create?: XOR<productCreateWithoutPopularproductsInput, productUncheckedCreateWithoutPopularproductsInput>
    connectOrCreate?: productCreateOrConnectWithoutPopularproductsInput
    connect?: productWhereUniqueInput
  }

  export type clubUpdateOneRequiredWithoutPopularproductsInput = {
    create?: XOR<clubCreateWithoutPopularproductsInput, clubUncheckedCreateWithoutPopularproductsInput>
    connectOrCreate?: clubCreateOrConnectWithoutPopularproductsInput
    upsert?: clubUpsertWithoutPopularproductsInput
    connect?: clubWhereUniqueInput
    update?: XOR<clubUpdateWithoutPopularproductsInput, clubUncheckedUpdateWithoutPopularproductsInput>
  }

  export type productUpdateOneRequiredWithoutPopularproductsInput = {
    create?: XOR<productCreateWithoutPopularproductsInput, productUncheckedCreateWithoutPopularproductsInput>
    connectOrCreate?: productCreateOrConnectWithoutPopularproductsInput
    upsert?: productUpsertWithoutPopularproductsInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutPopularproductsInput, productUncheckedUpdateWithoutPopularproductsInput>
  }

  export type productCreateNestedOneWithoutPresentationInput = {
    create?: XOR<productCreateWithoutPresentationInput, productUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: productCreateOrConnectWithoutPresentationInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutPresentationInput = {
    create?: XOR<productCreateWithoutPresentationInput, productUncheckedCreateWithoutPresentationInput>
    connectOrCreate?: productCreateOrConnectWithoutPresentationInput
    upsert?: productUpsertWithoutPresentationInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutPresentationInput, productUncheckedUpdateWithoutPresentationInput>
  }

  export type cashCreateNestedOneWithoutProductInput = {
    create?: XOR<cashCreateWithoutProductInput, cashUncheckedCreateWithoutProductInput>
    connectOrCreate?: cashCreateOrConnectWithoutProductInput
    connect?: cashWhereUniqueInput
  }

  export type producttypeCreateNestedOneWithoutProductInput = {
    create?: XOR<producttypeCreateWithoutProductInput, producttypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: producttypeCreateOrConnectWithoutProductInput
    connect?: producttypeWhereUniqueInput
  }

  export type supplierCreateNestedOneWithoutProductInput = {
    create?: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: supplierCreateOrConnectWithoutProductInput
    connect?: supplierWhereUniqueInput
  }

  export type inventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutProductInput>, Enumerable<inventoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutProductInput>
    createMany?: inventoryCreateManyProductInputEnvelope
    connect?: Enumerable<inventoryWhereUniqueInput>
  }

  export type orderlineCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutProductInput>, Enumerable<orderlineUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutProductInput>
    createMany?: orderlineCreateManyProductInputEnvelope
    connect?: Enumerable<orderlineWhereUniqueInput>
  }

  export type popularproductsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutProductInput>, Enumerable<popularproductsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutProductInput>
    createMany?: popularproductsCreateManyProductInputEnvelope
    connect?: Enumerable<popularproductsWhereUniqueInput>
  }

  export type presentationCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<presentationCreateWithoutProductInput>, Enumerable<presentationUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<presentationCreateOrConnectWithoutProductInput>
    createMany?: presentationCreateManyProductInputEnvelope
    connect?: Enumerable<presentationWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<reviewCreateWithoutProductInput>, Enumerable<reviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutProductInput>
    createMany?: reviewCreateManyProductInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type inventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutProductInput>, Enumerable<inventoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutProductInput>
    createMany?: inventoryCreateManyProductInputEnvelope
    connect?: Enumerable<inventoryWhereUniqueInput>
  }

  export type orderlineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutProductInput>, Enumerable<orderlineUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutProductInput>
    createMany?: orderlineCreateManyProductInputEnvelope
    connect?: Enumerable<orderlineWhereUniqueInput>
  }

  export type popularproductsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutProductInput>, Enumerable<popularproductsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutProductInput>
    createMany?: popularproductsCreateManyProductInputEnvelope
    connect?: Enumerable<popularproductsWhereUniqueInput>
  }

  export type presentationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<presentationCreateWithoutProductInput>, Enumerable<presentationUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<presentationCreateOrConnectWithoutProductInput>
    createMany?: presentationCreateManyProductInputEnvelope
    connect?: Enumerable<presentationWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<reviewCreateWithoutProductInput>, Enumerable<reviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutProductInput>
    createMany?: reviewCreateManyProductInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type cashUpdateOneRequiredWithoutProductInput = {
    create?: XOR<cashCreateWithoutProductInput, cashUncheckedCreateWithoutProductInput>
    connectOrCreate?: cashCreateOrConnectWithoutProductInput
    upsert?: cashUpsertWithoutProductInput
    connect?: cashWhereUniqueInput
    update?: XOR<cashUpdateWithoutProductInput, cashUncheckedUpdateWithoutProductInput>
  }

  export type producttypeUpdateOneRequiredWithoutProductInput = {
    create?: XOR<producttypeCreateWithoutProductInput, producttypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: producttypeCreateOrConnectWithoutProductInput
    upsert?: producttypeUpsertWithoutProductInput
    connect?: producttypeWhereUniqueInput
    update?: XOR<producttypeUpdateWithoutProductInput, producttypeUncheckedUpdateWithoutProductInput>
  }

  export type supplierUpdateOneRequiredWithoutProductInput = {
    create?: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
    connectOrCreate?: supplierCreateOrConnectWithoutProductInput
    upsert?: supplierUpsertWithoutProductInput
    connect?: supplierWhereUniqueInput
    update?: XOR<supplierUpdateWithoutProductInput, supplierUncheckedUpdateWithoutProductInput>
  }

  export type inventoryUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutProductInput>, Enumerable<inventoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<inventoryUpsertWithWhereUniqueWithoutProductInput>
    createMany?: inventoryCreateManyProductInputEnvelope
    set?: Enumerable<inventoryWhereUniqueInput>
    disconnect?: Enumerable<inventoryWhereUniqueInput>
    delete?: Enumerable<inventoryWhereUniqueInput>
    connect?: Enumerable<inventoryWhereUniqueInput>
    update?: Enumerable<inventoryUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<inventoryUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<inventoryScalarWhereInput>
  }

  export type orderlineUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutProductInput>, Enumerable<orderlineUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<orderlineUpsertWithWhereUniqueWithoutProductInput>
    createMany?: orderlineCreateManyProductInputEnvelope
    set?: Enumerable<orderlineWhereUniqueInput>
    disconnect?: Enumerable<orderlineWhereUniqueInput>
    delete?: Enumerable<orderlineWhereUniqueInput>
    connect?: Enumerable<orderlineWhereUniqueInput>
    update?: Enumerable<orderlineUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<orderlineUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<orderlineScalarWhereInput>
  }

  export type popularproductsUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutProductInput>, Enumerable<popularproductsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<popularproductsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: popularproductsCreateManyProductInputEnvelope
    set?: Enumerable<popularproductsWhereUniqueInput>
    disconnect?: Enumerable<popularproductsWhereUniqueInput>
    delete?: Enumerable<popularproductsWhereUniqueInput>
    connect?: Enumerable<popularproductsWhereUniqueInput>
    update?: Enumerable<popularproductsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<popularproductsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<popularproductsScalarWhereInput>
  }

  export type presentationUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<presentationCreateWithoutProductInput>, Enumerable<presentationUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<presentationCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<presentationUpsertWithWhereUniqueWithoutProductInput>
    createMany?: presentationCreateManyProductInputEnvelope
    set?: Enumerable<presentationWhereUniqueInput>
    disconnect?: Enumerable<presentationWhereUniqueInput>
    delete?: Enumerable<presentationWhereUniqueInput>
    connect?: Enumerable<presentationWhereUniqueInput>
    update?: Enumerable<presentationUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<presentationUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<presentationScalarWhereInput>
  }

  export type reviewUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<reviewCreateWithoutProductInput>, Enumerable<reviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: reviewCreateManyProductInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type inventoryUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<inventoryCreateWithoutProductInput>, Enumerable<inventoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<inventoryCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<inventoryUpsertWithWhereUniqueWithoutProductInput>
    createMany?: inventoryCreateManyProductInputEnvelope
    set?: Enumerable<inventoryWhereUniqueInput>
    disconnect?: Enumerable<inventoryWhereUniqueInput>
    delete?: Enumerable<inventoryWhereUniqueInput>
    connect?: Enumerable<inventoryWhereUniqueInput>
    update?: Enumerable<inventoryUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<inventoryUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<inventoryScalarWhereInput>
  }

  export type orderlineUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<orderlineCreateWithoutProductInput>, Enumerable<orderlineUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<orderlineCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<orderlineUpsertWithWhereUniqueWithoutProductInput>
    createMany?: orderlineCreateManyProductInputEnvelope
    set?: Enumerable<orderlineWhereUniqueInput>
    disconnect?: Enumerable<orderlineWhereUniqueInput>
    delete?: Enumerable<orderlineWhereUniqueInput>
    connect?: Enumerable<orderlineWhereUniqueInput>
    update?: Enumerable<orderlineUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<orderlineUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<orderlineScalarWhereInput>
  }

  export type popularproductsUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<popularproductsCreateWithoutProductInput>, Enumerable<popularproductsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<popularproductsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<popularproductsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: popularproductsCreateManyProductInputEnvelope
    set?: Enumerable<popularproductsWhereUniqueInput>
    disconnect?: Enumerable<popularproductsWhereUniqueInput>
    delete?: Enumerable<popularproductsWhereUniqueInput>
    connect?: Enumerable<popularproductsWhereUniqueInput>
    update?: Enumerable<popularproductsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<popularproductsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<popularproductsScalarWhereInput>
  }

  export type presentationUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<presentationCreateWithoutProductInput>, Enumerable<presentationUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<presentationCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<presentationUpsertWithWhereUniqueWithoutProductInput>
    createMany?: presentationCreateManyProductInputEnvelope
    set?: Enumerable<presentationWhereUniqueInput>
    disconnect?: Enumerable<presentationWhereUniqueInput>
    delete?: Enumerable<presentationWhereUniqueInput>
    connect?: Enumerable<presentationWhereUniqueInput>
    update?: Enumerable<presentationUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<presentationUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<presentationScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<reviewCreateWithoutProductInput>, Enumerable<reviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: reviewCreateManyProductInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type productCreateNestedManyWithoutProducttypeInput = {
    create?: XOR<Enumerable<productCreateWithoutProducttypeInput>, Enumerable<productUncheckedCreateWithoutProducttypeInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutProducttypeInput>
    createMany?: productCreateManyProducttypeInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutProducttypeInput = {
    create?: XOR<Enumerable<productCreateWithoutProducttypeInput>, Enumerable<productUncheckedCreateWithoutProducttypeInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutProducttypeInput>
    createMany?: productCreateManyProducttypeInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUpdateManyWithoutProducttypeInput = {
    create?: XOR<Enumerable<productCreateWithoutProducttypeInput>, Enumerable<productUncheckedCreateWithoutProducttypeInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutProducttypeInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutProducttypeInput>
    createMany?: productCreateManyProducttypeInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutProducttypeInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutProducttypeInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutProducttypeInput = {
    create?: XOR<Enumerable<productCreateWithoutProducttypeInput>, Enumerable<productUncheckedCreateWithoutProducttypeInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutProducttypeInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutProducttypeInput>
    createMany?: productCreateManyProducttypeInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutProducttypeInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutProducttypeInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type workerreviewCreateNestedOneWithoutQualificationInput = {
    create?: XOR<workerreviewCreateWithoutQualificationInput, workerreviewUncheckedCreateWithoutQualificationInput>
    connectOrCreate?: workerreviewCreateOrConnectWithoutQualificationInput
    connect?: workerreviewWhereUniqueInput
  }

  export type workerreviewUpdateOneRequiredWithoutQualificationInput = {
    create?: XOR<workerreviewCreateWithoutQualificationInput, workerreviewUncheckedCreateWithoutQualificationInput>
    connectOrCreate?: workerreviewCreateOrConnectWithoutQualificationInput
    upsert?: workerreviewUpsertWithoutQualificationInput
    connect?: workerreviewWhereUniqueInput
    update?: XOR<workerreviewUpdateWithoutQualificationInput, workerreviewUncheckedUpdateWithoutQualificationInput>
  }

  export type clientuserCreateNestedOneWithoutReviewInput = {
    create?: XOR<clientuserCreateWithoutReviewInput, clientuserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutReviewInput
    connect?: clientuserWhereUniqueInput
  }

  export type productCreateNestedOneWithoutReviewInput = {
    create?: XOR<productCreateWithoutReviewInput, productUncheckedCreateWithoutReviewInput>
    connectOrCreate?: productCreateOrConnectWithoutReviewInput
    connect?: productWhereUniqueInput
  }

  export type clientuserUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<clientuserCreateWithoutReviewInput, clientuserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutReviewInput
    upsert?: clientuserUpsertWithoutReviewInput
    connect?: clientuserWhereUniqueInput
    update?: XOR<clientuserUpdateWithoutReviewInput, clientuserUncheckedUpdateWithoutReviewInput>
  }

  export type productUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<productCreateWithoutReviewInput, productUncheckedCreateWithoutReviewInput>
    connectOrCreate?: productCreateOrConnectWithoutReviewInput
    upsert?: productUpsertWithoutReviewInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutReviewInput, productUncheckedUpdateWithoutReviewInput>
  }

  export type productCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productCreateWithoutSupplierInput>, Enumerable<productUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutSupplierInput>
    createMany?: productCreateManySupplierInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productCreateWithoutSupplierInput>, Enumerable<productUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutSupplierInput>
    createMany?: productCreateManySupplierInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productCreateWithoutSupplierInput>, Enumerable<productUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: productCreateManySupplierInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<productCreateWithoutSupplierInput>, Enumerable<productUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: productCreateManySupplierInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type clientuserCreateNestedOneWithoutWorkerreviewInput = {
    create?: XOR<clientuserCreateWithoutWorkerreviewInput, clientuserUncheckedCreateWithoutWorkerreviewInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutWorkerreviewInput
    connect?: clientuserWhereUniqueInput
  }

  export type complaintCreateNestedManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<complaintCreateWithoutWorkerreviewInput>, Enumerable<complaintUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<complaintCreateOrConnectWithoutWorkerreviewInput>
    createMany?: complaintCreateManyWorkerreviewInputEnvelope
    connect?: Enumerable<complaintWhereUniqueInput>
  }

  export type qualificationCreateNestedManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutWorkerreviewInput>, Enumerable<qualificationUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutWorkerreviewInput>
    createMany?: qualificationCreateManyWorkerreviewInputEnvelope
    connect?: Enumerable<qualificationWhereUniqueInput>
  }

  export type complaintUncheckedCreateNestedManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<complaintCreateWithoutWorkerreviewInput>, Enumerable<complaintUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<complaintCreateOrConnectWithoutWorkerreviewInput>
    createMany?: complaintCreateManyWorkerreviewInputEnvelope
    connect?: Enumerable<complaintWhereUniqueInput>
  }

  export type qualificationUncheckedCreateNestedManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutWorkerreviewInput>, Enumerable<qualificationUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutWorkerreviewInput>
    createMany?: qualificationCreateManyWorkerreviewInputEnvelope
    connect?: Enumerable<qualificationWhereUniqueInput>
  }

  export type clientuserUpdateOneRequiredWithoutWorkerreviewInput = {
    create?: XOR<clientuserCreateWithoutWorkerreviewInput, clientuserUncheckedCreateWithoutWorkerreviewInput>
    connectOrCreate?: clientuserCreateOrConnectWithoutWorkerreviewInput
    upsert?: clientuserUpsertWithoutWorkerreviewInput
    connect?: clientuserWhereUniqueInput
    update?: XOR<clientuserUpdateWithoutWorkerreviewInput, clientuserUncheckedUpdateWithoutWorkerreviewInput>
  }

  export type complaintUpdateManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<complaintCreateWithoutWorkerreviewInput>, Enumerable<complaintUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<complaintCreateOrConnectWithoutWorkerreviewInput>
    upsert?: Enumerable<complaintUpsertWithWhereUniqueWithoutWorkerreviewInput>
    createMany?: complaintCreateManyWorkerreviewInputEnvelope
    set?: Enumerable<complaintWhereUniqueInput>
    disconnect?: Enumerable<complaintWhereUniqueInput>
    delete?: Enumerable<complaintWhereUniqueInput>
    connect?: Enumerable<complaintWhereUniqueInput>
    update?: Enumerable<complaintUpdateWithWhereUniqueWithoutWorkerreviewInput>
    updateMany?: Enumerable<complaintUpdateManyWithWhereWithoutWorkerreviewInput>
    deleteMany?: Enumerable<complaintScalarWhereInput>
  }

  export type qualificationUpdateManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutWorkerreviewInput>, Enumerable<qualificationUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutWorkerreviewInput>
    upsert?: Enumerable<qualificationUpsertWithWhereUniqueWithoutWorkerreviewInput>
    createMany?: qualificationCreateManyWorkerreviewInputEnvelope
    set?: Enumerable<qualificationWhereUniqueInput>
    disconnect?: Enumerable<qualificationWhereUniqueInput>
    delete?: Enumerable<qualificationWhereUniqueInput>
    connect?: Enumerable<qualificationWhereUniqueInput>
    update?: Enumerable<qualificationUpdateWithWhereUniqueWithoutWorkerreviewInput>
    updateMany?: Enumerable<qualificationUpdateManyWithWhereWithoutWorkerreviewInput>
    deleteMany?: Enumerable<qualificationScalarWhereInput>
  }

  export type complaintUncheckedUpdateManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<complaintCreateWithoutWorkerreviewInput>, Enumerable<complaintUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<complaintCreateOrConnectWithoutWorkerreviewInput>
    upsert?: Enumerable<complaintUpsertWithWhereUniqueWithoutWorkerreviewInput>
    createMany?: complaintCreateManyWorkerreviewInputEnvelope
    set?: Enumerable<complaintWhereUniqueInput>
    disconnect?: Enumerable<complaintWhereUniqueInput>
    delete?: Enumerable<complaintWhereUniqueInput>
    connect?: Enumerable<complaintWhereUniqueInput>
    update?: Enumerable<complaintUpdateWithWhereUniqueWithoutWorkerreviewInput>
    updateMany?: Enumerable<complaintUpdateManyWithWhereWithoutWorkerreviewInput>
    deleteMany?: Enumerable<complaintScalarWhereInput>
  }

  export type qualificationUncheckedUpdateManyWithoutWorkerreviewInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutWorkerreviewInput>, Enumerable<qualificationUncheckedCreateWithoutWorkerreviewInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutWorkerreviewInput>
    upsert?: Enumerable<qualificationUpsertWithWhereUniqueWithoutWorkerreviewInput>
    createMany?: qualificationCreateManyWorkerreviewInputEnvelope
    set?: Enumerable<qualificationWhereUniqueInput>
    disconnect?: Enumerable<qualificationWhereUniqueInput>
    delete?: Enumerable<qualificationWhereUniqueInput>
    connect?: Enumerable<qualificationWhereUniqueInput>
    update?: Enumerable<qualificationUpdateWithWhereUniqueWithoutWorkerreviewInput>
    updateMany?: Enumerable<qualificationUpdateManyWithWhereWithoutWorkerreviewInput>
    deleteMany?: Enumerable<qualificationScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type infopeopleCreateWithoutCardInput = {
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    clientpeople?: clientpeopleCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedCreateWithoutCardInput = {
    idInfoPeople?: number
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    clientpeople?: clientpeopleUncheckedCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleCreateOrConnectWithoutCardInput = {
    where: infopeopleWhereUniqueInput
    create: XOR<infopeopleCreateWithoutCardInput, infopeopleUncheckedCreateWithoutCardInput>
  }

  export type infopeopleUpsertWithoutCardInput = {
    update: XOR<infopeopleUpdateWithoutCardInput, infopeopleUncheckedUpdateWithoutCardInput>
    create: XOR<infopeopleCreateWithoutCardInput, infopeopleUncheckedCreateWithoutCardInput>
  }

  export type infopeopleUpdateWithoutCardInput = {
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUpdateManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedUpdateWithoutCardInput = {
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUncheckedUpdateManyWithoutInfopeopleInput
  }

  export type clubCreateWithoutCashInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    location: locationCreateNestedOneWithoutClubInput
    inventory?: inventoryCreateNestedManyWithoutClubInput
    orderp?: orderpCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateWithoutCashInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    isActive: boolean
    inventory?: inventoryUncheckedCreateNestedManyWithoutClubInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubCreateOrConnectWithoutCashInput = {
    where: clubWhereUniqueInput
    create: XOR<clubCreateWithoutCashInput, clubUncheckedCreateWithoutCashInput>
  }

  export type clubCreateManyCashInputEnvelope = {
    data: Enumerable<clubCreateManyCashInput>
    skipDuplicates?: boolean
  }

  export type productCreateWithoutCashInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCashInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCashInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCashInput, productUncheckedCreateWithoutCashInput>
  }

  export type productCreateManyCashInputEnvelope = {
    data: Enumerable<productCreateManyCashInput>
    skipDuplicates?: boolean
  }

  export type clubUpsertWithWhereUniqueWithoutCashInput = {
    where: clubWhereUniqueInput
    update: XOR<clubUpdateWithoutCashInput, clubUncheckedUpdateWithoutCashInput>
    create: XOR<clubCreateWithoutCashInput, clubUncheckedCreateWithoutCashInput>
  }

  export type clubUpdateWithWhereUniqueWithoutCashInput = {
    where: clubWhereUniqueInput
    data: XOR<clubUpdateWithoutCashInput, clubUncheckedUpdateWithoutCashInput>
  }

  export type clubUpdateManyWithWhereWithoutCashInput = {
    where: clubScalarWhereInput
    data: XOR<clubUpdateManyMutationInput, clubUncheckedUpdateManyWithoutClubInput>
  }

  export type clubScalarWhereInput = {
    AND?: Enumerable<clubScalarWhereInput>
    OR?: Enumerable<clubScalarWhereInput>
    NOT?: Enumerable<clubScalarWhereInput>
    idClub?: IntFilter | number
    clubName?: StringFilter | string
    idLocation?: IntFilter | number
    deliveryCostProp?: FloatFilter | number
    idCash?: IntFilter | number
    isActive?: BoolFilter | boolean
  }

  export type productUpsertWithWhereUniqueWithoutCashInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutCashInput, productUncheckedUpdateWithoutCashInput>
    create: XOR<productCreateWithoutCashInput, productUncheckedCreateWithoutCashInput>
  }

  export type productUpdateWithWhereUniqueWithoutCashInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutCashInput, productUncheckedUpdateWithoutCashInput>
  }

  export type productUpdateManyWithWhereWithoutCashInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductInput>
  }

  export type productScalarWhereInput = {
    AND?: Enumerable<productScalarWhereInput>
    OR?: Enumerable<productScalarWhereInput>
    NOT?: Enumerable<productScalarWhereInput>
    idProduct?: IntFilter | number
    productName?: StringNullableFilter | string | null
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    idProductType?: IntFilter | number
    image?: BytesNullableFilter | Buffer | null
    idSupplier?: IntFilter | number
    idCash?: IntFilter | number
    isActive?: BoolFilter | boolean
    entryDate?: DateTimeFilter | Date | string
    tier?: IntFilter | number
    productDescr?: StringNullableFilter | string | null
  }

  export type clientpeopleCreateWithoutClientlocationInput = {
    salesCounter?: number
    isActive: boolean
    clientuser: clientuserCreateNestedOneWithoutClientpeopleInput
    infopeople: infopeopleCreateNestedOneWithoutClientpeopleInput
    clientmembership?: clientmembershipCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateWithoutClientlocationInput = {
    idClientPeople?: number
    idClientUser: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateOrConnectWithoutClientlocationInput = {
    where: clientpeopleWhereUniqueInput
    create: XOR<clientpeopleCreateWithoutClientlocationInput, clientpeopleUncheckedCreateWithoutClientlocationInput>
  }

  export type clientpeopleUpsertWithoutClientlocationInput = {
    update: XOR<clientpeopleUpdateWithoutClientlocationInput, clientpeopleUncheckedUpdateWithoutClientlocationInput>
    create: XOR<clientpeopleCreateWithoutClientlocationInput, clientpeopleUncheckedCreateWithoutClientlocationInput>
  }

  export type clientpeopleUpdateWithoutClientlocationInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientuser?: clientuserUpdateOneRequiredWithoutClientpeopleInput
    infopeople?: infopeopleUpdateOneRequiredWithoutClientpeopleInput
    clientmembership?: clientmembershipUpdateManyWithoutClientpeopleInput
    orderp?: orderpUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateWithoutClientlocationInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutClientpeopleInput
    orderp?: orderpUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type locationUpdateWithoutClientlocationInput = {
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    club?: clubUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateWithoutClientlocationInput = {
    idLocation?: IntFieldUpdateOperationsInput | number
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    club?: clubUncheckedUpdateManyWithoutLocationInput
  }

  export type clientpeopleCreateWithoutClientmembershipInput = {
    salesCounter?: number
    isActive: boolean
    clientuser: clientuserCreateNestedOneWithoutClientpeopleInput
    infopeople: infopeopleCreateNestedOneWithoutClientpeopleInput
    clientlocation?: clientlocationCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateWithoutClientmembershipInput = {
    idClientPeople?: number
    idClientUser: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
    clientlocation?: clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateOrConnectWithoutClientmembershipInput = {
    where: clientpeopleWhereUniqueInput
    create: XOR<clientpeopleCreateWithoutClientmembershipInput, clientpeopleUncheckedCreateWithoutClientmembershipInput>
  }

  export type membershipCreateWithoutClientmembershipInput = {
    nameMembership: string
    cost: Decimal | DecimalJsLike | number | string
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
  }

  export type membershipUncheckedCreateWithoutClientmembershipInput = {
    idMembership?: number
    nameMembership: string
    cost: Decimal | DecimalJsLike | number | string
    productDiscount: number
    deliveryDiscount: number
    isActive: boolean
  }

  export type membershipCreateOrConnectWithoutClientmembershipInput = {
    where: membershipWhereUniqueInput
    create: XOR<membershipCreateWithoutClientmembershipInput, membershipUncheckedCreateWithoutClientmembershipInput>
  }

  export type clientpeopleUpsertWithoutClientmembershipInput = {
    update: XOR<clientpeopleUpdateWithoutClientmembershipInput, clientpeopleUncheckedUpdateWithoutClientmembershipInput>
    create: XOR<clientpeopleCreateWithoutClientmembershipInput, clientpeopleUncheckedCreateWithoutClientmembershipInput>
  }

  export type clientpeopleUpdateWithoutClientmembershipInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientuser?: clientuserUpdateOneRequiredWithoutClientpeopleInput
    infopeople?: infopeopleUpdateOneRequiredWithoutClientpeopleInput
    clientlocation?: clientlocationUpdateManyWithoutClientpeopleInput
    orderp?: orderpUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateWithoutClientmembershipInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutClientpeopleInput
    orderp?: orderpUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type membershipUpsertWithoutClientmembershipInput = {
    update: XOR<membershipUpdateWithoutClientmembershipInput, membershipUncheckedUpdateWithoutClientmembershipInput>
    create: XOR<membershipCreateWithoutClientmembershipInput, membershipUncheckedCreateWithoutClientmembershipInput>
  }

  export type membershipUpdateWithoutClientmembershipInput = {
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type membershipUncheckedUpdateWithoutClientmembershipInput = {
    idMembership?: IntFieldUpdateOperationsInput | number
    nameMembership?: StringFieldUpdateOperationsInput | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productDiscount?: FloatFieldUpdateOperationsInput | number
    deliveryDiscount?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type clientuserCreateWithoutClientpeopleInput = {
    userPassword: Buffer
    isActive: boolean
    review?: reviewCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewCreateNestedManyWithoutClientuserInput
  }

  export type clientuserUncheckedCreateWithoutClientpeopleInput = {
    idClientUser?: number
    userPassword: Buffer
    isActive: boolean
    review?: reviewUncheckedCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedCreateNestedManyWithoutClientuserInput
  }

  export type clientuserCreateOrConnectWithoutClientpeopleInput = {
    where: clientuserWhereUniqueInput
    create: XOR<clientuserCreateWithoutClientpeopleInput, clientuserUncheckedCreateWithoutClientpeopleInput>
  }

  export type infopeopleCreateWithoutClientpeopleInput = {
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    card?: cardCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedCreateWithoutClientpeopleInput = {
    idInfoPeople?: number
    peopleName: string
    surname: string
    email: string
    phoneNumber: number
    birthDate: Date | string
    isActive: boolean
    card?: cardUncheckedCreateNestedManyWithoutInfopeopleInput
  }

  export type infopeopleCreateOrConnectWithoutClientpeopleInput = {
    where: infopeopleWhereUniqueInput
    create: XOR<infopeopleCreateWithoutClientpeopleInput, infopeopleUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientlocationCreateWithoutClientpeopleInput = {
    location: locationCreateNestedOneWithoutClientlocationInput
  }

  export type clientlocationUncheckedCreateWithoutClientpeopleInput = {
    idClientLocation?: number
    idLocation: number
  }

  export type clientlocationCreateOrConnectWithoutClientpeopleInput = {
    where: clientlocationWhereUniqueInput
    create: XOR<clientlocationCreateWithoutClientpeopleInput, clientlocationUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientlocationCreateManyClientpeopleInputEnvelope = {
    data: Enumerable<clientlocationCreateManyClientpeopleInput>
    skipDuplicates?: boolean
  }

  export type clientmembershipCreateWithoutClientpeopleInput = {
    membership: membershipCreateNestedOneWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedCreateWithoutClientpeopleInput = {
    idClientMembership?: number
    idMembership: number
  }

  export type clientmembershipCreateOrConnectWithoutClientpeopleInput = {
    where: clientmembershipWhereUniqueInput
    create: XOR<clientmembershipCreateWithoutClientpeopleInput, clientmembershipUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientmembershipCreateManyClientpeopleInputEnvelope = {
    data: Enumerable<clientmembershipCreateManyClientpeopleInput>
    skipDuplicates?: boolean
  }

  export type orderpCreateWithoutClientpeopleInput = {
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    club: clubCreateNestedOneWithoutOrderpInput
    orderline?: orderlineCreateNestedManyWithoutOrderpInput
  }

  export type orderpUncheckedCreateWithoutClientpeopleInput = {
    idOrderP?: number
    orderDate: Date | string
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedCreateNestedManyWithoutOrderpInput
  }

  export type orderpCreateOrConnectWithoutClientpeopleInput = {
    where: orderpWhereUniqueInput
    create: XOR<orderpCreateWithoutClientpeopleInput, orderpUncheckedCreateWithoutClientpeopleInput>
  }

  export type orderpCreateManyClientpeopleInputEnvelope = {
    data: Enumerable<orderpCreateManyClientpeopleInput>
    skipDuplicates?: boolean
  }

  export type clientuserUpsertWithoutClientpeopleInput = {
    update: XOR<clientuserUpdateWithoutClientpeopleInput, clientuserUncheckedUpdateWithoutClientpeopleInput>
    create: XOR<clientuserCreateWithoutClientpeopleInput, clientuserUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientuserUpdateWithoutClientpeopleInput = {
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    review?: reviewUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUpdateManyWithoutClientuserInput
  }

  export type clientuserUncheckedUpdateWithoutClientpeopleInput = {
    idClientUser?: IntFieldUpdateOperationsInput | number
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    review?: reviewUncheckedUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedUpdateManyWithoutClientuserInput
  }

  export type infopeopleUpsertWithoutClientpeopleInput = {
    update: XOR<infopeopleUpdateWithoutClientpeopleInput, infopeopleUncheckedUpdateWithoutClientpeopleInput>
    create: XOR<infopeopleCreateWithoutClientpeopleInput, infopeopleUncheckedCreateWithoutClientpeopleInput>
  }

  export type infopeopleUpdateWithoutClientpeopleInput = {
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    card?: cardUpdateManyWithoutInfopeopleInput
  }

  export type infopeopleUncheckedUpdateWithoutClientpeopleInput = {
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    peopleName?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: IntFieldUpdateOperationsInput | number
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    card?: cardUncheckedUpdateManyWithoutInfopeopleInput
  }

  export type clientlocationUpsertWithWhereUniqueWithoutClientpeopleInput = {
    where: clientlocationWhereUniqueInput
    update: XOR<clientlocationUpdateWithoutClientpeopleInput, clientlocationUncheckedUpdateWithoutClientpeopleInput>
    create: XOR<clientlocationCreateWithoutClientpeopleInput, clientlocationUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientlocationUpdateWithWhereUniqueWithoutClientpeopleInput = {
    where: clientlocationWhereUniqueInput
    data: XOR<clientlocationUpdateWithoutClientpeopleInput, clientlocationUncheckedUpdateWithoutClientpeopleInput>
  }

  export type clientlocationUpdateManyWithWhereWithoutClientpeopleInput = {
    where: clientlocationScalarWhereInput
    data: XOR<clientlocationUpdateManyMutationInput, clientlocationUncheckedUpdateManyWithoutClientlocationInput>
  }

  export type clientlocationScalarWhereInput = {
    AND?: Enumerable<clientlocationScalarWhereInput>
    OR?: Enumerable<clientlocationScalarWhereInput>
    NOT?: Enumerable<clientlocationScalarWhereInput>
    idClientLocation?: IntFilter | number
    idClientPeople?: IntFilter | number
    idLocation?: IntFilter | number
  }

  export type clientmembershipUpsertWithWhereUniqueWithoutClientpeopleInput = {
    where: clientmembershipWhereUniqueInput
    update: XOR<clientmembershipUpdateWithoutClientpeopleInput, clientmembershipUncheckedUpdateWithoutClientpeopleInput>
    create: XOR<clientmembershipCreateWithoutClientpeopleInput, clientmembershipUncheckedCreateWithoutClientpeopleInput>
  }

  export type clientmembershipUpdateWithWhereUniqueWithoutClientpeopleInput = {
    where: clientmembershipWhereUniqueInput
    data: XOR<clientmembershipUpdateWithoutClientpeopleInput, clientmembershipUncheckedUpdateWithoutClientpeopleInput>
  }

  export type clientmembershipUpdateManyWithWhereWithoutClientpeopleInput = {
    where: clientmembershipScalarWhereInput
    data: XOR<clientmembershipUpdateManyMutationInput, clientmembershipUncheckedUpdateManyWithoutClientmembershipInput>
  }

  export type clientmembershipScalarWhereInput = {
    AND?: Enumerable<clientmembershipScalarWhereInput>
    OR?: Enumerable<clientmembershipScalarWhereInput>
    NOT?: Enumerable<clientmembershipScalarWhereInput>
    idClientMembership?: IntFilter | number
    idMembership?: IntFilter | number
    idClientPeople?: IntFilter | number
  }

  export type orderpUpsertWithWhereUniqueWithoutClientpeopleInput = {
    where: orderpWhereUniqueInput
    update: XOR<orderpUpdateWithoutClientpeopleInput, orderpUncheckedUpdateWithoutClientpeopleInput>
    create: XOR<orderpCreateWithoutClientpeopleInput, orderpUncheckedCreateWithoutClientpeopleInput>
  }

  export type orderpUpdateWithWhereUniqueWithoutClientpeopleInput = {
    where: orderpWhereUniqueInput
    data: XOR<orderpUpdateWithoutClientpeopleInput, orderpUncheckedUpdateWithoutClientpeopleInput>
  }

  export type orderpUpdateManyWithWhereWithoutClientpeopleInput = {
    where: orderpScalarWhereInput
    data: XOR<orderpUpdateManyMutationInput, orderpUncheckedUpdateManyWithoutOrderpInput>
  }

  export type orderpScalarWhereInput = {
    AND?: Enumerable<orderpScalarWhereInput>
    OR?: Enumerable<orderpScalarWhereInput>
    NOT?: Enumerable<orderpScalarWhereInput>
    idOrderP?: IntFilter | number
    idClientPeople?: IntFilter | number
    orderDate?: DateTimeFilter | Date | string
    idClub?: IntFilter | number
    idEmployer?: IntFilter | number
    idMailer?: IntFilter | number
    deliveryCost?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type clientpeopleCreateWithoutClientuserInput = {
    salesCounter?: number
    isActive: boolean
    infopeople: infopeopleCreateNestedOneWithoutClientpeopleInput
    clientlocation?: clientlocationCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateWithoutClientuserInput = {
    idClientPeople?: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
    clientlocation?: clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateOrConnectWithoutClientuserInput = {
    where: clientpeopleWhereUniqueInput
    create: XOR<clientpeopleCreateWithoutClientuserInput, clientpeopleUncheckedCreateWithoutClientuserInput>
  }

  export type clientpeopleCreateManyClientuserInputEnvelope = {
    data: Enumerable<clientpeopleCreateManyClientuserInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutClientuserInput = {
    score: number
    revDescription: string
    revDate: Date | string
    product: productCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutClientuserInput = {
    idReview?: number
    idProduct: number
    score: number
    revDescription: string
    revDate: Date | string
  }

  export type reviewCreateOrConnectWithoutClientuserInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutClientuserInput, reviewUncheckedCreateWithoutClientuserInput>
  }

  export type reviewCreateManyClientuserInputEnvelope = {
    data: Enumerable<reviewCreateManyClientuserInput>
    skipDuplicates?: boolean
  }

  export type workerreviewCreateWithoutClientuserInput = {
    idWorker: number
    dateWR: Date | string
    complaint?: complaintCreateNestedManyWithoutWorkerreviewInput
    qualification?: qualificationCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedCreateWithoutClientuserInput = {
    idWorkerReview?: number
    idWorker: number
    dateWR: Date | string
    complaint?: complaintUncheckedCreateNestedManyWithoutWorkerreviewInput
    qualification?: qualificationUncheckedCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewCreateOrConnectWithoutClientuserInput = {
    where: workerreviewWhereUniqueInput
    create: XOR<workerreviewCreateWithoutClientuserInput, workerreviewUncheckedCreateWithoutClientuserInput>
  }

  export type workerreviewCreateManyClientuserInputEnvelope = {
    data: Enumerable<workerreviewCreateManyClientuserInput>
    skipDuplicates?: boolean
  }

  export type clientpeopleUpsertWithWhereUniqueWithoutClientuserInput = {
    where: clientpeopleWhereUniqueInput
    update: XOR<clientpeopleUpdateWithoutClientuserInput, clientpeopleUncheckedUpdateWithoutClientuserInput>
    create: XOR<clientpeopleCreateWithoutClientuserInput, clientpeopleUncheckedCreateWithoutClientuserInput>
  }

  export type clientpeopleUpdateWithWhereUniqueWithoutClientuserInput = {
    where: clientpeopleWhereUniqueInput
    data: XOR<clientpeopleUpdateWithoutClientuserInput, clientpeopleUncheckedUpdateWithoutClientuserInput>
  }

  export type clientpeopleUpdateManyWithWhereWithoutClientuserInput = {
    where: clientpeopleScalarWhereInput
    data: XOR<clientpeopleUpdateManyMutationInput, clientpeopleUncheckedUpdateManyWithoutClientpeopleInput>
  }

  export type clientpeopleScalarWhereInput = {
    AND?: Enumerable<clientpeopleScalarWhereInput>
    OR?: Enumerable<clientpeopleScalarWhereInput>
    NOT?: Enumerable<clientpeopleScalarWhereInput>
    idClientPeople?: IntFilter | number
    idClientUser?: IntFilter | number
    idInfoPeople?: IntFilter | number
    salesCounter?: IntFilter | number
    isActive?: BoolFilter | boolean
  }

  export type reviewUpsertWithWhereUniqueWithoutClientuserInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutClientuserInput, reviewUncheckedUpdateWithoutClientuserInput>
    create: XOR<reviewCreateWithoutClientuserInput, reviewUncheckedCreateWithoutClientuserInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutClientuserInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutClientuserInput, reviewUncheckedUpdateWithoutClientuserInput>
  }

  export type reviewUpdateManyWithWhereWithoutClientuserInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type reviewScalarWhereInput = {
    AND?: Enumerable<reviewScalarWhereInput>
    OR?: Enumerable<reviewScalarWhereInput>
    NOT?: Enumerable<reviewScalarWhereInput>
    idReview?: IntFilter | number
    idProduct?: IntFilter | number
    score?: IntFilter | number
    revDescription?: StringFilter | string
    idClientUser?: IntFilter | number
    revDate?: DateTimeFilter | Date | string
  }

  export type workerreviewUpsertWithWhereUniqueWithoutClientuserInput = {
    where: workerreviewWhereUniqueInput
    update: XOR<workerreviewUpdateWithoutClientuserInput, workerreviewUncheckedUpdateWithoutClientuserInput>
    create: XOR<workerreviewCreateWithoutClientuserInput, workerreviewUncheckedCreateWithoutClientuserInput>
  }

  export type workerreviewUpdateWithWhereUniqueWithoutClientuserInput = {
    where: workerreviewWhereUniqueInput
    data: XOR<workerreviewUpdateWithoutClientuserInput, workerreviewUncheckedUpdateWithoutClientuserInput>
  }

  export type workerreviewUpdateManyWithWhereWithoutClientuserInput = {
    where: workerreviewScalarWhereInput
    data: XOR<workerreviewUpdateManyMutationInput, workerreviewUncheckedUpdateManyWithoutWorkerreviewInput>
  }

  export type workerreviewScalarWhereInput = {
    AND?: Enumerable<workerreviewScalarWhereInput>
    OR?: Enumerable<workerreviewScalarWhereInput>
    NOT?: Enumerable<workerreviewScalarWhereInput>
    idWorkerReview?: IntFilter | number
    idClientUser?: IntFilter | number
    idWorker?: IntFilter | number
    dateWR?: DateTimeFilter | Date | string
  }

  export type cashCreateWithoutClubInput = {
    cashType: string
    product?: productCreateNestedManyWithoutCashInput
  }

  export type cashUncheckedCreateWithoutClubInput = {
    idCash?: number
    cashType: string
    product?: productUncheckedCreateNestedManyWithoutCashInput
  }

  export type cashCreateOrConnectWithoutClubInput = {
    where: cashWhereUniqueInput
    create: XOR<cashCreateWithoutClubInput, cashUncheckedCreateWithoutClubInput>
  }

  export type inventoryCreateWithoutClubInput = {
    stock?: number
    isActive: boolean
    product: productCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutClubInput = {
    idInventory?: number
    idProduct: number
    stock?: number
    isActive: boolean
  }

  export type inventoryCreateOrConnectWithoutClubInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutClubInput, inventoryUncheckedCreateWithoutClubInput>
  }

  export type inventoryCreateManyClubInputEnvelope = {
    data: Enumerable<inventoryCreateManyClubInput>
    skipDuplicates?: boolean
  }

  export type orderpCreateWithoutClubInput = {
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    clientpeople: clientpeopleCreateNestedOneWithoutOrderpInput
    orderline?: orderlineCreateNestedManyWithoutOrderpInput
  }

  export type orderpUncheckedCreateWithoutClubInput = {
    idOrderP?: number
    idClientPeople: number
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedCreateNestedManyWithoutOrderpInput
  }

  export type orderpCreateOrConnectWithoutClubInput = {
    where: orderpWhereUniqueInput
    create: XOR<orderpCreateWithoutClubInput, orderpUncheckedCreateWithoutClubInput>
  }

  export type orderpCreateManyClubInputEnvelope = {
    data: Enumerable<orderpCreateManyClubInput>
    skipDuplicates?: boolean
  }

  export type popularproductsCreateWithoutClubInput = {
    amount?: number
    product: productCreateNestedOneWithoutPopularproductsInput
  }

  export type popularproductsUncheckedCreateWithoutClubInput = {
    idPopularProducts?: number
    idProduct: number
    amount?: number
  }

  export type popularproductsCreateOrConnectWithoutClubInput = {
    where: popularproductsWhereUniqueInput
    create: XOR<popularproductsCreateWithoutClubInput, popularproductsUncheckedCreateWithoutClubInput>
  }

  export type popularproductsCreateManyClubInputEnvelope = {
    data: Enumerable<popularproductsCreateManyClubInput>
    skipDuplicates?: boolean
  }

  export type cashUpsertWithoutClubInput = {
    update: XOR<cashUpdateWithoutClubInput, cashUncheckedUpdateWithoutClubInput>
    create: XOR<cashCreateWithoutClubInput, cashUncheckedCreateWithoutClubInput>
  }

  export type cashUpdateWithoutClubInput = {
    cashType?: StringFieldUpdateOperationsInput | string
    product?: productUpdateManyWithoutCashInput
  }

  export type cashUncheckedUpdateWithoutClubInput = {
    idCash?: IntFieldUpdateOperationsInput | number
    cashType?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutCashInput
  }

  export type locationUpdateWithoutClubInput = {
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateWithoutClubInput = {
    idLocation?: IntFieldUpdateOperationsInput | number
    typeLocation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutLocationInput
  }

  export type inventoryUpsertWithWhereUniqueWithoutClubInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutClubInput, inventoryUncheckedUpdateWithoutClubInput>
    create: XOR<inventoryCreateWithoutClubInput, inventoryUncheckedCreateWithoutClubInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutClubInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutClubInput, inventoryUncheckedUpdateWithoutClubInput>
  }

  export type inventoryUpdateManyWithWhereWithoutClubInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutInventoryInput>
  }

  export type inventoryScalarWhereInput = {
    AND?: Enumerable<inventoryScalarWhereInput>
    OR?: Enumerable<inventoryScalarWhereInput>
    NOT?: Enumerable<inventoryScalarWhereInput>
    idInventory?: IntFilter | number
    idClub?: IntFilter | number
    idProduct?: IntFilter | number
    stock?: IntFilter | number
    isActive?: BoolFilter | boolean
  }

  export type orderpUpsertWithWhereUniqueWithoutClubInput = {
    where: orderpWhereUniqueInput
    update: XOR<orderpUpdateWithoutClubInput, orderpUncheckedUpdateWithoutClubInput>
    create: XOR<orderpCreateWithoutClubInput, orderpUncheckedCreateWithoutClubInput>
  }

  export type orderpUpdateWithWhereUniqueWithoutClubInput = {
    where: orderpWhereUniqueInput
    data: XOR<orderpUpdateWithoutClubInput, orderpUncheckedUpdateWithoutClubInput>
  }

  export type orderpUpdateManyWithWhereWithoutClubInput = {
    where: orderpScalarWhereInput
    data: XOR<orderpUpdateManyMutationInput, orderpUncheckedUpdateManyWithoutOrderpInput>
  }

  export type popularproductsUpsertWithWhereUniqueWithoutClubInput = {
    where: popularproductsWhereUniqueInput
    update: XOR<popularproductsUpdateWithoutClubInput, popularproductsUncheckedUpdateWithoutClubInput>
    create: XOR<popularproductsCreateWithoutClubInput, popularproductsUncheckedCreateWithoutClubInput>
  }

  export type popularproductsUpdateWithWhereUniqueWithoutClubInput = {
    where: popularproductsWhereUniqueInput
    data: XOR<popularproductsUpdateWithoutClubInput, popularproductsUncheckedUpdateWithoutClubInput>
  }

  export type popularproductsUpdateManyWithWhereWithoutClubInput = {
    where: popularproductsScalarWhereInput
    data: XOR<popularproductsUpdateManyMutationInput, popularproductsUncheckedUpdateManyWithoutPopularproductsInput>
  }

  export type popularproductsScalarWhereInput = {
    AND?: Enumerable<popularproductsScalarWhereInput>
    OR?: Enumerable<popularproductsScalarWhereInput>
    NOT?: Enumerable<popularproductsScalarWhereInput>
    idPopularProducts?: IntFilter | number
    idProduct?: IntFilter | number
    amount?: IntFilter | number
    idClub?: IntFilter | number
  }

  export type workerreviewCreateWithoutComplaintInput = {
    idWorker: number
    dateWR: Date | string
    clientuser: clientuserCreateNestedOneWithoutWorkerreviewInput
    qualification?: qualificationCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedCreateWithoutComplaintInput = {
    idWorkerReview?: number
    idClientUser: number
    idWorker: number
    dateWR: Date | string
    qualification?: qualificationUncheckedCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewCreateOrConnectWithoutComplaintInput = {
    where: workerreviewWhereUniqueInput
    create: XOR<workerreviewCreateWithoutComplaintInput, workerreviewUncheckedCreateWithoutComplaintInput>
  }

  export type workerreviewUpsertWithoutComplaintInput = {
    update: XOR<workerreviewUpdateWithoutComplaintInput, workerreviewUncheckedUpdateWithoutComplaintInput>
    create: XOR<workerreviewCreateWithoutComplaintInput, workerreviewUncheckedCreateWithoutComplaintInput>
  }

  export type workerreviewUpdateWithoutComplaintInput = {
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    clientuser?: clientuserUpdateOneRequiredWithoutWorkerreviewInput
    qualification?: qualificationUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedUpdateWithoutComplaintInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: qualificationUncheckedUpdateManyWithoutWorkerreviewInput
  }

  export type cardCreateWithoutInfopeopleInput = {
    cardNumber: string
    expirationDate: Date | string
    cvv: number
  }

  export type cardUncheckedCreateWithoutInfopeopleInput = {
    idCard?: number
    cardNumber: string
    expirationDate: Date | string
    cvv: number
  }

  export type cardCreateOrConnectWithoutInfopeopleInput = {
    where: cardWhereUniqueInput
    create: XOR<cardCreateWithoutInfopeopleInput, cardUncheckedCreateWithoutInfopeopleInput>
  }

  export type cardCreateManyInfopeopleInputEnvelope = {
    data: Enumerable<cardCreateManyInfopeopleInput>
    skipDuplicates?: boolean
  }

  export type clientpeopleCreateWithoutInfopeopleInput = {
    salesCounter?: number
    isActive: boolean
    clientuser: clientuserCreateNestedOneWithoutClientpeopleInput
    clientlocation?: clientlocationCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateWithoutInfopeopleInput = {
    idClientPeople?: number
    idClientUser: number
    salesCounter?: number
    isActive: boolean
    clientlocation?: clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateOrConnectWithoutInfopeopleInput = {
    where: clientpeopleWhereUniqueInput
    create: XOR<clientpeopleCreateWithoutInfopeopleInput, clientpeopleUncheckedCreateWithoutInfopeopleInput>
  }

  export type clientpeopleCreateManyInfopeopleInputEnvelope = {
    data: Enumerable<clientpeopleCreateManyInfopeopleInput>
    skipDuplicates?: boolean
  }

  export type cardUpsertWithWhereUniqueWithoutInfopeopleInput = {
    where: cardWhereUniqueInput
    update: XOR<cardUpdateWithoutInfopeopleInput, cardUncheckedUpdateWithoutInfopeopleInput>
    create: XOR<cardCreateWithoutInfopeopleInput, cardUncheckedCreateWithoutInfopeopleInput>
  }

  export type cardUpdateWithWhereUniqueWithoutInfopeopleInput = {
    where: cardWhereUniqueInput
    data: XOR<cardUpdateWithoutInfopeopleInput, cardUncheckedUpdateWithoutInfopeopleInput>
  }

  export type cardUpdateManyWithWhereWithoutInfopeopleInput = {
    where: cardScalarWhereInput
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyWithoutCardInput>
  }

  export type cardScalarWhereInput = {
    AND?: Enumerable<cardScalarWhereInput>
    OR?: Enumerable<cardScalarWhereInput>
    NOT?: Enumerable<cardScalarWhereInput>
    idCard?: IntFilter | number
    idInfoPeople?: IntFilter | number
    cardNumber?: StringFilter | string
    expirationDate?: DateTimeFilter | Date | string
    cvv?: IntFilter | number
  }

  export type clientpeopleUpsertWithWhereUniqueWithoutInfopeopleInput = {
    where: clientpeopleWhereUniqueInput
    update: XOR<clientpeopleUpdateWithoutInfopeopleInput, clientpeopleUncheckedUpdateWithoutInfopeopleInput>
    create: XOR<clientpeopleCreateWithoutInfopeopleInput, clientpeopleUncheckedCreateWithoutInfopeopleInput>
  }

  export type clientpeopleUpdateWithWhereUniqueWithoutInfopeopleInput = {
    where: clientpeopleWhereUniqueInput
    data: XOR<clientpeopleUpdateWithoutInfopeopleInput, clientpeopleUncheckedUpdateWithoutInfopeopleInput>
  }

  export type clientpeopleUpdateManyWithWhereWithoutInfopeopleInput = {
    where: clientpeopleScalarWhereInput
    data: XOR<clientpeopleUpdateManyMutationInput, clientpeopleUncheckedUpdateManyWithoutClientpeopleInput>
  }

  export type clubCreateWithoutInventoryInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    cash: cashCreateNestedOneWithoutClubInput
    location: locationCreateNestedOneWithoutClubInput
    orderp?: orderpCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateWithoutInventoryInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    orderp?: orderpUncheckedCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubCreateOrConnectWithoutInventoryInput = {
    where: clubWhereUniqueInput
    create: XOR<clubCreateWithoutInventoryInput, clubUncheckedCreateWithoutInventoryInput>
  }

  export type productCreateWithoutInventoryInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutInventoryInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutInventoryInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
  }

  export type clubUpsertWithoutInventoryInput = {
    update: XOR<clubUpdateWithoutInventoryInput, clubUncheckedUpdateWithoutInventoryInput>
    create: XOR<clubCreateWithoutInventoryInput, clubUncheckedCreateWithoutInventoryInput>
  }

  export type clubUpdateWithoutInventoryInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    cash?: cashUpdateOneRequiredWithoutClubInput
    location?: locationUpdateOneRequiredWithoutClubInput
    orderp?: orderpUpdateManyWithoutClubInput
    popularproducts?: popularproductsUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateWithoutInventoryInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    orderp?: orderpUncheckedUpdateManyWithoutClubInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutClubInput
  }

  export type productUpsertWithoutInventoryInput = {
    update: XOR<productUpdateWithoutInventoryInput, productUncheckedUpdateWithoutInventoryInput>
    create: XOR<productCreateWithoutInventoryInput, productUncheckedCreateWithoutInventoryInput>
  }

  export type productUpdateWithoutInventoryInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutInventoryInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type clientlocationCreateWithoutLocationInput = {
    clientpeople: clientpeopleCreateNestedOneWithoutClientlocationInput
  }

  export type clientlocationUncheckedCreateWithoutLocationInput = {
    idClientLocation?: number
    idClientPeople: number
  }

  export type clientlocationCreateOrConnectWithoutLocationInput = {
    where: clientlocationWhereUniqueInput
    create: XOR<clientlocationCreateWithoutLocationInput, clientlocationUncheckedCreateWithoutLocationInput>
  }

  export type clientlocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: clientlocationWhereUniqueInput
    update: XOR<clientlocationUpdateWithoutLocationInput, clientlocationUncheckedUpdateWithoutLocationInput>
    create: XOR<clientlocationCreateWithoutLocationInput, clientlocationUncheckedCreateWithoutLocationInput>
  }

  export type clientlocationCreateManyLocationInputEnvelope = {
    data: Enumerable<clientlocationCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type clientlocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: clientlocationWhereUniqueInput
    data: XOR<clientlocationUpdateWithoutLocationInput, clientlocationUncheckedUpdateWithoutLocationInput>
  }

  export type clientlocationUpdateManyWithWhereWithoutLocationInput = {
    where: clientlocationScalarWhereInput
    data: XOR<clientlocationUpdateManyMutationInput, clientlocationUncheckedUpdateManyWithoutClientlocationInput>
  }

  export type clubCreateWithoutLocationInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    cash: cashCreateNestedOneWithoutClubInput
    inventory?: inventoryCreateNestedManyWithoutClubInput
    orderp?: orderpCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateWithoutLocationInput = {
    idClub?: number
    clubName: string
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    inventory?: inventoryUncheckedCreateNestedManyWithoutClubInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubCreateOrConnectWithoutLocationInput = {
    where: clubWhereUniqueInput
    create: XOR<clubCreateWithoutLocationInput, clubUncheckedCreateWithoutLocationInput>
  }

  export type clubUpsertWithWhereUniqueWithoutLocationInput = {
    where: clubWhereUniqueInput
    update: XOR<clubUpdateWithoutLocationInput, clubUncheckedUpdateWithoutLocationInput>
    create: XOR<clubCreateWithoutLocationInput, clubUncheckedCreateWithoutLocationInput>
  }

  export type clubCreateManyLocationInputEnvelope = {
    data: Enumerable<clubCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type clubUpdateWithWhereUniqueWithoutLocationInput = {
    where: clubWhereUniqueInput
    data: XOR<clubUpdateWithoutLocationInput, clubUncheckedUpdateWithoutLocationInput>
  }

  export type clubUpdateManyWithWhereWithoutLocationInput = {
    where: clubScalarWhereInput
    data: XOR<clubUpdateManyMutationInput, clubUncheckedUpdateManyWithoutClubInput>
  }

  export type clientmembershipCreateWithoutMembershipInput = {
    clientpeople: clientpeopleCreateNestedOneWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedCreateWithoutMembershipInput = {
    idClientMembership?: number
    idClientPeople: number
  }

  export type clientmembershipCreateOrConnectWithoutMembershipInput = {
    where: clientmembershipWhereUniqueInput
    create: XOR<clientmembershipCreateWithoutMembershipInput, clientmembershipUncheckedCreateWithoutMembershipInput>
  }

  export type clientmembershipCreateManyMembershipInputEnvelope = {
    data: Enumerable<clientmembershipCreateManyMembershipInput>
    skipDuplicates?: boolean
  }

  export type clientmembershipUpsertWithWhereUniqueWithoutMembershipInput = {
    where: clientmembershipWhereUniqueInput
    update: XOR<clientmembershipUpdateWithoutMembershipInput, clientmembershipUncheckedUpdateWithoutMembershipInput>
    create: XOR<clientmembershipCreateWithoutMembershipInput, clientmembershipUncheckedCreateWithoutMembershipInput>
  }

  export type clientmembershipUpdateWithWhereUniqueWithoutMembershipInput = {
    where: clientmembershipWhereUniqueInput
    data: XOR<clientmembershipUpdateWithoutMembershipInput, clientmembershipUncheckedUpdateWithoutMembershipInput>
  }

  export type clientmembershipUpdateManyWithWhereWithoutMembershipInput = {
    where: clientmembershipScalarWhereInput
    data: XOR<clientmembershipUpdateManyMutationInput, clientmembershipUncheckedUpdateManyWithoutClientmembershipInput>
  }

  export type orderpCreateWithoutOrderlineInput = {
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
    clientpeople: clientpeopleCreateNestedOneWithoutOrderpInput
    club: clubCreateNestedOneWithoutOrderpInput
  }

  export type orderpUncheckedCreateWithoutOrderlineInput = {
    idOrderP?: number
    idClientPeople: number
    orderDate: Date | string
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
  }

  export type orderpCreateOrConnectWithoutOrderlineInput = {
    where: orderpWhereUniqueInput
    create: XOR<orderpCreateWithoutOrderlineInput, orderpUncheckedCreateWithoutOrderlineInput>
  }

  export type productCreateWithoutOrderlineInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutOrderlineInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutOrderlineInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrderlineInput, productUncheckedCreateWithoutOrderlineInput>
  }

  export type orderpUpsertWithoutOrderlineInput = {
    update: XOR<orderpUpdateWithoutOrderlineInput, orderpUncheckedUpdateWithoutOrderlineInput>
    create: XOR<orderpCreateWithoutOrderlineInput, orderpUncheckedCreateWithoutOrderlineInput>
  }

  export type orderpUpdateWithoutOrderlineInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientpeople?: clientpeopleUpdateOneRequiredWithoutOrderpInput
    club?: clubUpdateOneRequiredWithoutOrderpInput
  }

  export type orderpUncheckedUpdateWithoutOrderlineInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idClub?: IntFieldUpdateOperationsInput | number
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type productUpsertWithoutOrderlineInput = {
    update: XOR<productUpdateWithoutOrderlineInput, productUncheckedUpdateWithoutOrderlineInput>
    create: XOR<productCreateWithoutOrderlineInput, productUncheckedCreateWithoutOrderlineInput>
  }

  export type productUpdateWithoutOrderlineInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutOrderlineInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type clientpeopleCreateWithoutOrderpInput = {
    salesCounter?: number
    isActive: boolean
    clientuser: clientuserCreateNestedOneWithoutClientpeopleInput
    infopeople: infopeopleCreateNestedOneWithoutClientpeopleInput
    clientlocation?: clientlocationCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedCreateWithoutOrderpInput = {
    idClientPeople?: number
    idClientUser: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
    clientlocation?: clientlocationUncheckedCreateNestedManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedCreateNestedManyWithoutClientpeopleInput
  }

  export type clientpeopleCreateOrConnectWithoutOrderpInput = {
    where: clientpeopleWhereUniqueInput
    create: XOR<clientpeopleCreateWithoutOrderpInput, clientpeopleUncheckedCreateWithoutOrderpInput>
  }

  export type clubCreateWithoutOrderpInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    cash: cashCreateNestedOneWithoutClubInput
    location: locationCreateNestedOneWithoutClubInput
    inventory?: inventoryCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateWithoutOrderpInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    inventory?: inventoryUncheckedCreateNestedManyWithoutClubInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubCreateOrConnectWithoutOrderpInput = {
    where: clubWhereUniqueInput
    create: XOR<clubCreateWithoutOrderpInput, clubUncheckedCreateWithoutOrderpInput>
  }

  export type orderlineCreateWithoutOrderpInput = {
    cost: Decimal | DecimalJsLike | number | string
    amount: number
    product: productCreateNestedOneWithoutOrderlineInput
  }

  export type orderlineUncheckedCreateWithoutOrderpInput = {
    idOrderLine?: number
    idProduct: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type orderlineCreateOrConnectWithoutOrderpInput = {
    where: orderlineWhereUniqueInput
    create: XOR<orderlineCreateWithoutOrderpInput, orderlineUncheckedCreateWithoutOrderpInput>
  }

  export type orderlineCreateManyOrderpInputEnvelope = {
    data: Enumerable<orderlineCreateManyOrderpInput>
    skipDuplicates?: boolean
  }

  export type clientpeopleUpsertWithoutOrderpInput = {
    update: XOR<clientpeopleUpdateWithoutOrderpInput, clientpeopleUncheckedUpdateWithoutOrderpInput>
    create: XOR<clientpeopleCreateWithoutOrderpInput, clientpeopleUncheckedCreateWithoutOrderpInput>
  }

  export type clientpeopleUpdateWithoutOrderpInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientuser?: clientuserUpdateOneRequiredWithoutClientpeopleInput
    infopeople?: infopeopleUpdateOneRequiredWithoutClientpeopleInput
    clientlocation?: clientlocationUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateWithoutOrderpInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type clubUpsertWithoutOrderpInput = {
    update: XOR<clubUpdateWithoutOrderpInput, clubUncheckedUpdateWithoutOrderpInput>
    create: XOR<clubCreateWithoutOrderpInput, clubUncheckedCreateWithoutOrderpInput>
  }

  export type clubUpdateWithoutOrderpInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    cash?: cashUpdateOneRequiredWithoutClubInput
    location?: locationUpdateOneRequiredWithoutClubInput
    inventory?: inventoryUpdateManyWithoutClubInput
    popularproducts?: popularproductsUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateWithoutOrderpInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inventory?: inventoryUncheckedUpdateManyWithoutClubInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutClubInput
  }

  export type orderlineUpsertWithWhereUniqueWithoutOrderpInput = {
    where: orderlineWhereUniqueInput
    update: XOR<orderlineUpdateWithoutOrderpInput, orderlineUncheckedUpdateWithoutOrderpInput>
    create: XOR<orderlineCreateWithoutOrderpInput, orderlineUncheckedCreateWithoutOrderpInput>
  }

  export type orderlineUpdateWithWhereUniqueWithoutOrderpInput = {
    where: orderlineWhereUniqueInput
    data: XOR<orderlineUpdateWithoutOrderpInput, orderlineUncheckedUpdateWithoutOrderpInput>
  }

  export type orderlineUpdateManyWithWhereWithoutOrderpInput = {
    where: orderlineScalarWhereInput
    data: XOR<orderlineUpdateManyMutationInput, orderlineUncheckedUpdateManyWithoutOrderlineInput>
  }

  export type orderlineScalarWhereInput = {
    AND?: Enumerable<orderlineScalarWhereInput>
    OR?: Enumerable<orderlineScalarWhereInput>
    NOT?: Enumerable<orderlineScalarWhereInput>
    idOrderLine?: IntFilter | number
    idOrderP?: IntFilter | number
    idProduct?: IntFilter | number
    cost?: DecimalFilter | Decimal | DecimalJsLike | number | string
    amount?: IntFilter | number
  }

  export type clubCreateWithoutPopularproductsInput = {
    clubName: string
    deliveryCostProp: number
    isActive: boolean
    cash: cashCreateNestedOneWithoutClubInput
    location: locationCreateNestedOneWithoutClubInput
    inventory?: inventoryCreateNestedManyWithoutClubInput
    orderp?: orderpCreateNestedManyWithoutClubInput
  }

  export type clubUncheckedCreateWithoutPopularproductsInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    idCash: number
    isActive: boolean
    inventory?: inventoryUncheckedCreateNestedManyWithoutClubInput
    orderp?: orderpUncheckedCreateNestedManyWithoutClubInput
  }

  export type clubCreateOrConnectWithoutPopularproductsInput = {
    where: clubWhereUniqueInput
    create: XOR<clubCreateWithoutPopularproductsInput, clubUncheckedCreateWithoutPopularproductsInput>
  }

  export type productCreateWithoutPopularproductsInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutPopularproductsInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutPopularproductsInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutPopularproductsInput, productUncheckedCreateWithoutPopularproductsInput>
  }

  export type clubUpsertWithoutPopularproductsInput = {
    update: XOR<clubUpdateWithoutPopularproductsInput, clubUncheckedUpdateWithoutPopularproductsInput>
    create: XOR<clubCreateWithoutPopularproductsInput, clubUncheckedCreateWithoutPopularproductsInput>
  }

  export type clubUpdateWithoutPopularproductsInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    cash?: cashUpdateOneRequiredWithoutClubInput
    location?: locationUpdateOneRequiredWithoutClubInput
    inventory?: inventoryUpdateManyWithoutClubInput
    orderp?: orderpUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateWithoutPopularproductsInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inventory?: inventoryUncheckedUpdateManyWithoutClubInput
    orderp?: orderpUncheckedUpdateManyWithoutClubInput
  }

  export type productUpsertWithoutPopularproductsInput = {
    update: XOR<productUpdateWithoutPopularproductsInput, productUncheckedUpdateWithoutPopularproductsInput>
    create: XOR<productCreateWithoutPopularproductsInput, productUncheckedCreateWithoutPopularproductsInput>
  }

  export type productUpdateWithoutPopularproductsInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutPopularproductsInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type productCreateWithoutPresentationInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutPresentationInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutPresentationInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutPresentationInput, productUncheckedCreateWithoutPresentationInput>
  }

  export type productUpsertWithoutPresentationInput = {
    update: XOR<productUpdateWithoutPresentationInput, productUncheckedUpdateWithoutPresentationInput>
    create: XOR<productCreateWithoutPresentationInput, productUncheckedCreateWithoutPresentationInput>
  }

  export type productUpdateWithoutPresentationInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutPresentationInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type cashCreateWithoutProductInput = {
    cashType: string
    club?: clubCreateNestedManyWithoutCashInput
  }

  export type cashUncheckedCreateWithoutProductInput = {
    idCash?: number
    cashType: string
    club?: clubUncheckedCreateNestedManyWithoutCashInput
  }

  export type cashCreateOrConnectWithoutProductInput = {
    where: cashWhereUniqueInput
    create: XOR<cashCreateWithoutProductInput, cashUncheckedCreateWithoutProductInput>
  }

  export type producttypeCreateWithoutProductInput = {
    typeName: string
    isActive: boolean
  }

  export type producttypeUncheckedCreateWithoutProductInput = {
    idProductType?: number
    typeName: string
    isActive: boolean
  }

  export type producttypeCreateOrConnectWithoutProductInput = {
    where: producttypeWhereUniqueInput
    create: XOR<producttypeCreateWithoutProductInput, producttypeUncheckedCreateWithoutProductInput>
  }

  export type supplierCreateWithoutProductInput = {
    supplierName: string
    isActive: boolean
  }

  export type supplierUncheckedCreateWithoutProductInput = {
    idSupplier?: number
    supplierName: string
    isActive: boolean
  }

  export type supplierCreateOrConnectWithoutProductInput = {
    where: supplierWhereUniqueInput
    create: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
  }

  export type inventoryCreateWithoutProductInput = {
    stock?: number
    isActive: boolean
    club: clubCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateWithoutProductInput = {
    idInventory?: number
    idClub: number
    stock?: number
    isActive: boolean
  }

  export type inventoryCreateOrConnectWithoutProductInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
  }

  export type inventoryCreateManyProductInputEnvelope = {
    data: Enumerable<inventoryCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type orderlineCreateWithoutProductInput = {
    cost: Decimal | DecimalJsLike | number | string
    amount: number
    orderp: orderpCreateNestedOneWithoutOrderlineInput
  }

  export type orderlineUncheckedCreateWithoutProductInput = {
    idOrderLine?: number
    idOrderP: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type orderlineCreateOrConnectWithoutProductInput = {
    where: orderlineWhereUniqueInput
    create: XOR<orderlineCreateWithoutProductInput, orderlineUncheckedCreateWithoutProductInput>
  }

  export type orderlineCreateManyProductInputEnvelope = {
    data: Enumerable<orderlineCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type popularproductsCreateWithoutProductInput = {
    amount?: number
    club: clubCreateNestedOneWithoutPopularproductsInput
  }

  export type popularproductsUncheckedCreateWithoutProductInput = {
    idPopularProducts?: number
    amount?: number
    idClub: number
  }

  export type popularproductsCreateOrConnectWithoutProductInput = {
    where: popularproductsWhereUniqueInput
    create: XOR<popularproductsCreateWithoutProductInput, popularproductsUncheckedCreateWithoutProductInput>
  }

  export type popularproductsCreateManyProductInputEnvelope = {
    data: Enumerable<popularproductsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type presentationCreateWithoutProductInput = {
    amountBottles: number
    sizeBottle: number
  }

  export type presentationUncheckedCreateWithoutProductInput = {
    idPresentation?: number
    amountBottles: number
    sizeBottle: number
  }

  export type presentationCreateOrConnectWithoutProductInput = {
    where: presentationWhereUniqueInput
    create: XOR<presentationCreateWithoutProductInput, presentationUncheckedCreateWithoutProductInput>
  }

  export type presentationCreateManyProductInputEnvelope = {
    data: Enumerable<presentationCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutProductInput = {
    score: number
    revDescription: string
    revDate: Date | string
    clientuser: clientuserCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutProductInput = {
    idReview?: number
    score: number
    revDescription: string
    idClientUser: number
    revDate: Date | string
  }

  export type reviewCreateOrConnectWithoutProductInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutProductInput, reviewUncheckedCreateWithoutProductInput>
  }

  export type reviewCreateManyProductInputEnvelope = {
    data: Enumerable<reviewCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type cashUpsertWithoutProductInput = {
    update: XOR<cashUpdateWithoutProductInput, cashUncheckedUpdateWithoutProductInput>
    create: XOR<cashCreateWithoutProductInput, cashUncheckedCreateWithoutProductInput>
  }

  export type cashUpdateWithoutProductInput = {
    cashType?: StringFieldUpdateOperationsInput | string
    club?: clubUpdateManyWithoutCashInput
  }

  export type cashUncheckedUpdateWithoutProductInput = {
    idCash?: IntFieldUpdateOperationsInput | number
    cashType?: StringFieldUpdateOperationsInput | string
    club?: clubUncheckedUpdateManyWithoutCashInput
  }

  export type producttypeUpsertWithoutProductInput = {
    update: XOR<producttypeUpdateWithoutProductInput, producttypeUncheckedUpdateWithoutProductInput>
    create: XOR<producttypeCreateWithoutProductInput, producttypeUncheckedCreateWithoutProductInput>
  }

  export type producttypeUpdateWithoutProductInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type producttypeUncheckedUpdateWithoutProductInput = {
    idProductType?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type supplierUpsertWithoutProductInput = {
    update: XOR<supplierUpdateWithoutProductInput, supplierUncheckedUpdateWithoutProductInput>
    create: XOR<supplierCreateWithoutProductInput, supplierUncheckedCreateWithoutProductInput>
  }

  export type supplierUpdateWithoutProductInput = {
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type supplierUncheckedUpdateWithoutProductInput = {
    idSupplier?: IntFieldUpdateOperationsInput | number
    supplierName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: inventoryWhereUniqueInput
    update: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
  }

  export type inventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: inventoryWhereUniqueInput
    data: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
  }

  export type inventoryUpdateManyWithWhereWithoutProductInput = {
    where: inventoryScalarWhereInput
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyWithoutInventoryInput>
  }

  export type orderlineUpsertWithWhereUniqueWithoutProductInput = {
    where: orderlineWhereUniqueInput
    update: XOR<orderlineUpdateWithoutProductInput, orderlineUncheckedUpdateWithoutProductInput>
    create: XOR<orderlineCreateWithoutProductInput, orderlineUncheckedCreateWithoutProductInput>
  }

  export type orderlineUpdateWithWhereUniqueWithoutProductInput = {
    where: orderlineWhereUniqueInput
    data: XOR<orderlineUpdateWithoutProductInput, orderlineUncheckedUpdateWithoutProductInput>
  }

  export type orderlineUpdateManyWithWhereWithoutProductInput = {
    where: orderlineScalarWhereInput
    data: XOR<orderlineUpdateManyMutationInput, orderlineUncheckedUpdateManyWithoutOrderlineInput>
  }

  export type popularproductsUpsertWithWhereUniqueWithoutProductInput = {
    where: popularproductsWhereUniqueInput
    update: XOR<popularproductsUpdateWithoutProductInput, popularproductsUncheckedUpdateWithoutProductInput>
    create: XOR<popularproductsCreateWithoutProductInput, popularproductsUncheckedCreateWithoutProductInput>
  }

  export type popularproductsUpdateWithWhereUniqueWithoutProductInput = {
    where: popularproductsWhereUniqueInput
    data: XOR<popularproductsUpdateWithoutProductInput, popularproductsUncheckedUpdateWithoutProductInput>
  }

  export type popularproductsUpdateManyWithWhereWithoutProductInput = {
    where: popularproductsScalarWhereInput
    data: XOR<popularproductsUpdateManyMutationInput, popularproductsUncheckedUpdateManyWithoutPopularproductsInput>
  }

  export type presentationUpsertWithWhereUniqueWithoutProductInput = {
    where: presentationWhereUniqueInput
    update: XOR<presentationUpdateWithoutProductInput, presentationUncheckedUpdateWithoutProductInput>
    create: XOR<presentationCreateWithoutProductInput, presentationUncheckedCreateWithoutProductInput>
  }

  export type presentationUpdateWithWhereUniqueWithoutProductInput = {
    where: presentationWhereUniqueInput
    data: XOR<presentationUpdateWithoutProductInput, presentationUncheckedUpdateWithoutProductInput>
  }

  export type presentationUpdateManyWithWhereWithoutProductInput = {
    where: presentationScalarWhereInput
    data: XOR<presentationUpdateManyMutationInput, presentationUncheckedUpdateManyWithoutPresentationInput>
  }

  export type presentationScalarWhereInput = {
    AND?: Enumerable<presentationScalarWhereInput>
    OR?: Enumerable<presentationScalarWhereInput>
    NOT?: Enumerable<presentationScalarWhereInput>
    idPresentation?: IntFilter | number
    idProduct?: IntFilter | number
    amountBottles?: IntFilter | number
    sizeBottle?: IntFilter | number
  }

  export type reviewUpsertWithWhereUniqueWithoutProductInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutProductInput, reviewUncheckedUpdateWithoutProductInput>
    create: XOR<reviewCreateWithoutProductInput, reviewUncheckedCreateWithoutProductInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutProductInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutProductInput, reviewUncheckedUpdateWithoutProductInput>
  }

  export type reviewUpdateManyWithWhereWithoutProductInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type productCreateWithoutProducttypeInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProducttypeInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProducttypeInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProducttypeInput, productUncheckedCreateWithoutProducttypeInput>
  }

  export type productCreateManyProducttypeInputEnvelope = {
    data: Enumerable<productCreateManyProducttypeInput>
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutProducttypeInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutProducttypeInput, productUncheckedUpdateWithoutProducttypeInput>
    create: XOR<productCreateWithoutProducttypeInput, productUncheckedCreateWithoutProducttypeInput>
  }

  export type productUpdateWithWhereUniqueWithoutProducttypeInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutProducttypeInput, productUncheckedUpdateWithoutProducttypeInput>
  }

  export type productUpdateManyWithWhereWithoutProducttypeInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductInput>
  }

  export type workerreviewCreateWithoutQualificationInput = {
    idWorker: number
    dateWR: Date | string
    clientuser: clientuserCreateNestedOneWithoutWorkerreviewInput
    complaint?: complaintCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedCreateWithoutQualificationInput = {
    idWorkerReview?: number
    idClientUser: number
    idWorker: number
    dateWR: Date | string
    complaint?: complaintUncheckedCreateNestedManyWithoutWorkerreviewInput
  }

  export type workerreviewCreateOrConnectWithoutQualificationInput = {
    where: workerreviewWhereUniqueInput
    create: XOR<workerreviewCreateWithoutQualificationInput, workerreviewUncheckedCreateWithoutQualificationInput>
  }

  export type workerreviewUpsertWithoutQualificationInput = {
    update: XOR<workerreviewUpdateWithoutQualificationInput, workerreviewUncheckedUpdateWithoutQualificationInput>
    create: XOR<workerreviewCreateWithoutQualificationInput, workerreviewUncheckedCreateWithoutQualificationInput>
  }

  export type workerreviewUpdateWithoutQualificationInput = {
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    clientuser?: clientuserUpdateOneRequiredWithoutWorkerreviewInput
    complaint?: complaintUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedUpdateWithoutQualificationInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: complaintUncheckedUpdateManyWithoutWorkerreviewInput
  }

  export type clientuserCreateWithoutReviewInput = {
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewCreateNestedManyWithoutClientuserInput
  }

  export type clientuserUncheckedCreateWithoutReviewInput = {
    idClientUser?: number
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleUncheckedCreateNestedManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedCreateNestedManyWithoutClientuserInput
  }

  export type clientuserCreateOrConnectWithoutReviewInput = {
    where: clientuserWhereUniqueInput
    create: XOR<clientuserCreateWithoutReviewInput, clientuserUncheckedCreateWithoutReviewInput>
  }

  export type productCreateWithoutReviewInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    supplier: supplierCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutReviewInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutReviewInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutReviewInput, productUncheckedCreateWithoutReviewInput>
  }

  export type clientuserUpsertWithoutReviewInput = {
    update: XOR<clientuserUpdateWithoutReviewInput, clientuserUncheckedUpdateWithoutReviewInput>
    create: XOR<clientuserCreateWithoutReviewInput, clientuserUncheckedCreateWithoutReviewInput>
  }

  export type clientuserUpdateWithoutReviewInput = {
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUpdateManyWithoutClientuserInput
  }

  export type clientuserUncheckedUpdateWithoutReviewInput = {
    idClientUser?: IntFieldUpdateOperationsInput | number
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUncheckedUpdateManyWithoutClientuserInput
    workerreview?: workerreviewUncheckedUpdateManyWithoutClientuserInput
  }

  export type productUpsertWithoutReviewInput = {
    update: XOR<productUpdateWithoutReviewInput, productUncheckedUpdateWithoutReviewInput>
    create: XOR<productCreateWithoutReviewInput, productUncheckedCreateWithoutReviewInput>
  }

  export type productUpdateWithoutReviewInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutReviewInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
  }

  export type productCreateWithoutSupplierInput = {
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    cash: cashCreateNestedOneWithoutProductInput
    producttype: producttypeCreateNestedOneWithoutProductInput
    inventory?: inventoryCreateNestedManyWithoutProductInput
    orderline?: orderlineCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsCreateNestedManyWithoutProductInput
    presentation?: presentationCreateNestedManyWithoutProductInput
    review?: reviewCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutSupplierInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
    inventory?: inventoryUncheckedCreateNestedManyWithoutProductInput
    orderline?: orderlineUncheckedCreateNestedManyWithoutProductInput
    popularproducts?: popularproductsUncheckedCreateNestedManyWithoutProductInput
    presentation?: presentationUncheckedCreateNestedManyWithoutProductInput
    review?: reviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutSupplierInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput>
  }

  export type productCreateManySupplierInputEnvelope = {
    data: Enumerable<productCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutSupplierInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutSupplierInput, productUncheckedUpdateWithoutSupplierInput>
    create: XOR<productCreateWithoutSupplierInput, productUncheckedCreateWithoutSupplierInput>
  }

  export type productUpdateWithWhereUniqueWithoutSupplierInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutSupplierInput, productUncheckedUpdateWithoutSupplierInput>
  }

  export type productUpdateManyWithWhereWithoutSupplierInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductInput>
  }

  export type clientuserCreateWithoutWorkerreviewInput = {
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleCreateNestedManyWithoutClientuserInput
    review?: reviewCreateNestedManyWithoutClientuserInput
  }

  export type clientuserUncheckedCreateWithoutWorkerreviewInput = {
    idClientUser?: number
    userPassword: Buffer
    isActive: boolean
    clientpeople?: clientpeopleUncheckedCreateNestedManyWithoutClientuserInput
    review?: reviewUncheckedCreateNestedManyWithoutClientuserInput
  }

  export type clientuserCreateOrConnectWithoutWorkerreviewInput = {
    where: clientuserWhereUniqueInput
    create: XOR<clientuserCreateWithoutWorkerreviewInput, clientuserUncheckedCreateWithoutWorkerreviewInput>
  }

  export type complaintCreateWithoutWorkerreviewInput = {
    compDescription: string
    solved: boolean
  }

  export type complaintUncheckedCreateWithoutWorkerreviewInput = {
    idComplaint?: number
    compDescription: string
    solved: boolean
  }

  export type complaintCreateOrConnectWithoutWorkerreviewInput = {
    where: complaintWhereUniqueInput
    create: XOR<complaintCreateWithoutWorkerreviewInput, complaintUncheckedCreateWithoutWorkerreviewInput>
  }

  export type complaintCreateManyWorkerreviewInputEnvelope = {
    data: Enumerable<complaintCreateManyWorkerreviewInput>
    skipDuplicates?: boolean
  }

  export type qualificationCreateWithoutWorkerreviewInput = {
    qualDescription: string
  }

  export type qualificationUncheckedCreateWithoutWorkerreviewInput = {
    idQualification?: number
    qualDescription: string
  }

  export type qualificationCreateOrConnectWithoutWorkerreviewInput = {
    where: qualificationWhereUniqueInput
    create: XOR<qualificationCreateWithoutWorkerreviewInput, qualificationUncheckedCreateWithoutWorkerreviewInput>
  }

  export type qualificationCreateManyWorkerreviewInputEnvelope = {
    data: Enumerable<qualificationCreateManyWorkerreviewInput>
    skipDuplicates?: boolean
  }

  export type clientuserUpsertWithoutWorkerreviewInput = {
    update: XOR<clientuserUpdateWithoutWorkerreviewInput, clientuserUncheckedUpdateWithoutWorkerreviewInput>
    create: XOR<clientuserCreateWithoutWorkerreviewInput, clientuserUncheckedCreateWithoutWorkerreviewInput>
  }

  export type clientuserUpdateWithoutWorkerreviewInput = {
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUpdateManyWithoutClientuserInput
    review?: reviewUpdateManyWithoutClientuserInput
  }

  export type clientuserUncheckedUpdateWithoutWorkerreviewInput = {
    idClientUser?: IntFieldUpdateOperationsInput | number
    userPassword?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientpeople?: clientpeopleUncheckedUpdateManyWithoutClientuserInput
    review?: reviewUncheckedUpdateManyWithoutClientuserInput
  }

  export type complaintUpsertWithWhereUniqueWithoutWorkerreviewInput = {
    where: complaintWhereUniqueInput
    update: XOR<complaintUpdateWithoutWorkerreviewInput, complaintUncheckedUpdateWithoutWorkerreviewInput>
    create: XOR<complaintCreateWithoutWorkerreviewInput, complaintUncheckedCreateWithoutWorkerreviewInput>
  }

  export type complaintUpdateWithWhereUniqueWithoutWorkerreviewInput = {
    where: complaintWhereUniqueInput
    data: XOR<complaintUpdateWithoutWorkerreviewInput, complaintUncheckedUpdateWithoutWorkerreviewInput>
  }

  export type complaintUpdateManyWithWhereWithoutWorkerreviewInput = {
    where: complaintScalarWhereInput
    data: XOR<complaintUpdateManyMutationInput, complaintUncheckedUpdateManyWithoutComplaintInput>
  }

  export type complaintScalarWhereInput = {
    AND?: Enumerable<complaintScalarWhereInput>
    OR?: Enumerable<complaintScalarWhereInput>
    NOT?: Enumerable<complaintScalarWhereInput>
    idComplaint?: IntFilter | number
    idWorkerReview?: IntFilter | number
    compDescription?: StringFilter | string
    solved?: BoolFilter | boolean
  }

  export type qualificationUpsertWithWhereUniqueWithoutWorkerreviewInput = {
    where: qualificationWhereUniqueInput
    update: XOR<qualificationUpdateWithoutWorkerreviewInput, qualificationUncheckedUpdateWithoutWorkerreviewInput>
    create: XOR<qualificationCreateWithoutWorkerreviewInput, qualificationUncheckedCreateWithoutWorkerreviewInput>
  }

  export type qualificationUpdateWithWhereUniqueWithoutWorkerreviewInput = {
    where: qualificationWhereUniqueInput
    data: XOR<qualificationUpdateWithoutWorkerreviewInput, qualificationUncheckedUpdateWithoutWorkerreviewInput>
  }

  export type qualificationUpdateManyWithWhereWithoutWorkerreviewInput = {
    where: qualificationScalarWhereInput
    data: XOR<qualificationUpdateManyMutationInput, qualificationUncheckedUpdateManyWithoutQualificationInput>
  }

  export type qualificationScalarWhereInput = {
    AND?: Enumerable<qualificationScalarWhereInput>
    OR?: Enumerable<qualificationScalarWhereInput>
    NOT?: Enumerable<qualificationScalarWhereInput>
    idQualification?: IntFilter | number
    idWorkerReview?: IntFilter | number
    qualDescription?: StringFilter | string
  }

  export type clubCreateManyCashInput = {
    idClub?: number
    clubName: string
    idLocation: number
    deliveryCostProp: number
    isActive: boolean
  }

  export type productCreateManyCashInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idSupplier: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
  }

  export type clubUpdateWithoutCashInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: locationUpdateOneRequiredWithoutClubInput
    inventory?: inventoryUpdateManyWithoutClubInput
    orderp?: orderpUpdateManyWithoutClubInput
    popularproducts?: popularproductsUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateWithoutCashInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inventory?: inventoryUncheckedUpdateManyWithoutClubInput
    orderp?: orderpUncheckedUpdateManyWithoutClubInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateManyWithoutClubInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    idLocation?: IntFieldUpdateOperationsInput | number
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productUpdateWithoutCashInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutCashInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateManyWithoutProductInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientlocationCreateManyClientpeopleInput = {
    idClientLocation?: number
    idLocation: number
  }

  export type clientmembershipCreateManyClientpeopleInput = {
    idClientMembership?: number
    idMembership: number
  }

  export type orderpCreateManyClientpeopleInput = {
    idOrderP?: number
    orderDate: Date | string
    idClub: number
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
  }

  export type clientlocationUpdateWithoutClientpeopleInput = {
    location?: locationUpdateOneRequiredWithoutClientlocationInput
  }

  export type clientlocationUncheckedUpdateWithoutClientpeopleInput = {
    idClientLocation?: IntFieldUpdateOperationsInput | number
    idLocation?: IntFieldUpdateOperationsInput | number
  }

  export type clientlocationUncheckedUpdateManyWithoutClientlocationInput = {
    idClientLocation?: IntFieldUpdateOperationsInput | number
    idLocation?: IntFieldUpdateOperationsInput | number
  }

  export type clientmembershipUpdateWithoutClientpeopleInput = {
    membership?: membershipUpdateOneRequiredWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedUpdateWithoutClientpeopleInput = {
    idClientMembership?: IntFieldUpdateOperationsInput | number
    idMembership?: IntFieldUpdateOperationsInput | number
  }

  export type clientmembershipUncheckedUpdateManyWithoutClientmembershipInput = {
    idClientMembership?: IntFieldUpdateOperationsInput | number
    idMembership?: IntFieldUpdateOperationsInput | number
  }

  export type orderpUpdateWithoutClientpeopleInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    club?: clubUpdateOneRequiredWithoutOrderpInput
    orderline?: orderlineUpdateManyWithoutOrderpInput
  }

  export type orderpUncheckedUpdateWithoutClientpeopleInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idClub?: IntFieldUpdateOperationsInput | number
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedUpdateManyWithoutOrderpInput
  }

  export type orderpUncheckedUpdateManyWithoutOrderpInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idClub?: IntFieldUpdateOperationsInput | number
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type clientpeopleCreateManyClientuserInput = {
    idClientPeople?: number
    idInfoPeople: number
    salesCounter?: number
    isActive: boolean
  }

  export type reviewCreateManyClientuserInput = {
    idReview?: number
    idProduct: number
    score: number
    revDescription: string
    revDate: Date | string
  }

  export type workerreviewCreateManyClientuserInput = {
    idWorkerReview?: number
    idWorker: number
    dateWR: Date | string
  }

  export type clientpeopleUpdateWithoutClientuserInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    infopeople?: infopeopleUpdateOneRequiredWithoutClientpeopleInput
    clientlocation?: clientlocationUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUpdateManyWithoutClientpeopleInput
    orderp?: orderpUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateWithoutClientuserInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutClientpeopleInput
    orderp?: orderpUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateManyWithoutClientpeopleInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idInfoPeople?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reviewUpdateWithoutClientuserInput = {
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutClientuserInput = {
    idReview?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewUncheckedUpdateManyWithoutReviewInput = {
    idReview?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workerreviewUpdateWithoutClientuserInput = {
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: complaintUpdateManyWithoutWorkerreviewInput
    qualification?: qualificationUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedUpdateWithoutClientuserInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
    complaint?: complaintUncheckedUpdateManyWithoutWorkerreviewInput
    qualification?: qualificationUncheckedUpdateManyWithoutWorkerreviewInput
  }

  export type workerreviewUncheckedUpdateManyWithoutWorkerreviewInput = {
    idWorkerReview?: IntFieldUpdateOperationsInput | number
    idWorker?: IntFieldUpdateOperationsInput | number
    dateWR?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryCreateManyClubInput = {
    idInventory?: number
    idProduct: number
    stock?: number
    isActive: boolean
  }

  export type orderpCreateManyClubInput = {
    idOrderP?: number
    idClientPeople: number
    orderDate: Date | string
    idEmployer: number
    idMailer: number
    deliveryCost: Decimal | DecimalJsLike | number | string
  }

  export type popularproductsCreateManyClubInput = {
    idPopularProducts?: number
    idProduct: number
    amount?: number
  }

  export type inventoryUpdateWithoutClubInput = {
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    product?: productUpdateOneRequiredWithoutInventoryInput
  }

  export type inventoryUncheckedUpdateWithoutClubInput = {
    idInventory?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventoryUncheckedUpdateManyWithoutInventoryInput = {
    idInventory?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type orderpUpdateWithoutClubInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientpeople?: clientpeopleUpdateOneRequiredWithoutOrderpInput
    orderline?: orderlineUpdateManyWithoutOrderpInput
  }

  export type orderpUncheckedUpdateWithoutClubInput = {
    idOrderP?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmployer?: IntFieldUpdateOperationsInput | number
    idMailer?: IntFieldUpdateOperationsInput | number
    deliveryCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderline?: orderlineUncheckedUpdateManyWithoutOrderpInput
  }

  export type popularproductsUpdateWithoutClubInput = {
    amount?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutPopularproductsInput
  }

  export type popularproductsUncheckedUpdateWithoutClubInput = {
    idPopularProducts?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type popularproductsUncheckedUpdateManyWithoutPopularproductsInput = {
    idPopularProducts?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type cardCreateManyInfopeopleInput = {
    idCard?: number
    cardNumber: string
    expirationDate: Date | string
    cvv: number
  }

  export type clientpeopleCreateManyInfopeopleInput = {
    idClientPeople?: number
    idClientUser: number
    salesCounter?: number
    isActive: boolean
  }

  export type cardUpdateWithoutInfopeopleInput = {
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateWithoutInfopeopleInput = {
    idCard?: IntFieldUpdateOperationsInput | number
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateManyWithoutCardInput = {
    idCard?: IntFieldUpdateOperationsInput | number
    cardNumber?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cvv?: IntFieldUpdateOperationsInput | number
  }

  export type clientpeopleUpdateWithoutInfopeopleInput = {
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientuser?: clientuserUpdateOneRequiredWithoutClientpeopleInput
    clientlocation?: clientlocationUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUpdateManyWithoutClientpeopleInput
    orderp?: orderpUpdateManyWithoutClientpeopleInput
  }

  export type clientpeopleUncheckedUpdateWithoutInfopeopleInput = {
    idClientPeople?: IntFieldUpdateOperationsInput | number
    idClientUser?: IntFieldUpdateOperationsInput | number
    salesCounter?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientlocation?: clientlocationUncheckedUpdateManyWithoutClientpeopleInput
    clientmembership?: clientmembershipUncheckedUpdateManyWithoutClientpeopleInput
    orderp?: orderpUncheckedUpdateManyWithoutClientpeopleInput
  }

  export type clientlocationUpdateWithoutLocationInput = {
    clientpeople?: clientpeopleUpdateOneRequiredWithoutClientlocationInput
  }

  export type clientlocationUncheckedUpdateWithoutLocationInput = {
    idClientLocation?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
  }

  export type clientlocationCreateManyLocationInput = {
    idClientLocation?: number
    idClientPeople: number
  }

  export type clubUpdateWithoutLocationInput = {
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    cash?: cashUpdateOneRequiredWithoutClubInput
    inventory?: inventoryUpdateManyWithoutClubInput
    orderp?: orderpUpdateManyWithoutClubInput
    popularproducts?: popularproductsUpdateManyWithoutClubInput
  }

  export type clubUncheckedUpdateWithoutLocationInput = {
    idClub?: IntFieldUpdateOperationsInput | number
    clubName?: StringFieldUpdateOperationsInput | string
    deliveryCostProp?: FloatFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    inventory?: inventoryUncheckedUpdateManyWithoutClubInput
    orderp?: orderpUncheckedUpdateManyWithoutClubInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutClubInput
  }

  export type clubCreateManyLocationInput = {
    idClub?: number
    clubName: string
    deliveryCostProp: number
    idCash: number
    isActive: boolean
  }

  export type clientmembershipCreateManyMembershipInput = {
    idClientMembership?: number
    idClientPeople: number
  }

  export type clientmembershipUpdateWithoutMembershipInput = {
    clientpeople?: clientpeopleUpdateOneRequiredWithoutClientmembershipInput
  }

  export type clientmembershipUncheckedUpdateWithoutMembershipInput = {
    idClientMembership?: IntFieldUpdateOperationsInput | number
    idClientPeople?: IntFieldUpdateOperationsInput | number
  }

  export type orderlineCreateManyOrderpInput = {
    idOrderLine?: number
    idProduct: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type orderlineUpdateWithoutOrderpInput = {
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutOrderlineInput
  }

  export type orderlineUncheckedUpdateWithoutOrderpInput = {
    idOrderLine?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type orderlineUncheckedUpdateManyWithoutOrderlineInput = {
    idOrderLine?: IntFieldUpdateOperationsInput | number
    idProduct?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type inventoryCreateManyProductInput = {
    idInventory?: number
    idClub: number
    stock?: number
    isActive: boolean
  }

  export type orderlineCreateManyProductInput = {
    idOrderLine?: number
    idOrderP: number
    cost: Decimal | DecimalJsLike | number | string
    amount: number
  }

  export type popularproductsCreateManyProductInput = {
    idPopularProducts?: number
    amount?: number
    idClub: number
  }

  export type presentationCreateManyProductInput = {
    idPresentation?: number
    amountBottles: number
    sizeBottle: number
  }

  export type reviewCreateManyProductInput = {
    idReview?: number
    score: number
    revDescription: string
    idClientUser: number
    revDate: Date | string
  }

  export type inventoryUpdateWithoutProductInput = {
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    club?: clubUpdateOneRequiredWithoutInventoryInput
  }

  export type inventoryUncheckedUpdateWithoutProductInput = {
    idInventory?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type orderlineUpdateWithoutProductInput = {
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
    orderp?: orderpUpdateOneRequiredWithoutOrderlineInput
  }

  export type orderlineUncheckedUpdateWithoutProductInput = {
    idOrderLine?: IntFieldUpdateOperationsInput | number
    idOrderP?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type popularproductsUpdateWithoutProductInput = {
    amount?: IntFieldUpdateOperationsInput | number
    club?: clubUpdateOneRequiredWithoutPopularproductsInput
  }

  export type popularproductsUncheckedUpdateWithoutProductInput = {
    idPopularProducts?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    idClub?: IntFieldUpdateOperationsInput | number
  }

  export type presentationUpdateWithoutProductInput = {
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type presentationUncheckedUpdateWithoutProductInput = {
    idPresentation?: IntFieldUpdateOperationsInput | number
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type presentationUncheckedUpdateManyWithoutPresentationInput = {
    idPresentation?: IntFieldUpdateOperationsInput | number
    amountBottles?: IntFieldUpdateOperationsInput | number
    sizeBottle?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUpdateWithoutProductInput = {
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientuser?: clientuserUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutProductInput = {
    idReview?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    revDescription?: StringFieldUpdateOperationsInput | string
    idClientUser?: IntFieldUpdateOperationsInput | number
    revDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateManyProducttypeInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    image?: Buffer | null
    idSupplier: number
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
  }

  export type productUpdateWithoutProducttypeInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    supplier?: supplierUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutProducttypeInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idSupplier?: IntFieldUpdateOperationsInput | number
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type productCreateManySupplierInput = {
    idProduct?: number
    productName?: string | null
    cost: Decimal | DecimalJsLike | number | string
    idProductType: number
    image?: Buffer | null
    idCash: number
    isActive: boolean
    entryDate: Date | string
    tier?: number
    productDescr?: string | null
  }

  export type productUpdateWithoutSupplierInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    cash?: cashUpdateOneRequiredWithoutProductInput
    producttype?: producttypeUpdateOneRequiredWithoutProductInput
    inventory?: inventoryUpdateManyWithoutProductInput
    orderline?: orderlineUpdateManyWithoutProductInput
    popularproducts?: popularproductsUpdateManyWithoutProductInput
    presentation?: presentationUpdateManyWithoutProductInput
    review?: reviewUpdateManyWithoutProductInput
  }

  export type productUncheckedUpdateWithoutSupplierInput = {
    idProduct?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    idProductType?: IntFieldUpdateOperationsInput | number
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    idCash?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    entryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: IntFieldUpdateOperationsInput | number
    productDescr?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: inventoryUncheckedUpdateManyWithoutProductInput
    orderline?: orderlineUncheckedUpdateManyWithoutProductInput
    popularproducts?: popularproductsUncheckedUpdateManyWithoutProductInput
    presentation?: presentationUncheckedUpdateManyWithoutProductInput
    review?: reviewUncheckedUpdateManyWithoutProductInput
  }

  export type complaintCreateManyWorkerreviewInput = {
    idComplaint?: number
    compDescription: string
    solved: boolean
  }

  export type qualificationCreateManyWorkerreviewInput = {
    idQualification?: number
    qualDescription: string
  }

  export type complaintUpdateWithoutWorkerreviewInput = {
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintUncheckedUpdateWithoutWorkerreviewInput = {
    idComplaint?: IntFieldUpdateOperationsInput | number
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type complaintUncheckedUpdateManyWithoutComplaintInput = {
    idComplaint?: IntFieldUpdateOperationsInput | number
    compDescription?: StringFieldUpdateOperationsInput | string
    solved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qualificationUpdateWithoutWorkerreviewInput = {
    qualDescription?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateWithoutWorkerreviewInput = {
    idQualification?: IntFieldUpdateOperationsInput | number
    qualDescription?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateManyWithoutQualificationInput = {
    idQualification?: IntFieldUpdateOperationsInput | number
    qualDescription?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}